{"ast":null,"code":"import { keydownHandler } from 'prosemirror-keymap';\nimport { NodeSelection, Selection, Plugin, TextSelection } from 'prosemirror-state';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\nimport { Slice } from 'prosemirror-model'; // ::- Gap cursor selections are represented using this class. Its\n// `$anchor` and `$head` properties both point at the cursor position.\n\nvar GapCursor = /*@__PURE__*/function (Selection) {\n  function GapCursor($pos) {\n    Selection.call(this, $pos, $pos);\n  }\n\n  if (Selection) GapCursor.__proto__ = Selection;\n  GapCursor.prototype = Object.create(Selection && Selection.prototype);\n  GapCursor.prototype.constructor = GapCursor;\n\n  GapCursor.prototype.map = function map(doc, mapping) {\n    var $pos = doc.resolve(mapping.map(this.head));\n    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n  };\n\n  GapCursor.prototype.content = function content() {\n    return Slice.empty;\n  };\n\n  GapCursor.prototype.eq = function eq(other) {\n    return other instanceof GapCursor && other.head == this.head;\n  };\n\n  GapCursor.prototype.toJSON = function toJSON() {\n    return {\n      type: \"gapcursor\",\n      pos: this.head\n    };\n  };\n\n  GapCursor.fromJSON = function fromJSON(doc, json) {\n    if (typeof json.pos != \"number\") {\n      throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n    }\n\n    return new GapCursor(doc.resolve(json.pos));\n  };\n\n  GapCursor.prototype.getBookmark = function getBookmark() {\n    return new GapBookmark(this.anchor);\n  };\n\n  GapCursor.valid = function valid($pos) {\n    var parent = $pos.parent;\n\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) {\n      return false;\n    }\n\n    var override = parent.type.spec.allowGapCursor;\n\n    if (override != null) {\n      return override;\n    }\n\n    var deflt = parent.contentMatchAt($pos.index()).defaultType;\n    return deflt && deflt.isTextblock;\n  };\n\n  GapCursor.findFrom = function findFrom($pos, dir, mustMove) {\n    search: for (;;) {\n      if (!mustMove && GapCursor.valid($pos)) {\n        return $pos;\n      }\n\n      var pos = $pos.pos,\n          next = null; // Scan up from this position\n\n      for (var d = $pos.depth;; d--) {\n        var parent = $pos.node(d);\n\n        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n          break;\n        } else if (d == 0) {\n          return null;\n        }\n\n        pos += dir;\n        var $cur = $pos.doc.resolve(pos);\n\n        if (GapCursor.valid($cur)) {\n          return $cur;\n        }\n      } // And then down into the next node\n\n\n      for (;;) {\n        var inside = dir > 0 ? next.firstChild : next.lastChild;\n\n        if (!inside) {\n          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n            mustMove = false;\n            continue search;\n          }\n\n          break;\n        }\n\n        next = inside;\n        pos += dir;\n        var $cur$1 = $pos.doc.resolve(pos);\n\n        if (GapCursor.valid($cur$1)) {\n          return $cur$1;\n        }\n      }\n\n      return null;\n    }\n  };\n\n  return GapCursor;\n}(Selection);\n\nGapCursor.prototype.visible = false;\nSelection.jsonID(\"gapcursor\", GapCursor);\n\nvar GapBookmark = function GapBookmark(pos) {\n  this.pos = pos;\n};\n\nGapBookmark.prototype.map = function map(mapping) {\n  return new GapBookmark(mapping.map(this.pos));\n};\n\nGapBookmark.prototype.resolve = function resolve(doc) {\n  var $pos = doc.resolve(this.pos);\n  return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n};\n\nfunction closedBefore($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.index(d); // At the start of this parent, look at next one\n\n    if (index == 0) {\n      continue;\n    } // See if the node before (or its first ancestor) is closed\n\n\n    for (var before = $pos.node(d).child(index - 1);; before = before.lastChild) {\n      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) {\n        return true;\n      }\n\n      if (before.inlineContent) {\n        return false;\n      }\n    }\n  } // Hit start of document\n\n\n  return true;\n}\n\nfunction closedAfter($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.indexAfter(d),\n        parent = $pos.node(d);\n\n    if (index == parent.childCount) {\n      continue;\n    }\n\n    for (var after = parent.child(index);; after = after.firstChild) {\n      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) {\n        return true;\n      }\n\n      if (after.inlineContent) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n} // :: () â†’ Plugin\n// Create a gap cursor plugin. When enabled, this will capture clicks\n// near and arrow-key-motion past places that don't have a normally\n// selectable position nearby, and create a gap cursor selection for\n// them. The cursor is drawn as an element with class\n// `ProseMirror-gapcursor`. You can either include\n// `style/gapcursor.css` from the package's directory or add your own\n// styles to make it visible.\n\n\nvar gapCursor = function gapCursor() {\n  return new Plugin({\n    props: {\n      decorations: drawGapCursor,\n      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {\n        if ($anchor.pos == $head.pos && GapCursor.valid($head)) {\n          return new GapCursor($head);\n        }\n      },\n      handleClick: handleClick,\n      handleKeyDown: handleKeyDown\n    }\n  });\n};\n\nvar handleKeyDown = keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n});\n\nfunction arrow(axis, dir) {\n  var dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n    var $start = dir > 0 ? sel.$to : sel.$from,\n        mustMove = sel.empty;\n\n    if (sel instanceof TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) {\n        return false;\n      }\n\n      mustMove = false;\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n    }\n\n    var $found = GapCursor.findFrom($start, dir, mustMove);\n\n    if (!$found) {\n      return false;\n    }\n\n    if (dispatch) {\n      dispatch(state.tr.setSelection(new GapCursor($found)));\n    }\n\n    return true;\n  };\n}\n\nfunction handleClick(view, pos, event) {\n  if (!view.editable) {\n    return false;\n  }\n\n  var $pos = view.state.doc.resolve(pos);\n\n  if (!GapCursor.valid($pos)) {\n    return false;\n  }\n\n  var ref = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  var inside = ref.inside;\n\n  if (inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(inside))) {\n    return false;\n  }\n\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n  return true;\n}\n\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) {\n    return null;\n  }\n\n  var node = document.createElement(\"div\");\n  node.className = \"ProseMirror-gapcursor\";\n  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, {\n    key: \"gapcursor\"\n  })]);\n}\n\nexport { GapCursor, gapCursor };","map":null,"metadata":{},"sourceType":"module"}