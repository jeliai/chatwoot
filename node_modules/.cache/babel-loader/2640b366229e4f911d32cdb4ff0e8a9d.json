{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar md5_1 = __importDefault(require(\"tiny-hashes/md5\"));\n\nvar dlv_1 = __importDefault(require(\"dlv\"));\n\nvar math_base_special_ldexp_1 = __importDefault(require(\"@stdlib/math-base-special-ldexp\"));\n\nvar dset_1 = require(\"dset\");\n\nvar unset_1 = require(\"./unset\");\n\nfunction transform(payload, transformers) {\n  var transformedPayload = payload;\n\n  for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n    var transformer = transformers_1[_i];\n\n    switch (transformer.type) {\n      case 'drop':\n        return null;\n\n      case 'drop_properties':\n        dropProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'allow_properties':\n        allowProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'sample_event':\n        if (sampleEvent(transformedPayload, transformer.config)) {\n          break;\n        }\n\n        return null;\n\n      case 'map_properties':\n        mapProperties(transformedPayload, transformer.config);\n        break;\n\n      case 'hash_properties':\n        // Not yet supported, but don't throw an error. Just ignore.\n        break;\n\n      default:\n        throw new Error(\"Transformer of type \\\"\".concat(transformer.type, \"\\\" is unsupported.\"));\n    }\n  }\n\n  return transformedPayload;\n}\n\nexports.default = transform; // dropProperties removes all specified props from the object.\n\nfunction dropProperties(payload, config) {\n  for (var key in config.drop) {\n    if (!config.drop.hasOwnProperty(key)) {\n      continue;\n    } // If key is empty, it refers to the top-level object.\n\n\n    var field = key === '' ? payload : (0, dlv_1.default)(payload, key); // Can only drop props off of arrays and objects.\n\n    if (_typeof(field) !== 'object' || field === null) {\n      continue;\n    }\n\n    for (var _i = 0, _a = config.drop[key]; _i < _a.length; _i++) {\n      var target = _a[_i];\n      delete field[target];\n    }\n  }\n} // allowProperties ONLY allows the specific targets within the keys. (e.g. \"a.foo\": [\"bar\", \"baz\"]\n// on {a: {foo: {bar: 1, baz: 2}, other: 3}} will not have any drops, as it only looks inside a.foo\n\n\nfunction allowProperties(payload, config) {\n  for (var key in config.allow) {\n    if (!config.allow.hasOwnProperty(key)) {\n      continue;\n    } // If key is empty, it refers to the top-level object.\n\n\n    var field = key === '' ? payload : (0, dlv_1.default)(payload, key); // Can only drop props off of arrays and objects.\n\n    if (_typeof(field) !== 'object' || field === null) {\n      continue;\n    } // Execution order fortunately doesn't really matter (e.g. if someone filtered off of foo.bar, then foo.bar.baz)\n    // except for micro-optimization.\n\n\n    for (var k in field) {\n      if (!field.hasOwnProperty(k)) {\n        continue;\n      }\n\n      if (config.allow[key].indexOf(k) === -1) {\n        delete field[k];\n      }\n    }\n  }\n}\n\nfunction mapProperties(payload, config) {\n  // Some configs might try to modify or read from a field multiple times. We will only ever read\n  // values as they were before any modifications began. Thus, if you try to override e.g.\n  // {a: {b: 1}} with set(a, 'b', 2) (which results in {a: {b: 2}}) and then try to copy a.b into\n  // a.c, you will get {a: {b: 2, c:1}} and NOT {a: {b:2, c:2}}. This prevents map evaluation\n  // order from mattering, and === what server-side does.\n  // See: https://github.com/segmentio/tsub/blob/661695a63b60b90471796e667458f076af788c19/transformers/map_properties.go#L179-L200\n  var initialPayload = JSON.parse(JSON.stringify(payload));\n\n  for (var key in config.map) {\n    if (!config.map.hasOwnProperty(key)) {\n      continue;\n    }\n\n    var actionMap = config.map[key]; // Can't manipulate non-objects. Check that the parent is one. Strip the last .field\n    // from the string.\n\n    var splitKey = key.split('.');\n    var parent_1 = void 0;\n\n    if (splitKey.length > 1) {\n      splitKey.pop();\n      parent_1 = (0, dlv_1.default)(initialPayload, splitKey.join('.'));\n    } else {\n      parent_1 = payload;\n    }\n\n    if (_typeof(parent_1) !== 'object') {\n      continue;\n    } // These actions are exclusive to each other.\n\n\n    if (actionMap.copy) {\n      var valueToCopy = (0, dlv_1.default)(initialPayload, actionMap.copy);\n\n      if (valueToCopy !== undefined) {\n        (0, dset_1.dset)(payload, key, valueToCopy);\n      }\n    } else if (actionMap.move) {\n      var valueToMove = (0, dlv_1.default)(initialPayload, actionMap.move);\n\n      if (valueToMove !== undefined) {\n        (0, dset_1.dset)(payload, key, valueToMove);\n      }\n\n      (0, unset_1.unset)(payload, actionMap.move);\n    } // Have to check only if property exists, as null, undefined, and other vals could be explicitly set.\n    else if (actionMap.hasOwnProperty('set')) {\n        (0, dset_1.dset)(payload, key, actionMap.set);\n      } // to_string is not exclusive and can be paired with other actions. Final action.\n\n\n    if (actionMap.to_string) {\n      var valueToString = (0, dlv_1.default)(payload, key); // Do not string arrays and objects. Do not double-encode strings.\n\n      if (typeof valueToString === 'string' || _typeof(valueToString) === 'object' && valueToString !== null) {\n        continue;\n      } // TODO: Check stringifier in Golang for parity.\n\n\n      if (valueToString !== undefined) {\n        (0, dset_1.dset)(payload, key, JSON.stringify(valueToString));\n      } else {\n        // TODO: Check this behavior.\n        (0, dset_1.dset)(payload, key, 'undefined');\n      }\n    }\n  }\n}\n\nfunction sampleEvent(payload, config) {\n  if (config.sample.percent <= 0) {\n    return false;\n  } else if (config.sample.percent >= 1) {\n    return true;\n  } // If we're not filtering deterministically, just use raw percentage.\n\n\n  if (!config.sample.path) {\n    return samplePercent(config.sample.percent);\n  } // Otherwise, use a deterministic hash.\n\n\n  return sampleConsistentPercent(payload, config);\n}\n\nfunction samplePercent(percent) {\n  // Math.random returns [0, 1) => 0.0<>0.9999...\n  return Math.random() <= percent;\n} // sampleConsistentPercent converts an input string of bytes into a consistent uniform\n// continuous distribution of [0.0, 1.0]. This is based on\n// http://mumble.net/~campbell/tmp/random_real.c, but using the digest\n// result of the input value as the random information.\n// IMPORTANT - This function needs to === the Golang implementation to ensure that the two return the same vals!\n// See: https://github.com/segmentio/sampler/blob/65cb04132305a04fcd4bcaef67d57fbe40c30241/sampler.go#L13-L38\n// Since AJS supports IE9+ (typed arrays were introduced in IE10) we're doing some manual array math.\n// This could be done directly with strings, but arrays are easier to reason about/have better function support.\n\n\nfunction sampleConsistentPercent(payload, config) {\n  var field = (0, dlv_1.default)(payload, config.sample.path); // Operate off of JSON bytes. TODO: Validate all type behavior, esp. strings.\n\n  var digest = (0, md5_1.default)(JSON.stringify(field));\n  var exponent = -64; // Manually maintain 64-bit int as an array.\n\n  var significand = []; // Left-shift and OR for first 8 bytes of digest. (8 bytes * 8 = 64 bits)\n\n  consumeDigest(digest.slice(0, 8), significand);\n  var leadingZeros = 0;\n\n  for (var i = 0; i < 64; i++) {\n    if (significand[i] === 1) {\n      break;\n    }\n\n    leadingZeros++;\n  }\n\n  if (leadingZeros !== 0) {\n    // Use the last 8 bytes of the digest, same as before.\n    var val = [];\n    consumeDigest(digest.slice(9, 16), val);\n    exponent -= leadingZeros; // Left-shift away leading zeros in significand.\n\n    significand.splice(0, leadingZeros); // Right-shift val by 64 minus leading zeros and push into significand.\n\n    val.splice(64 - leadingZeros);\n    significand = significand.concat(val);\n  } // Flip 64th bit\n\n\n  significand[63] = significand[63] === 0 ? 1 : 0; // Convert our manual binary into a JS num (binary arr => binary string => psuedo-int) and run the ldexp!\n\n  return (0, math_base_special_ldexp_1.default)(parseInt(significand.join(''), 2), exponent) < config.sample.percent;\n} // Array byte filler helper\n\n\nfunction consumeDigest(digest, arr) {\n  for (var i = 0; i < 8; i++) {\n    var remainder = digest[i];\n\n    for (var binary = 128; binary >= 1; binary /= 2) {\n      if (remainder - binary >= 0) {\n        remainder -= binary;\n        arr.push(1);\n      } else {\n        arr.push(0);\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}