{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { Alias, Group, Identify, Page, Track } from '@segment/facade';\nimport { isOffline, isOnline } from '../../core/connection';\nimport { Context, ContextCancelation } from '../../core/context';\nimport { isServer } from '../../core/environment';\nimport { attempt } from '../../core/queue/delivery';\nimport { asPromise } from '../../lib/as-promise';\nimport { mergedOptions } from '../../lib/merged-options';\nimport { pWhile } from '../../lib/p-while';\nimport { PersistedPriorityQueue } from '../../lib/priority-queue/persisted';\nimport { applyDestinationMiddleware } from '../middleware';\nimport { tsubMiddleware } from '../routing-middleware';\nimport { loadIntegration, resolveVersion, unloadIntegration } from './loader';\n\nvar klona = function klona(evt) {\n  return JSON.parse(JSON.stringify(evt));\n};\n\nfunction flushQueue(xt, queue) {\n  return __awaiter(this, void 0, void 0, function () {\n    var failedQueue;\n\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          failedQueue = [];\n\n          if (isOffline()) {\n            return [2\n            /*return*/\n            , queue];\n          }\n\n          return [4\n          /*yield*/\n          , pWhile(function () {\n            return queue.length > 0 && isOnline();\n          }, function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var ctx, result, success;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    ctx = queue.pop();\n\n                    if (!ctx) {\n                      return [2\n                      /*return*/\n                      ];\n                    }\n\n                    return [4\n                    /*yield*/\n                    , attempt(ctx, xt)];\n\n                  case 1:\n                    result = _a.sent();\n                    success = result instanceof Context;\n\n                    if (!success) {\n                      failedQueue.push(ctx);\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }) // re-add failed tasks\n          ];\n\n        case 1:\n          _a.sent(); // re-add failed tasks\n\n\n          failedQueue.map(function (failed) {\n            return queue.pushWithBackoff(failed);\n          });\n          return [2\n          /*return*/\n          , queue];\n      }\n    });\n  });\n}\n\nvar LegacyDestination =\n/** @class */\nfunction () {\n  function LegacyDestination(name, version, settings, options) {\n    if (settings === void 0) {\n      settings = {};\n    }\n\n    this.options = {};\n    this.type = 'destination';\n    this.middleware = [];\n    this._ready = false;\n    this._initialized = false;\n    this.flushing = false;\n    this.name = name;\n    this.version = version;\n    this.settings = __assign({}, settings); // AJS-Renderer sets an extraneous `type` setting that clobbers\n    // existing type defaults. We need to remove it if it's present\n\n    if (this.settings['type'] && this.settings['type'] === 'browser') {\n      delete this.settings['type'];\n    }\n\n    this.options = options;\n    this.buffer = new PersistedPriorityQueue(4, \"dest-\" + name);\n    this.scheduleFlush();\n  }\n\n  LegacyDestination.prototype.isLoaded = function () {\n    return this._ready;\n  };\n\n  LegacyDestination.prototype.ready = function () {\n    var _a;\n\n    return (_a = this.onReady) !== null && _a !== void 0 ? _a : Promise.resolve();\n  };\n\n  LegacyDestination.prototype.load = function (ctx, analyticsInstance) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (this._ready || this.onReady !== undefined) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            _a = this;\n            return [4\n            /*yield*/\n            , loadIntegration(ctx, analyticsInstance, this.name, this.version, this.settings)];\n\n          case 1:\n            _a.integration = _b.sent();\n            this.onReady = new Promise(function (resolve) {\n              var onReadyFn = function onReadyFn() {\n                _this._ready = true;\n                resolve(true);\n              };\n\n              _this.integration.once('ready', onReadyFn);\n            });\n            this.onInitialize = new Promise(function (resolve) {\n              var onInit = function onInit() {\n                _this._initialized = true;\n                resolve(true);\n              };\n\n              _this.integration.on('initialize', onInit);\n            });\n\n            try {\n              ctx.stats.increment('analytics_js.integration.invoke', 1, [\"method:initialize\", \"integration_name:\" + this.name]);\n              this.integration.initialize();\n            } catch (error) {\n              ctx.stats.increment('analytics_js.integration.invoke.error', 1, [\"method:initialize\", \"integration_name:\" + this.name]);\n              throw error;\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  LegacyDestination.prototype.unload = function (_ctx, _analyticsInstance) {\n    return unloadIntegration(this.name, this.version);\n  };\n\n  LegacyDestination.prototype.addMiddleware = function () {\n    var _a;\n\n    var fn = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fn[_i] = arguments[_i];\n    }\n\n    this.middleware = (_a = this.middleware).concat.apply(_a, fn);\n  };\n\n  LegacyDestination.prototype.shouldBuffer = function (ctx) {\n    return (// page events can't be buffered because of destinations that automatically add page views\n      ctx.event.type !== 'page' && (isOffline() || this._ready === false || this._initialized === false)\n    );\n  };\n\n  LegacyDestination.prototype.send = function (ctx, clz, eventType) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var plan, ev, planEvent, afterMiddleware, event, err_1;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            if (this.shouldBuffer(ctx)) {\n              this.buffer.push(ctx);\n              this.scheduleFlush();\n              return [2\n              /*return*/\n              , ctx];\n            }\n\n            plan = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.plan) === null || _b === void 0 ? void 0 : _b.track;\n            ev = ctx.event.event;\n\n            if (plan && ev && this.name !== 'Segment.io') {\n              planEvent = plan[ev];\n\n              if ((planEvent === null || planEvent === void 0 ? void 0 : planEvent.enabled) === false) {\n                ctx.updateEvent('integrations', __assign(__assign({}, ctx.event.integrations), {\n                  All: false,\n                  'Segment.io': true\n                }));\n                ctx.cancel(new ContextCancelation({\n                  retry: false,\n                  reason: \"Event \" + ev + \" disabled for integration \" + this.name + \" in tracking plan\",\n                  type: 'Dropped by plan'\n                }));\n                return [2\n                /*return*/\n                , ctx];\n              } else {\n                ctx.updateEvent('integrations', __assign(__assign({}, ctx.event.integrations), planEvent === null || planEvent === void 0 ? void 0 : planEvent.integrations));\n              }\n\n              if ((planEvent === null || planEvent === void 0 ? void 0 : planEvent.enabled) && (planEvent === null || planEvent === void 0 ? void 0 : planEvent.integrations[this.name]) === false) {\n                ctx.cancel(new ContextCancelation({\n                  retry: false,\n                  reason: \"Event \" + ev + \" disabled for integration \" + this.name + \" in tracking plan\",\n                  type: 'Dropped by plan'\n                }));\n                return [2\n                /*return*/\n                , ctx];\n              }\n            }\n\n            return [4\n            /*yield*/\n            , applyDestinationMiddleware(this.name, klona(ctx.event), this.middleware)];\n\n          case 1:\n            afterMiddleware = _c.sent();\n\n            if (afterMiddleware === null) {\n              return [2\n              /*return*/\n              , ctx];\n            }\n\n            event = new clz(afterMiddleware, {});\n            ctx.stats.increment('analytics_js.integration.invoke', 1, [\"method:\" + eventType, \"integration_name:\" + this.name]);\n            _c.label = 2;\n\n          case 2:\n            _c.trys.push([2, 5,, 6]);\n\n            if (!this.integration) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , asPromise(this.integration.invoke.call(this.integration, eventType, event))];\n\n          case 3:\n            _c.sent();\n\n            _c.label = 4;\n\n          case 4:\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            err_1 = _c.sent();\n            ctx.stats.increment('analytics_js.integration.invoke.error', 1, [\"method:\" + eventType, \"integration_name:\" + this.name]);\n            throw err_1;\n\n          case 6:\n            return [2\n            /*return*/\n            , ctx];\n        }\n      });\n    });\n  };\n\n  LegacyDestination.prototype.track = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.send(ctx, Track, 'track')];\n      });\n    });\n  };\n\n  LegacyDestination.prototype.page = function (ctx) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        if (((_a = this.integration) === null || _a === void 0 ? void 0 : _a._assumesPageview) && !this._initialized) {\n          this.integration.initialize();\n        }\n\n        return [2\n        /*return*/\n        , this.onInitialize.then(function () {\n          return _this.send(ctx, Page, 'page');\n        })];\n      });\n    });\n  };\n\n  LegacyDestination.prototype.identify = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.send(ctx, Identify, 'identify')];\n      });\n    });\n  };\n\n  LegacyDestination.prototype.alias = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.send(ctx, Alias, 'alias')];\n      });\n    });\n  };\n\n  LegacyDestination.prototype.group = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.send(ctx, Group, 'group')];\n      });\n    });\n  };\n\n  LegacyDestination.prototype.scheduleFlush = function () {\n    var _this = this;\n\n    if (this.flushing) {\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n\n    setTimeout(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              this.flushing = true;\n              _a = this;\n              return [4\n              /*yield*/\n              , flushQueue(this, this.buffer)];\n\n            case 1:\n              _a.buffer = _b.sent();\n              this.flushing = false;\n\n              if (this.buffer.todo > 0) {\n                this.scheduleFlush();\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }, Math.random() * 5000);\n  };\n\n  return LegacyDestination;\n}();\n\nexport { LegacyDestination };\nexport function ajsDestinations(settings, globalIntegrations, options) {\n  var _a, _b;\n\n  if (globalIntegrations === void 0) {\n    globalIntegrations = {};\n  }\n\n  return __awaiter(this, void 0, void 0, function () {\n    var routingRules, routingMiddleware, integrationOptions;\n    return __generator(this, function (_c) {\n      if (isServer()) {\n        return [2\n        /*return*/\n        , []];\n      }\n\n      if (settings.plan) {\n        options = options !== null && options !== void 0 ? options : {};\n        options.plan = settings.plan;\n      }\n\n      routingRules = (_b = (_a = settings.middlewareSettings) === null || _a === void 0 ? void 0 : _a.routingRules) !== null && _b !== void 0 ? _b : [];\n      routingMiddleware = tsubMiddleware(routingRules);\n      integrationOptions = mergedOptions(settings, options !== null && options !== void 0 ? options : {});\n      return [2\n      /*return*/\n      , Object.entries(settings.integrations).map(function (_a) {\n        var _b;\n\n        var name = _a[0],\n            integrationSettings = _a[1];\n\n        if (name.startsWith('Segment')) {\n          return;\n        }\n\n        var allDisableAndNotDefined = globalIntegrations.All === false && globalIntegrations[name] === undefined;\n\n        if (globalIntegrations[name] === false || allDisableAndNotDefined) {\n          return;\n        }\n\n        var type = integrationSettings.type,\n            bundlingStatus = integrationSettings.bundlingStatus,\n            versionSettings = integrationSettings.versionSettings; // We use `!== 'unbundled'` (versus `=== 'bundled'`) to be inclusive of\n        // destinations without a defined value for `bundlingStatus`\n\n        var deviceMode = bundlingStatus !== 'unbundled' && (type === 'browser' || ((_b = versionSettings === null || versionSettings === void 0 ? void 0 : versionSettings.componentTypes) === null || _b === void 0 ? void 0 : _b.includes('browser'))); // checking for iterable is a quick fix we need in place to prevent\n        // errors showing Iterable as a failed destiantion. Ideally, we should\n        // fix the Iterable metadata instead, but that's a longer process.\n\n        if (!deviceMode && name !== 'Segment.io' || name === 'Iterable') {\n          return;\n        }\n\n        var version = resolveVersion(integrationSettings);\n        var destination = new LegacyDestination(name, version, integrationOptions[name], options);\n        var routing = routingRules.filter(function (rule) {\n          return rule.destinationName === name;\n        });\n\n        if (routing.length > 0) {\n          destination.addMiddleware(routingMiddleware);\n        }\n\n        return destination;\n      }).filter(function (xt) {\n        return xt !== undefined;\n      })];\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"module"}