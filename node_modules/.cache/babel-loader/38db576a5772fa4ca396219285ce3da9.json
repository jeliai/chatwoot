{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { v4 as uuid } from '@lukeed/uuid';\nimport { dset } from 'dset';\nimport md5 from 'spark-md5';\nexport * from './interfaces';\n\nvar EventFactory =\n/** @class */\nfunction () {\n  function EventFactory(user) {\n    this.user = user;\n  }\n\n  EventFactory.prototype.track = function (event, properties, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      event: event,\n      type: 'track',\n      properties: properties,\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    }));\n  };\n\n  EventFactory.prototype.page = function (category, page, properties, options, globalIntegrations) {\n    var _a;\n\n    var event = {\n      type: 'page',\n      properties: __assign({}, properties),\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n\n    if (category !== null) {\n      event.category = category;\n      event.properties = (_a = event.properties) !== null && _a !== void 0 ? _a : {};\n      event.properties.category = category;\n    }\n\n    if (page !== null) {\n      event.name = page;\n    }\n\n    return this.normalize(__assign(__assign({}, this.baseEvent()), event));\n  };\n\n  EventFactory.prototype.screen = function (category, screen, properties, options, globalIntegrations) {\n    var event = {\n      type: 'screen',\n      properties: __assign({}, properties),\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n\n    if (category !== null) {\n      event.category = category;\n    }\n\n    if (screen !== null) {\n      event.name = screen;\n    }\n\n    return this.normalize(__assign(__assign({}, this.baseEvent()), event));\n  };\n\n  EventFactory.prototype.identify = function (userId, traits, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      type: 'identify',\n      userId: userId,\n      traits: traits,\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    }));\n  };\n\n  EventFactory.prototype.group = function (groupId, traits, options, globalIntegrations) {\n    return this.normalize(__assign(__assign({}, this.baseEvent()), {\n      type: 'group',\n      traits: traits,\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations),\n      groupId: groupId\n    }));\n  };\n\n  EventFactory.prototype.alias = function (to, from, options, globalIntegrations) {\n    var base = {\n      userId: to,\n      type: 'alias',\n      options: __assign({}, options),\n      integrations: __assign({}, globalIntegrations)\n    };\n\n    if (from !== null) {\n      base.previousId = from;\n    }\n\n    if (to === undefined) {\n      return this.normalize(__assign(__assign({}, base), this.baseEvent()));\n    }\n\n    return this.normalize(__assign(__assign({}, this.baseEvent()), base));\n  };\n\n  EventFactory.prototype.baseEvent = function () {\n    var base = {\n      integrations: {},\n      options: {}\n    };\n\n    if (this.user.id()) {\n      base.userId = this.user.id();\n    }\n\n    base.anonymousId = this.user.anonymousId();\n    return base;\n  };\n  /**\n   * Builds the context part of an event based on \"foreign\" keys that\n   * are provided in the `Options` parameter for an Event\n   */\n\n\n  EventFactory.prototype.context = function (event) {\n    var _a, _b, _c;\n\n    var optionsKeys = ['integrations', 'anonymousId', 'timestamp', 'userId'];\n    var options = (_a = event.options) !== null && _a !== void 0 ? _a : {};\n    delete options['integrations'];\n    var providedOptionsKeys = Object.keys(options);\n    var context = (_c = (_b = event.options) === null || _b === void 0 ? void 0 : _b.context) !== null && _c !== void 0 ? _c : {};\n    var overrides = {};\n    providedOptionsKeys.forEach(function (key) {\n      if (key === 'context') {\n        return;\n      }\n\n      if (optionsKeys.includes(key)) {\n        dset(overrides, key, options[key]);\n      } else {\n        dset(context, key, options[key]);\n      }\n    });\n    return [context, overrides];\n  };\n\n  EventFactory.prototype.normalize = function (event) {\n    var _a, _b;\n\n    var integrationBooleans = Object.keys((_a = event.integrations) !== null && _a !== void 0 ? _a : {}).reduce(function (integrationNames, name) {\n      var _a;\n\n      var _b;\n\n      return __assign(__assign({}, integrationNames), (_a = {}, _a[name] = Boolean((_b = event.integrations) === null || _b === void 0 ? void 0 : _b[name]), _a));\n    }, {}); // This is pretty trippy, but here's what's going on:\n    // - a) We don't pass initial integration options as part of the event, only if they're true or false\n    // - b) We do accept per integration overrides (like integrations.Amplitude.sessionId) at the event level\n    // Hence the need to convert base integration options to booleans, but maintain per event integration overrides\n\n    var allIntegrations = __assign(__assign({}, integrationBooleans), (_b = event.options) === null || _b === void 0 ? void 0 : _b.integrations);\n\n    var _c = this.context(event),\n        context = _c[0],\n        overrides = _c[1];\n\n    var options = event.options,\n        rest = __rest(event, [\"options\"]);\n\n    var body = __assign(__assign(__assign({}, rest), {\n      context: context,\n      integrations: allIntegrations\n    }), overrides);\n\n    var messageId = 'ajs-next-' + md5.hash(JSON.stringify(body) + uuid());\n\n    var evt = __assign(__assign({}, body), {\n      messageId: messageId\n    });\n\n    return evt;\n  };\n\n  return EventFactory;\n}();\n\nexport { EventFactory };","map":null,"metadata":{},"sourceType":"module"}