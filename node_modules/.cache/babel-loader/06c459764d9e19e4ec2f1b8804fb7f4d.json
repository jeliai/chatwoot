{"ast":null,"code":"import { Schema, Mark } from 'prosemirror-model';\nimport markdownit from 'markdown-it'; // ::Schema Document schema for the data model used by CommonMark.\n\nvar schema = new Schema({\n  nodes: {\n    doc: {\n      content: \"block+\"\n    },\n    paragraph: {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{\n        tag: \"p\"\n      }],\n      toDOM: function toDOM() {\n        return [\"p\", 0];\n      }\n    },\n    blockquote: {\n      content: \"block+\",\n      group: \"block\",\n      parseDOM: [{\n        tag: \"blockquote\"\n      }],\n      toDOM: function toDOM() {\n        return [\"blockquote\", 0];\n      }\n    },\n    horizontal_rule: {\n      group: \"block\",\n      parseDOM: [{\n        tag: \"hr\"\n      }],\n      toDOM: function toDOM() {\n        return [\"div\", [\"hr\"]];\n      }\n    },\n    heading: {\n      attrs: {\n        level: {\n          default: 1\n        }\n      },\n      content: \"(text | image)*\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [{\n        tag: \"h1\",\n        attrs: {\n          level: 1\n        }\n      }, {\n        tag: \"h2\",\n        attrs: {\n          level: 2\n        }\n      }, {\n        tag: \"h3\",\n        attrs: {\n          level: 3\n        }\n      }, {\n        tag: \"h4\",\n        attrs: {\n          level: 4\n        }\n      }, {\n        tag: \"h5\",\n        attrs: {\n          level: 5\n        }\n      }, {\n        tag: \"h6\",\n        attrs: {\n          level: 6\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"h\" + node.attrs.level, 0];\n      }\n    },\n    code_block: {\n      content: \"text*\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      marks: \"\",\n      attrs: {\n        params: {\n          default: \"\"\n        }\n      },\n      parseDOM: [{\n        tag: \"pre\",\n        preserveWhitespace: \"full\",\n        getAttrs: function getAttrs(node) {\n          return {\n            params: node.getAttribute(\"data-params\") || \"\"\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"pre\", node.attrs.params ? {\n          \"data-params\": node.attrs.params\n        } : {}, [\"code\", 0]];\n      }\n    },\n    ordered_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {\n        order: {\n          default: 1\n        },\n        tight: {\n          default: false\n        }\n      },\n      parseDOM: [{\n        tag: \"ol\",\n        getAttrs: function getAttrs(dom) {\n          return {\n            order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1,\n            tight: dom.hasAttribute(\"data-tight\")\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"ol\", {\n          start: node.attrs.order == 1 ? null : node.attrs.order,\n          \"data-tight\": node.attrs.tight ? \"true\" : null\n        }, 0];\n      }\n    },\n    bullet_list: {\n      content: \"list_item+\",\n      group: \"block\",\n      attrs: {\n        tight: {\n          default: false\n        }\n      },\n      parseDOM: [{\n        tag: \"ul\",\n        getAttrs: function getAttrs(dom) {\n          return {\n            tight: dom.hasAttribute(\"data-tight\")\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"ul\", {\n          \"data-tight\": node.attrs.tight ? \"true\" : null\n        }, 0];\n      }\n    },\n    list_item: {\n      content: \"paragraph block*\",\n      defining: true,\n      parseDOM: [{\n        tag: \"li\"\n      }],\n      toDOM: function toDOM() {\n        return [\"li\", 0];\n      }\n    },\n    text: {\n      group: \"inline\"\n    },\n    image: {\n      inline: true,\n      attrs: {\n        src: {},\n        alt: {\n          default: null\n        },\n        title: {\n          default: null\n        }\n      },\n      group: \"inline\",\n      draggable: true,\n      parseDOM: [{\n        tag: \"img[src]\",\n        getAttrs: function getAttrs(dom) {\n          return {\n            src: dom.getAttribute(\"src\"),\n            title: dom.getAttribute(\"title\"),\n            alt: dom.getAttribute(\"alt\")\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"img\", node.attrs];\n      }\n    },\n    hard_break: {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{\n        tag: \"br\"\n      }],\n      toDOM: function toDOM() {\n        return [\"br\"];\n      }\n    }\n  },\n  marks: {\n    em: {\n      parseDOM: [{\n        tag: \"i\"\n      }, {\n        tag: \"em\"\n      }, {\n        style: \"font-style\",\n        getAttrs: function getAttrs(value) {\n          return value == \"italic\" && null;\n        }\n      }],\n      toDOM: function toDOM() {\n        return [\"em\"];\n      }\n    },\n    strong: {\n      parseDOM: [{\n        tag: \"b\"\n      }, {\n        tag: \"strong\"\n      }, {\n        style: \"font-weight\",\n        getAttrs: function getAttrs(value) {\n          return /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null;\n        }\n      }],\n      toDOM: function toDOM() {\n        return [\"strong\"];\n      }\n    },\n    link: {\n      attrs: {\n        href: {},\n        title: {\n          default: null\n        }\n      },\n      inclusive: false,\n      parseDOM: [{\n        tag: \"a[href]\",\n        getAttrs: function getAttrs(dom) {\n          return {\n            href: dom.getAttribute(\"href\"),\n            title: dom.getAttribute(\"title\")\n          };\n        }\n      }],\n      toDOM: function toDOM(node) {\n        return [\"a\", node.attrs];\n      }\n    },\n    code: {\n      parseDOM: [{\n        tag: \"code\"\n      }],\n      toDOM: function toDOM() {\n        return [\"code\"];\n      }\n    }\n  }\n});\n\nfunction maybeMerge(a, b) {\n  if (a.isText && b.isText && Mark.sameSet(a.marks, b.marks)) {\n    return a.withText(a.text + b.text);\n  }\n} // Object used to track the context of a running parse.\n\n\nvar MarkdownParseState = function MarkdownParseState(schema, tokenHandlers) {\n  this.schema = schema;\n  this.stack = [{\n    type: schema.topNodeType,\n    content: []\n  }];\n  this.marks = Mark.none;\n  this.tokenHandlers = tokenHandlers;\n};\n\nMarkdownParseState.prototype.top = function top() {\n  return this.stack[this.stack.length - 1];\n};\n\nMarkdownParseState.prototype.push = function push(elt) {\n  if (this.stack.length) {\n    this.top().content.push(elt);\n  }\n}; // : (string)\n// Adds the given text to the current position in the document,\n// using the current marks as styling.\n\n\nMarkdownParseState.prototype.addText = function addText(text) {\n  if (!text) {\n    return;\n  }\n\n  var nodes = this.top().content,\n      last = nodes[nodes.length - 1];\n  var node = this.schema.text(text, this.marks),\n      merged;\n\n  if (last && (merged = maybeMerge(last, node))) {\n    nodes[nodes.length - 1] = merged;\n  } else {\n    nodes.push(node);\n  }\n}; // : (Mark)\n// Adds the given mark to the set of active marks.\n\n\nMarkdownParseState.prototype.openMark = function openMark(mark) {\n  this.marks = mark.addToSet(this.marks);\n}; // : (Mark)\n// Removes the given mark from the set of active marks.\n\n\nMarkdownParseState.prototype.closeMark = function closeMark(mark) {\n  this.marks = mark.removeFromSet(this.marks);\n};\n\nMarkdownParseState.prototype.parseTokens = function parseTokens(toks) {\n  for (var i = 0; i < toks.length; i++) {\n    var tok = toks[i];\n    var handler = this.tokenHandlers[tok.type];\n\n    if (!handler) {\n      throw new Error(\"Token type `\" + tok.type + \"` not supported by Markdown parser\");\n    }\n\n    handler(this, tok, toks, i);\n  }\n}; // : (NodeType, ?Object, ?[Node]) → ?Node\n// Add a node at the current position.\n\n\nMarkdownParseState.prototype.addNode = function addNode(type, attrs, content) {\n  var node = type.createAndFill(attrs, content, this.marks);\n\n  if (!node) {\n    return null;\n  }\n\n  this.push(node);\n  return node;\n}; // : (NodeType, ?Object)\n// Wrap subsequent content in a node of the given type.\n\n\nMarkdownParseState.prototype.openNode = function openNode(type, attrs) {\n  this.stack.push({\n    type: type,\n    attrs: attrs,\n    content: []\n  });\n}; // : () → ?Node\n// Close and return the node that is currently on top of the stack.\n\n\nMarkdownParseState.prototype.closeNode = function closeNode() {\n  if (this.marks.length) {\n    this.marks = Mark.none;\n  }\n\n  var info = this.stack.pop();\n  return this.addNode(info.type, info.attrs, info.content);\n};\n\nfunction attrs(spec, token, tokens, i) {\n  if (spec.getAttrs) {\n    return spec.getAttrs(token, tokens, i);\n  } // For backwards compatibility when `attrs` is a Function\n  else if (spec.attrs instanceof Function) {\n      return spec.attrs(token);\n    } else {\n      return spec.attrs;\n    }\n} // Code content is represented as a single token with a `content`\n// property in Markdown-it.\n\n\nfunction noCloseToken(spec, type) {\n  return spec.noCloseToken || type == \"code_inline\" || type == \"code_block\" || type == \"fence\";\n}\n\nfunction withoutTrailingNewline(str) {\n  return str[str.length - 1] == \"\\n\" ? str.slice(0, str.length - 1) : str;\n}\n\nfunction noOp() {}\n\nfunction tokenHandlers(schema, tokens) {\n  var handlers = Object.create(null);\n\n  var loop = function loop(type) {\n    var spec = tokens[type];\n\n    if (spec.block) {\n      var nodeType = schema.nodeType(spec.block);\n\n      if (noCloseToken(spec, type)) {\n        handlers[type] = function (state, tok, tokens, i) {\n          state.openNode(nodeType, attrs(spec, tok, tokens, i));\n          state.addText(withoutTrailingNewline(tok.content));\n          state.closeNode();\n        };\n      } else {\n        handlers[type + \"_open\"] = function (state, tok, tokens, i) {\n          return state.openNode(nodeType, attrs(spec, tok, tokens, i));\n        };\n\n        handlers[type + \"_close\"] = function (state) {\n          return state.closeNode();\n        };\n      }\n    } else if (spec.node) {\n      var nodeType$1 = schema.nodeType(spec.node);\n\n      handlers[type] = function (state, tok, tokens, i) {\n        return state.addNode(nodeType$1, attrs(spec, tok, tokens, i));\n      };\n    } else if (spec.mark) {\n      var markType = schema.marks[spec.mark];\n\n      if (noCloseToken(spec, type)) {\n        handlers[type] = function (state, tok, tokens, i) {\n          state.openMark(markType.create(attrs(spec, tok, tokens, i)));\n          state.addText(withoutTrailingNewline(tok.content));\n          state.closeMark(markType);\n        };\n      } else {\n        handlers[type + \"_open\"] = function (state, tok, tokens, i) {\n          return state.openMark(markType.create(attrs(spec, tok, tokens, i)));\n        };\n\n        handlers[type + \"_close\"] = function (state) {\n          return state.closeMark(markType);\n        };\n      }\n    } else if (spec.ignore) {\n      if (noCloseToken(spec, type)) {\n        handlers[type] = noOp;\n      } else {\n        handlers[type + '_open'] = noOp;\n        handlers[type + '_close'] = noOp;\n      }\n    } else {\n      throw new RangeError(\"Unrecognized parsing spec \" + JSON.stringify(spec));\n    }\n  };\n\n  for (var type in tokens) {\n    loop(type);\n  }\n\n  handlers.text = function (state, tok) {\n    return state.addText(tok.content);\n  };\n\n  handlers.inline = function (state, tok) {\n    return state.parseTokens(tok.children);\n  };\n\n  handlers.softbreak = handlers.softbreak || function (state) {\n    return state.addText(\"\\n\");\n  };\n\n  return handlers;\n} // ::- A configuration of a Markdown parser. Such a parser uses\n// [markdown-it](https://github.com/markdown-it/markdown-it) to\n// tokenize a file, and then runs the custom rules it is given over\n// the tokens to create a ProseMirror document tree.\n\n\nvar MarkdownParser = function MarkdownParser(schema, tokenizer, tokens) {\n  // :: Object The value of the `tokens` object used to construct\n  // this parser. Can be useful to copy and modify to base other\n  // parsers on.\n  this.tokens = tokens;\n  this.schema = schema;\n  this.tokenizer = tokenizer;\n  this.tokenHandlers = tokenHandlers(schema, tokens);\n}; // :: (string) → Node\n// Parse a string as [CommonMark](http://commonmark.org/) markup,\n// and create a ProseMirror document as prescribed by this parser's\n// rules.\n\n\nMarkdownParser.prototype.parse = function parse(text) {\n  var state = new MarkdownParseState(this.schema, this.tokenHandlers),\n      doc;\n  state.parseTokens(this.tokenizer.parse(text, {}));\n\n  do {\n    doc = state.closeNode();\n  } while (state.stack.length);\n\n  return doc;\n};\n\nfunction listIsTight(tokens, i) {\n  while (++i < tokens.length) {\n    if (tokens[i].type != \"list_item_open\") {\n      return tokens[i].hidden;\n    }\n  }\n\n  return false;\n} // :: MarkdownParser\n// A parser parsing unextended [CommonMark](http://commonmark.org/),\n// without inline HTML, and producing a document in the basic schema.\n\n\nvar defaultMarkdownParser = new MarkdownParser(schema, markdownit(\"commonmark\", {\n  html: false\n}), {\n  blockquote: {\n    block: \"blockquote\"\n  },\n  paragraph: {\n    block: \"paragraph\"\n  },\n  list_item: {\n    block: \"list_item\"\n  },\n  bullet_list: {\n    block: \"bullet_list\",\n    getAttrs: function getAttrs(_, tokens, i) {\n      return {\n        tight: listIsTight(tokens, i)\n      };\n    }\n  },\n  ordered_list: {\n    block: \"ordered_list\",\n    getAttrs: function getAttrs(tok, tokens, i) {\n      return {\n        order: +tok.attrGet(\"start\") || 1,\n        tight: listIsTight(tokens, i)\n      };\n    }\n  },\n  heading: {\n    block: \"heading\",\n    getAttrs: function getAttrs(tok) {\n      return {\n        level: +tok.tag.slice(1)\n      };\n    }\n  },\n  code_block: {\n    block: \"code_block\",\n    noCloseToken: true\n  },\n  fence: {\n    block: \"code_block\",\n    getAttrs: function getAttrs(tok) {\n      return {\n        params: tok.info || \"\"\n      };\n    },\n    noCloseToken: true\n  },\n  hr: {\n    node: \"horizontal_rule\"\n  },\n  image: {\n    node: \"image\",\n    getAttrs: function getAttrs(tok) {\n      return {\n        src: tok.attrGet(\"src\"),\n        title: tok.attrGet(\"title\") || null,\n        alt: tok.children[0] && tok.children[0].content || null\n      };\n    }\n  },\n  hardbreak: {\n    node: \"hard_break\"\n  },\n  em: {\n    mark: \"em\"\n  },\n  strong: {\n    mark: \"strong\"\n  },\n  link: {\n    mark: \"link\",\n    getAttrs: function getAttrs(tok) {\n      return {\n        href: tok.attrGet(\"href\"),\n        title: tok.attrGet(\"title\") || null\n      };\n    }\n  },\n  code_inline: {\n    mark: \"code\",\n    noCloseToken: true\n  }\n}); // ::- A specification for serializing a ProseMirror document as\n// Markdown/CommonMark text.\n\nvar MarkdownSerializer = function MarkdownSerializer(nodes, marks) {\n  // :: Object<(MarkdownSerializerState, Node)> The node serializer\n  // functions for this serializer.\n  this.nodes = nodes; // :: Object The mark serializer info.\n\n  this.marks = marks;\n}; // :: (Node, ?Object) → string\n// Serialize the content of the given node to\n// [CommonMark](http://commonmark.org/).\n\n\nMarkdownSerializer.prototype.serialize = function serialize(content, options) {\n  var state = new MarkdownSerializerState(this.nodes, this.marks, options);\n  state.renderContent(content);\n  return state.out;\n}; // :: MarkdownSerializer\n// A serializer for the [basic schema](#schema).\n\n\nvar defaultMarkdownSerializer = new MarkdownSerializer({\n  blockquote: function blockquote(state, node) {\n    state.wrapBlock(\"> \", null, node, function () {\n      return state.renderContent(node);\n    });\n  },\n  code_block: function code_block(state, node) {\n    state.write(\"```\" + (node.attrs.params || \"\") + \"\\n\");\n    state.text(node.textContent, false);\n    state.ensureNewLine();\n    state.write(\"```\");\n    state.closeBlock(node);\n  },\n  heading: function heading(state, node) {\n    state.write(state.repeat(\"#\", node.attrs.level) + \" \");\n    state.renderInline(node);\n    state.closeBlock(node);\n  },\n  horizontal_rule: function horizontal_rule(state, node) {\n    state.write(node.attrs.markup || \"---\");\n    state.closeBlock(node);\n  },\n  bullet_list: function bullet_list(state, node) {\n    state.renderList(node, \"  \", function () {\n      return (node.attrs.bullet || \"*\") + \" \";\n    });\n  },\n  ordered_list: function ordered_list(state, node) {\n    var start = node.attrs.order || 1;\n    var maxW = String(start + node.childCount - 1).length;\n    var space = state.repeat(\" \", maxW + 2);\n    state.renderList(node, space, function (i) {\n      var nStr = String(start + i);\n      return state.repeat(\" \", maxW - nStr.length) + nStr + \". \";\n    });\n  },\n  list_item: function list_item(state, node) {\n    state.renderContent(node);\n  },\n  paragraph: function paragraph(state, node) {\n    state.renderInline(node);\n    state.closeBlock(node);\n  },\n  image: function image(state, node) {\n    state.write(\"![\" + state.esc(node.attrs.alt || \"\") + \"](\" + state.esc(node.attrs.src) + (node.attrs.title ? \" \" + state.quote(node.attrs.title) : \"\") + \")\");\n  },\n  hard_break: function hard_break(state, node, parent, index) {\n    for (var i = index + 1; i < parent.childCount; i++) {\n      if (parent.child(i).type != node.type) {\n        state.write(\"\\\\\\n\");\n        return;\n      }\n    }\n  },\n  text: function text(state, node) {\n    state.text(node.text);\n  }\n}, {\n  em: {\n    open: \"*\",\n    close: \"*\",\n    mixable: true,\n    expelEnclosingWhitespace: true\n  },\n  strong: {\n    open: \"**\",\n    close: \"**\",\n    mixable: true,\n    expelEnclosingWhitespace: true\n  },\n  link: {\n    open: function open(_state, mark, parent, index) {\n      return isPlainURL(mark, parent, index, 1) ? \"<\" : \"[\";\n    },\n    close: function close(state, mark, parent, index) {\n      return isPlainURL(mark, parent, index, -1) ? \">\" : \"](\" + state.esc(mark.attrs.href) + (mark.attrs.title ? \" \" + state.quote(mark.attrs.title) : \"\") + \")\";\n    }\n  },\n  code: {\n    open: function open(_state, _mark, parent, index) {\n      return backticksFor(parent.child(index), -1);\n    },\n    close: function close(_state, _mark, parent, index) {\n      return backticksFor(parent.child(index - 1), 1);\n    },\n    escape: false\n  }\n});\n\nfunction backticksFor(node, side) {\n  var ticks = /`+/g,\n      m,\n      len = 0;\n\n  if (node.isText) {\n    while (m = ticks.exec(node.text)) {\n      len = Math.max(len, m[0].length);\n    }\n  }\n\n  var result = len > 0 && side > 0 ? \" `\" : \"`\";\n\n  for (var i = 0; i < len; i++) {\n    result += \"`\";\n  }\n\n  if (len > 0 && side < 0) {\n    result += \" \";\n  }\n\n  return result;\n}\n\nfunction isPlainURL(link, parent, index, side) {\n  if (link.attrs.title || !/^\\w+:/.test(link.attrs.href)) {\n    return false;\n  }\n\n  var content = parent.child(index + (side < 0 ? -1 : 0));\n\n  if (!content.isText || content.text != link.attrs.href || content.marks[content.marks.length - 1] != link) {\n    return false;\n  }\n\n  if (index == (side < 0 ? 1 : parent.childCount - 1)) {\n    return true;\n  }\n\n  var next = parent.child(index + (side < 0 ? -2 : 1));\n  return !link.isInSet(next.marks);\n} // ::- This is an object used to track state and expose\n// methods related to markdown serialization. Instances are passed to\n// node and mark serialization methods (see `toMarkdown`).\n\n\nvar MarkdownSerializerState = function MarkdownSerializerState(nodes, marks, options) {\n  this.nodes = nodes;\n  this.marks = marks;\n  this.delim = this.out = \"\";\n  this.closed = false;\n  this.inTightList = false; // :: Object\n  // The options passed to the serializer.\n  // tightLists:: ?bool\n  // Whether to render lists in a tight style. This can be overridden\n  // on a node level by specifying a tight attribute on the node.\n  // Defaults to false.\n\n  this.options = options || {};\n\n  if (typeof this.options.tightLists == \"undefined\") {\n    this.options.tightLists = false;\n  }\n};\n\nMarkdownSerializerState.prototype.flushClose = function flushClose(size) {\n  if (this.closed) {\n    if (!this.atBlank()) {\n      this.out += \"\\n\";\n    }\n\n    if (size == null) {\n      size = 2;\n    }\n\n    if (size > 1) {\n      var delimMin = this.delim;\n      var trim = /\\s+$/.exec(delimMin);\n\n      if (trim) {\n        delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n      }\n\n      for (var i = 1; i < size; i++) {\n        this.out += delimMin + \"\\n\";\n      }\n    }\n\n    this.closed = false;\n  }\n}; // :: (string, ?string, Node, ())\n// Render a block, prefixing each line with `delim`, and the first\n// line in `firstDelim`. `node` should be the node that is closed at\n// the end of the block, and `f` is a function that renders the\n// content of the block.\n\n\nMarkdownSerializerState.prototype.wrapBlock = function wrapBlock(delim, firstDelim, node, f) {\n  var old = this.delim;\n  this.write(firstDelim || delim);\n  this.delim += delim;\n  f();\n  this.delim = old;\n  this.closeBlock(node);\n};\n\nMarkdownSerializerState.prototype.atBlank = function atBlank() {\n  return /(^|\\n)$/.test(this.out);\n}; // :: ()\n// Ensure the current content ends with a newline.\n\n\nMarkdownSerializerState.prototype.ensureNewLine = function ensureNewLine() {\n  if (!this.atBlank()) {\n    this.out += \"\\n\";\n  }\n}; // :: (?string)\n// Prepare the state for writing output (closing closed paragraphs,\n// adding delimiters, and so on), and then optionally add content\n// (unescaped) to the output.\n\n\nMarkdownSerializerState.prototype.write = function write(content) {\n  this.flushClose();\n\n  if (this.delim && this.atBlank()) {\n    this.out += this.delim;\n  }\n\n  if (content) {\n    this.out += content;\n  }\n}; // :: (Node)\n// Close the block for the given node.\n\n\nMarkdownSerializerState.prototype.closeBlock = function closeBlock(node) {\n  this.closed = node;\n}; // :: (string, ?bool)\n// Add the given text to the document. When escape is not `false`,\n// it will be escaped.\n\n\nMarkdownSerializerState.prototype.text = function text(text$1, escape) {\n  var lines = text$1.split(\"\\n\");\n\n  for (var i = 0; i < lines.length; i++) {\n    var startOfLine = this.atBlank() || this.closed;\n    this.write();\n    this.out += escape !== false ? this.esc(lines[i], startOfLine) : lines[i];\n\n    if (i != lines.length - 1) {\n      this.out += \"\\n\";\n    }\n  }\n}; // :: (Node)\n// Render the given node as a block.\n\n\nMarkdownSerializerState.prototype.render = function render(node, parent, index) {\n  if (typeof parent == \"number\") {\n    throw new Error(\"!\");\n  }\n\n  if (!this.nodes[node.type.name]) {\n    throw new Error(\"Token type `\" + node.type.name + \"` not supported by Markdown renderer\");\n  }\n\n  this.nodes[node.type.name](this, node, parent, index);\n}; // :: (Node)\n// Render the contents of `parent` as block nodes.\n\n\nMarkdownSerializerState.prototype.renderContent = function renderContent(parent) {\n  var this$1 = this;\n  parent.forEach(function (node, _, i) {\n    return this$1.render(node, parent, i);\n  });\n}; // :: (Node)\n// Render the contents of `parent` as inline content.\n\n\nMarkdownSerializerState.prototype.renderInline = function renderInline(parent) {\n  var this$1 = this;\n  var active = [],\n      trailing = \"\";\n\n  var progress = function progress(node, _, index) {\n    var marks = node ? node.marks : []; // Remove marks from `hard_break` that are the last node inside\n    // that mark to prevent parser edge cases with new lines just\n    // before closing marks.\n    // (FIXME it'd be nice if we had a schema-agnostic way to\n    // identify nodes that serialize as hard breaks)\n\n    if (node && node.type.name === \"hard_break\") {\n      marks = marks.filter(function (m) {\n        if (index + 1 == parent.childCount) {\n          return false;\n        }\n\n        var next = parent.child(index + 1);\n        return m.isInSet(next.marks) && (!next.isText || /\\S/.test(next.text));\n      });\n    }\n\n    var leading = trailing;\n    trailing = \"\"; // If whitespace has to be expelled from the node, adjust\n    // leading and trailing accordingly.\n\n    if (node && node.isText && marks.some(function (mark) {\n      var info = this$1.marks[mark.type.name];\n      return info && info.expelEnclosingWhitespace;\n    })) {\n      var ref = /^(\\s*)(.*?)(\\s*)$/m.exec(node.text);\n      var _$1 = ref[0];\n      var lead = ref[1];\n      var inner$1 = ref[2];\n      var trail = ref[3];\n      leading += lead;\n      trailing = trail;\n\n      if (lead || trail) {\n        node = inner$1 ? node.withText(inner$1) : null;\n\n        if (!node) {\n          marks = active;\n        }\n      }\n    }\n\n    var inner = marks.length && marks[marks.length - 1],\n        noEsc = inner && this$1.marks[inner.type.name].escape === false;\n    var len = marks.length - (noEsc ? 1 : 0); // Try to reorder 'mixable' marks, such as em and strong, which\n    // in Markdown may be opened and closed in different order, so\n    // that order of the marks for the token matches the order in\n    // active.\n\n    outer: for (var i = 0; i < len; i++) {\n      var mark = marks[i];\n\n      if (!this$1.marks[mark.type.name].mixable) {\n        break;\n      }\n\n      for (var j = 0; j < active.length; j++) {\n        var other = active[j];\n\n        if (!this$1.marks[other.type.name].mixable) {\n          break;\n        }\n\n        if (mark.eq(other)) {\n          if (i > j) {\n            marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len));\n          } else if (j > i) {\n            marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len));\n          }\n\n          continue outer;\n        }\n      }\n    } // Find the prefix of the mark set that didn't change\n\n\n    var keep = 0;\n\n    while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) {\n      ++keep;\n    } // Close the marks that need to be closed\n\n\n    while (keep < active.length) {\n      this$1.text(this$1.markString(active.pop(), false, parent, index), false);\n    } // Output any previously expelled trailing whitespace outside the marks\n\n\n    if (leading) {\n      this$1.text(leading);\n    } // Open the marks that need to be opened\n\n\n    if (node) {\n      while (active.length < len) {\n        var add = marks[active.length];\n        active.push(add);\n        this$1.text(this$1.markString(add, true, parent, index), false);\n      } // Render the node. Special case code marks, since their content\n      // may not be escaped.\n\n\n      if (noEsc && node.isText) {\n        this$1.text(this$1.markString(inner, true, parent, index) + node.text + this$1.markString(inner, false, parent, index + 1), false);\n      } else {\n        this$1.render(node, parent, index);\n      }\n    }\n  };\n\n  parent.forEach(progress);\n  progress(null, null, parent.childCount);\n}; // :: (Node, string, (number) → string)\n// Render a node's content as a list. `delim` should be the extra\n// indentation added to all lines except the first in an item,\n// `firstDelim` is a function going from an item index to a\n// delimiter for the first line of the item.\n\n\nMarkdownSerializerState.prototype.renderList = function renderList(node, delim, firstDelim) {\n  var this$1 = this;\n\n  if (this.closed && this.closed.type == node.type) {\n    this.flushClose(3);\n  } else if (this.inTightList) {\n    this.flushClose(1);\n  }\n\n  var isTight = typeof node.attrs.tight != \"undefined\" ? node.attrs.tight : this.options.tightLists;\n  var prevTight = this.inTightList;\n  this.inTightList = isTight;\n  node.forEach(function (child, _, i) {\n    if (i && isTight) {\n      this$1.flushClose(1);\n    }\n\n    this$1.wrapBlock(delim, firstDelim(i), node, function () {\n      return this$1.render(child, node, i);\n    });\n  });\n  this.inTightList = prevTight;\n}; // :: (string, ?bool) → string\n// Escape the given string so that it can safely appear in Markdown\n// content. If `startOfLine` is true, also escape characters that\n// have special meaning only at the start of the line.\n\n\nMarkdownSerializerState.prototype.esc = function esc(str, startOfLine) {\n  str = str.replace(/[`*\\\\~\\[\\]]/g, \"\\\\$&\");\n\n  if (startOfLine) {\n    str = str.replace(/^[:#\\-*+]/, \"\\\\$&\").replace(/^(\\s*\\d+)\\./, \"$1\\\\.\");\n  }\n\n  return str;\n};\n\nMarkdownSerializerState.prototype.quote = function quote(str) {\n  var wrap = str.indexOf('\"') == -1 ? '\"\"' : str.indexOf(\"'\") == -1 ? \"''\" : \"()\";\n  return wrap[0] + str + wrap[1];\n}; // :: (string, number) → string\n// Repeat the given string `n` times.\n\n\nMarkdownSerializerState.prototype.repeat = function repeat(str, n) {\n  var out = \"\";\n\n  for (var i = 0; i < n; i++) {\n    out += str;\n  }\n\n  return out;\n}; // : (Mark, bool, string?) → string\n// Get the markdown string for a given opening or closing mark.\n\n\nMarkdownSerializerState.prototype.markString = function markString(mark, open, parent, index) {\n  var info = this.marks[mark.type.name];\n  var value = open ? info.open : info.close;\n  return typeof value == \"string\" ? value : value(this, mark, parent, index);\n}; // :: (string) → { leading: ?string, trailing: ?string }\n// Get leading and trailing whitespace from a string. Values of\n// leading or trailing property of the return object will be undefined\n// if there is no match.\n\n\nMarkdownSerializerState.prototype.getEnclosingWhitespace = function getEnclosingWhitespace(text) {\n  return {\n    leading: (text.match(/^(\\s+)/) || [])[0],\n    trailing: (text.match(/(\\s+)$/) || [])[0]\n  };\n};\n\nexport { MarkdownParser, MarkdownSerializer, MarkdownSerializerState, defaultMarkdownParser, defaultMarkdownSerializer, schema };","map":null,"metadata":{},"sourceType":"module"}