{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { getEventDescription, isMatchingPattern, logger } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from '../flags'; // \"Script error.\" is hard coded into browsers for errors that it can't read.\n// this is the result of a script being pulled in from an external domain and CORS.\n\nvar DEFAULT_IGNORE_ERRORS = [/^Script error\\.?$/, /^Javascript error: Script error\\.? on line 0$/];\n/** Inbound filters configurable by the user */\n\nvar InboundFilters =\n/** @class */\nfunction () {\n  function InboundFilters(_options) {\n    if (_options === void 0) {\n      _options = {};\n    }\n\n    this._options = _options;\n    /**\n     * @inheritDoc\n     */\n\n    this.name = InboundFilters.id;\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  InboundFilters.prototype.setupOnce = function (addGlobalEventProcessor, getCurrentHub) {\n    addGlobalEventProcessor(function (event) {\n      var hub = getCurrentHub();\n\n      if (hub) {\n        var self_1 = hub.getIntegration(InboundFilters);\n\n        if (self_1) {\n          var client = hub.getClient();\n          var clientOptions = client ? client.getOptions() : {};\n\n          var options = _mergeOptions(self_1._options, clientOptions);\n\n          return _shouldDropEvent(event, options) ? null : event;\n        }\n      }\n\n      return event;\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  InboundFilters.id = 'InboundFilters';\n  return InboundFilters;\n}();\n\nexport { InboundFilters };\n/** JSDoc */\n\nexport function _mergeOptions(internalOptions, clientOptions) {\n  if (internalOptions === void 0) {\n    internalOptions = {};\n  }\n\n  if (clientOptions === void 0) {\n    clientOptions = {};\n  }\n\n  return {\n    allowUrls: __spread(internalOptions.whitelistUrls || [], internalOptions.allowUrls || [], clientOptions.whitelistUrls || [], clientOptions.allowUrls || []),\n    denyUrls: __spread(internalOptions.blacklistUrls || [], internalOptions.denyUrls || [], clientOptions.blacklistUrls || [], clientOptions.denyUrls || []),\n    ignoreErrors: __spread(internalOptions.ignoreErrors || [], clientOptions.ignoreErrors || [], DEFAULT_IGNORE_ERRORS),\n    ignoreInternal: internalOptions.ignoreInternal !== undefined ? internalOptions.ignoreInternal : true\n  };\n}\n/** JSDoc */\n\nexport function _shouldDropEvent(event, options) {\n  if (options.ignoreInternal && _isSentryError(event)) {\n    IS_DEBUG_BUILD && logger.warn(\"Event dropped due to being internal Sentry Error.\\nEvent: \" + getEventDescription(event));\n    return true;\n  }\n\n  if (_isIgnoredError(event, options.ignoreErrors)) {\n    IS_DEBUG_BUILD && logger.warn(\"Event dropped due to being matched by `ignoreErrors` option.\\nEvent: \" + getEventDescription(event));\n    return true;\n  }\n\n  if (_isDeniedUrl(event, options.denyUrls)) {\n    IS_DEBUG_BUILD && logger.warn(\"Event dropped due to being matched by `denyUrls` option.\\nEvent: \" + getEventDescription(event) + \".\\nUrl: \" + _getEventFilterUrl(event));\n    return true;\n  }\n\n  if (!_isAllowedUrl(event, options.allowUrls)) {\n    IS_DEBUG_BUILD && logger.warn(\"Event dropped due to not being matched by `allowUrls` option.\\nEvent: \" + getEventDescription(event) + \".\\nUrl: \" + _getEventFilterUrl(event));\n    return true;\n  }\n\n  return false;\n}\n\nfunction _isIgnoredError(event, ignoreErrors) {\n  if (!ignoreErrors || !ignoreErrors.length) {\n    return false;\n  }\n\n  return _getPossibleEventMessages(event).some(function (message) {\n    return ignoreErrors.some(function (pattern) {\n      return isMatchingPattern(message, pattern);\n    });\n  });\n}\n\nfunction _isDeniedUrl(event, denyUrls) {\n  // TODO: Use Glob instead?\n  if (!denyUrls || !denyUrls.length) {\n    return false;\n  }\n\n  var url = _getEventFilterUrl(event);\n\n  return !url ? false : denyUrls.some(function (pattern) {\n    return isMatchingPattern(url, pattern);\n  });\n}\n\nfunction _isAllowedUrl(event, allowUrls) {\n  // TODO: Use Glob instead?\n  if (!allowUrls || !allowUrls.length) {\n    return true;\n  }\n\n  var url = _getEventFilterUrl(event);\n\n  return !url ? true : allowUrls.some(function (pattern) {\n    return isMatchingPattern(url, pattern);\n  });\n}\n\nfunction _getPossibleEventMessages(event) {\n  if (event.message) {\n    return [event.message];\n  }\n\n  if (event.exception) {\n    try {\n      var _a = event.exception.values && event.exception.values[0] || {},\n          _b = _a.type,\n          type = _b === void 0 ? '' : _b,\n          _c = _a.value,\n          value = _c === void 0 ? '' : _c;\n\n      return [\"\" + value, type + \": \" + value];\n    } catch (oO) {\n      IS_DEBUG_BUILD && logger.error(\"Cannot extract message for event \" + getEventDescription(event));\n      return [];\n    }\n  }\n\n  return [];\n}\n\nfunction _isSentryError(event) {\n  try {\n    // @ts-ignore can't be a sentry error if undefined\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    return event.exception.values[0].type === 'SentryError';\n  } catch (e) {// ignore\n  }\n\n  return false;\n}\n\nfunction _getLastValidUrl(frames) {\n  if (frames === void 0) {\n    frames = [];\n  }\n\n  for (var i = frames.length - 1; i >= 0; i--) {\n    var frame = frames[i];\n\n    if (frame && frame.filename !== '<anonymous>' && frame.filename !== '[native code]') {\n      return frame.filename || null;\n    }\n  }\n\n  return null;\n}\n\nfunction _getEventFilterUrl(event) {\n  try {\n    if (event.stacktrace) {\n      return _getLastValidUrl(event.stacktrace.frames);\n    }\n\n    var frames_1;\n\n    try {\n      // @ts-ignore we only care about frames if the whole thing here is defined\n      frames_1 = event.exception.values[0].stacktrace.frames;\n    } catch (e) {// ignore\n    }\n\n    return frames_1 ? _getLastValidUrl(frames_1) : null;\n  } catch (oO) {\n    IS_DEBUG_BUILD && logger.error(\"Cannot extract url for event \" + getEventDescription(event));\n    return null;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}