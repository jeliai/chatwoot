{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n!function (e, t) {\n  \"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) && \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) ? exports.Recorder = t() : e.Recorder = t();\n}(\"undefined\" != typeof self ? self : this, function () {\n  return function (e) {\n    var t = {};\n\n    function o(n) {\n      if (t[n]) return t[n].exports;\n      var i = t[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return e[n].call(i.exports, i, i.exports, o), i.l = !0, i.exports;\n    }\n\n    return o.m = e, o.c = t, o.d = function (e, t, n) {\n      o.o(e, t) || Object.defineProperty(e, t, {\n        enumerable: !0,\n        get: n\n      });\n    }, o.r = function (e) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, o.t = function (e, t) {\n      if (1 & t && (e = o(e)), 8 & t) return e;\n      if (4 & t && \"object\" == _typeof(e) && e && e.__esModule) return e;\n      var n = Object.create(null);\n      if (o.r(n), Object.defineProperty(n, \"default\", {\n        enumerable: !0,\n        value: e\n      }), 2 & t && \"string\" != typeof e) for (var i in e) {\n        o.d(n, i, function (t) {\n          return e[t];\n        }.bind(null, i));\n      }\n      return n;\n    }, o.n = function (e) {\n      var t = e && e.__esModule ? function () {\n        return e.default;\n      } : function () {\n        return e;\n      };\n      return o.d(t, \"a\", t), t;\n    }, o.o = function (e, t) {\n      return Object.prototype.hasOwnProperty.call(e, t);\n    }, o.p = \"\", o(o.s = 0);\n  }([function (e, t, o) {\n    \"use strict\";\n\n    (function (t) {\n      function o(e, t) {\n        if (null == e) return {};\n\n        var o,\n            n,\n            i = function (e, t) {\n          if (null == e) return {};\n          var o,\n              n,\n              i = {},\n              r = Object.keys(e);\n\n          for (n = 0; n < r.length; n++) {\n            o = r[n], t.indexOf(o) >= 0 || (i[o] = e[o]);\n          }\n\n          return i;\n        }(e, t);\n\n        if (Object.getOwnPropertySymbols) {\n          var r = Object.getOwnPropertySymbols(e);\n\n          for (n = 0; n < r.length; n++) {\n            o = r[n], t.indexOf(o) >= 0 || Object.prototype.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n          }\n        }\n\n        return i;\n      }\n\n      var n = t.AudioContext || t.webkitAudioContext,\n          i = function e() {\n        var t = this,\n            o = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n        if (!e.isRecordingSupported()) throw new Error(\"Recording is not supported in this browser\");\n        this.state = \"inactive\", this.config = Object.assign({\n          bufferLength: 4096,\n          encoderApplication: 2049,\n          encoderFrameSize: 20,\n          encoderPath: \"encoderWorker.min.js\",\n          encoderSampleRate: 48e3,\n          maxFramesPerPage: 40,\n          mediaTrackConstraints: !0,\n          monitorGain: 0,\n          numberOfChannels: 1,\n          recordingGain: 1,\n          resampleQuality: 3,\n          streamPages: !1,\n          wavBitDepth: 16,\n          sourceNode: {\n            context: null\n          }\n        }, o), this.encodedSamplePosition = 0, this.initAudioContext(), this.initialize = this.initWorklet().then(function () {\n          return t.initEncoder();\n        });\n      };\n\n      i.isRecordingSupported = function () {\n        var e = t.navigator && t.navigator.mediaDevices && t.navigator.mediaDevices.getUserMedia;\n        return n && e && t.WebAssembly;\n      }, i.version = \"8.0.5\", i.prototype.clearStream = function () {\n        this.stream && (this.stream.getTracks ? this.stream.getTracks().forEach(function (e) {\n          return e.stop();\n        }) : this.stream.stop());\n      }, i.prototype.close = function () {\n        return this.monitorGainNode.disconnect(), this.recordingGainNode.disconnect(), this.sourceNode && this.sourceNode.disconnect(), this.clearStream(), this.encoder && (this.encoderNode.disconnect(), this.encoder.postMessage({\n          command: \"close\"\n        })), this.config.sourceNode.context ? Promise.resolve() : this.audioContext.close();\n      }, i.prototype.encodeBuffers = function (e) {\n        if (\"recording\" === this.state) {\n          for (var t = [], o = 0; o < e.numberOfChannels; o++) {\n            t[o] = e.getChannelData(o);\n          }\n\n          this.encoder.postMessage({\n            command: \"encode\",\n            buffers: t\n          });\n        }\n      }, i.prototype.initAudioContext = function () {\n        this.audioContext = this.config.sourceNode.context ? this.config.sourceNode.context : new n(), this.monitorGainNode = this.audioContext.createGain(), this.setMonitorGain(this.config.monitorGain), this.recordingGainNode = this.audioContext.createGain(), this.setRecordingGain(this.config.recordingGain);\n      }, i.prototype.initEncoder = function () {\n        var e = this;\n        this.audioContext.audioWorklet ? (this.encoderNode = new AudioWorkletNode(this.audioContext, \"encoder-worklet\", {\n          numberOfOutputs: 0\n        }), this.encoder = this.encoderNode.port) : (console.log(\"audioWorklet support not detected. Falling back to scriptProcessor\"), this.encodeBuffers = function () {\n          return delete e.encodeBuffers;\n        }, this.encoderNode = this.audioContext.createScriptProcessor(this.config.bufferLength, this.config.numberOfChannels, this.config.numberOfChannels), this.encoderNode.onaudioprocess = function (t) {\n          var o = t.inputBuffer;\n          return e.encodeBuffers(o);\n        }, this.encoderNode.connect(this.audioContext.destination), this.encoder = new t.Worker(this.config.encoderPath));\n      }, i.prototype.initSourceNode = function () {\n        var e = this;\n        return this.config.sourceNode.context ? (this.sourceNode = this.config.sourceNode, Promise.resolve()) : t.navigator.mediaDevices.getUserMedia({\n          audio: this.config.mediaTrackConstraints\n        }).then(function (t) {\n          e.stream = t, e.sourceNode = e.audioContext.createMediaStreamSource(t);\n        });\n      }, i.prototype.initWorker = function () {\n        var e = this,\n            t = (this.config.streamPages ? this.streamPage : this.storePage).bind(this);\n        return this.recordedPages = [], this.totalLength = 0, new Promise(function (n) {\n          e.encoder.addEventListener(\"message\", function o(i) {\n            var r = i.data;\n\n            switch (r.message) {\n              case \"ready\":\n                n();\n                break;\n\n              case \"page\":\n                e.encodedSamplePosition = r.samplePosition, t(r.page);\n                break;\n\n              case \"done\":\n                e.encoder.removeEventListener(\"message\", o), e.finish();\n            }\n          }), e.encoder.start && e.encoder.start();\n          var i = e.config,\n              r = (i.sourceNode, o(i, [\"sourceNode\"]));\n          e.encoder.postMessage(Object.assign({\n            command: \"init\",\n            originalSampleRate: e.audioContext.sampleRate,\n            wavSampleRate: e.audioContext.sampleRate\n          }, r));\n        });\n      }, i.prototype.initWorklet = function () {\n        return this.audioContext.audioWorklet ? this.audioContext.audioWorklet.addModule(this.config.encoderPath) : Promise.resolve();\n      }, i.prototype.pause = function (e) {\n        var t = this;\n        if (\"recording\" === this.state) return this.state = \"paused\", this.recordingGainNode.disconnect(), e && this.config.streamPages ? new Promise(function (e) {\n          t.encoder.addEventListener(\"message\", function o(n) {\n            \"flushed\" === n.data.message && (t.encoder.removeEventListener(\"message\", o), t.onpause(), e());\n          }), t.encoder.start && t.encoder.start(), t.encoder.postMessage({\n            command: \"flush\"\n          });\n        }) : (this.onpause(), Promise.resolve());\n      }, i.prototype.resume = function () {\n        \"paused\" === this.state && (this.state = \"recording\", this.recordingGainNode.connect(this.encoderNode), this.onresume());\n      }, i.prototype.setRecordingGain = function (e) {\n        this.config.recordingGain = e, this.recordingGainNode && this.audioContext && this.recordingGainNode.gain.setTargetAtTime(e, this.audioContext.currentTime, .01);\n      }, i.prototype.setMonitorGain = function (e) {\n        this.config.monitorGain = e, this.monitorGainNode && this.audioContext && this.monitorGainNode.gain.setTargetAtTime(e, this.audioContext.currentTime, .01);\n      }, i.prototype.start = function () {\n        var e = this;\n        return \"inactive\" === this.state ? (this.state = \"loading\", this.encodedSamplePosition = 0, this.audioContext.resume().then(function () {\n          return e.initialize;\n        }).then(function () {\n          return Promise.all([e.initSourceNode(), e.initWorker()]);\n        }).then(function () {\n          e.state = \"recording\", e.encoder.postMessage({\n            command: \"getHeaderPages\"\n          }), e.sourceNode.connect(e.monitorGainNode), e.sourceNode.connect(e.recordingGainNode), e.monitorGainNode.connect(e.audioContext.destination), e.recordingGainNode.connect(e.encoderNode), e.onstart();\n        }).catch(function (t) {\n          throw e.state = \"inactive\", t;\n        })) : Promise.resolve();\n      }, i.prototype.stop = function () {\n        var e = this;\n        return \"paused\" === this.state || \"recording\" === this.state ? (this.state = \"inactive\", this.recordingGainNode.connect(this.encoderNode), this.monitorGainNode.disconnect(), this.clearStream(), new Promise(function (t) {\n          e.encoder.addEventListener(\"message\", function o(n) {\n            \"done\" === n.data.message && (e.encoder.removeEventListener(\"message\", o), t());\n          }), e.encoder.start && e.encoder.start(), e.encoder.postMessage({\n            command: \"done\"\n          });\n        })) : Promise.resolve();\n      }, i.prototype.storePage = function (e) {\n        this.recordedPages.push(e), this.totalLength += e.length;\n      }, i.prototype.streamPage = function (e) {\n        this.ondataavailable(e);\n      }, i.prototype.finish = function () {\n        if (!this.config.streamPages) {\n          var e = new Uint8Array(this.totalLength);\n          this.recordedPages.reduce(function (t, o) {\n            return e.set(o, t), t + o.length;\n          }, 0), this.ondataavailable(e);\n        }\n\n        this.onstop();\n      }, i.prototype.ondataavailable = function () {}, i.prototype.onpause = function () {}, i.prototype.onresume = function () {}, i.prototype.onstart = function () {}, i.prototype.onstop = function () {}, e.exports = i;\n    }).call(this, o(1));\n  }, function (e, t) {\n    var o;\n\n    o = function () {\n      return this;\n    }();\n\n    try {\n      o = o || new Function(\"return this\")();\n    } catch (e) {\n      \"object\" == (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) && (o = window);\n    }\n\n    e.exports = o;\n  }]);\n});","map":null,"metadata":{},"sourceType":"module"}