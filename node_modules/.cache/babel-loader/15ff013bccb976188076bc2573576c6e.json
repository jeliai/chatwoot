{"ast":null,"code":"var _mutations;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport \"regenerator-runtime/runtime.js\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.promise.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport Vue from 'vue';\nimport * as types from '../mutation-types';\nimport ConversationAPI from '../../api/inbox/conversation';\nvar state = {\n  records: {}\n};\nexport var getters = {\n  getUserList: function getUserList($state) {\n    return function (id) {\n      return $state.records[Number(id)] || [];\n    };\n  }\n};\nexport var actions = {\n  toggleTyping: function () {\n    var _toggleTyping = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_, _ref) {\n      var status, conversationId, isPrivate;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              status = _ref.status, conversationId = _ref.conversationId, isPrivate = _ref.isPrivate;\n              _context.prev = 1;\n              _context.next = 4;\n              return ConversationAPI.toggleTyping({\n                status: status,\n                conversationId: conversationId,\n                isPrivate: isPrivate\n              });\n\n            case 4:\n              _context.next = 8;\n              break;\n\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](1);\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 6]]);\n    }));\n\n    function toggleTyping(_x, _x2) {\n      return _toggleTyping.apply(this, arguments);\n    }\n\n    return toggleTyping;\n  }(),\n  create: function create(_ref2, _ref3) {\n    var commit = _ref2.commit;\n    var conversationId = _ref3.conversationId,\n        user = _ref3.user;\n    commit(types.default.ADD_USER_TYPING_TO_CONVERSATION, {\n      conversationId: conversationId,\n      user: user\n    });\n  },\n  destroy: function destroy(_ref4, _ref5) {\n    var commit = _ref4.commit;\n    var conversationId = _ref5.conversationId,\n        user = _ref5.user;\n    commit(types.default.REMOVE_USER_TYPING_FROM_CONVERSATION, {\n      conversationId: conversationId,\n      user: user\n    });\n  }\n};\nexport var mutations = (_mutations = {}, _defineProperty(_mutations, types.default.ADD_USER_TYPING_TO_CONVERSATION, function ($state, _ref6) {\n  var conversationId = _ref6.conversationId,\n      user = _ref6.user;\n  var records = $state.records[conversationId] || [];\n  var hasUserRecordAlready = !!records.filter(function (record) {\n    return record.id === user.id && record.type === user.type;\n  }).length;\n\n  if (!hasUserRecordAlready) {\n    Vue.set($state.records, conversationId, [].concat(_toConsumableArray(records), [user]));\n  }\n}), _defineProperty(_mutations, types.default.REMOVE_USER_TYPING_FROM_CONVERSATION, function ($state, _ref7) {\n  var conversationId = _ref7.conversationId,\n      user = _ref7.user;\n  var records = $state.records[conversationId] || [];\n  var updatedRecords = records.filter(function (record) {\n    return record.id !== user.id || record.type !== user.type;\n  });\n  Vue.set($state.records, conversationId, updatedRecords);\n}), _mutations);\nexport default {\n  namespaced: true,\n  state: state,\n  getters: getters,\n  actions: actions,\n  mutations: mutations\n};","map":{"version":3,"sources":["/Users/s.dastan/Desktop/chatwoot/chatwoot/app/javascript/dashboard/store/modules/conversationTypingStatus.js"],"names":["Vue","types","ConversationAPI","state","records","getters","getUserList","$state","id","Number","actions","toggleTyping","_","status","conversationId","isPrivate","create","commit","user","default","ADD_USER_TYPING_TO_CONVERSATION","destroy","REMOVE_USER_TYPING_FROM_CONVERSATION","mutations","hasUserRecordAlready","filter","record","type","length","set","updatedRecords","namespaced"],"mappings":"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","sourcesContent":["import Vue from 'vue';\nimport * as types from '../mutation-types';\nimport ConversationAPI from '../../api/inbox/conversation';\nconst state = {\n  records: {},\n};\n\nexport const getters = {\n  getUserList: $state => id => {\n    return $state.records[Number(id)] || [];\n  },\n};\n\nexport const actions = {\n  toggleTyping: async (_, { status, conversationId, isPrivate }) => {\n    try {\n      await ConversationAPI.toggleTyping({ status, conversationId, isPrivate });\n    } catch (error) {\n      // Handle error\n    }\n  },\n  create: ({ commit }, { conversationId, user }) => {\n    commit(types.default.ADD_USER_TYPING_TO_CONVERSATION, {\n      conversationId,\n      user,\n    });\n  },\n  destroy: ({ commit }, { conversationId, user }) => {\n    commit(types.default.REMOVE_USER_TYPING_FROM_CONVERSATION, {\n      conversationId,\n      user,\n    });\n  },\n};\n\nexport const mutations = {\n  [types.default.ADD_USER_TYPING_TO_CONVERSATION]: (\n    $state,\n    { conversationId, user }\n  ) => {\n    const records = $state.records[conversationId] || [];\n    const hasUserRecordAlready = !!records.filter(\n      record => record.id === user.id && record.type === user.type\n    ).length;\n    if (!hasUserRecordAlready) {\n      Vue.set($state.records, conversationId, [...records, user]);\n    }\n  },\n  [types.default.REMOVE_USER_TYPING_FROM_CONVERSATION]: (\n    $state,\n    { conversationId, user }\n  ) => {\n    const records = $state.records[conversationId] || [];\n    const updatedRecords = records.filter(\n      record => record.id !== user.id || record.type !== user.type\n    );\n    Vue.set($state.records, conversationId, updatedRecords);\n  },\n};\n\nexport default {\n  namespaced: true,\n  state,\n  getters,\n  actions,\n  mutations,\n};\n"]},"metadata":{},"sourceType":"module"}