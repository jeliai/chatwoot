{"ast":null,"code":"import { __values } from \"tslib\";\nimport { getCurrentHub } from '@sentry/browser';\nimport { logger, timestampInSeconds } from '@sentry/utils';\nimport { formatComponentName } from './components';\nimport { DEFAULT_HOOKS } from './constants';\nimport { IS_DEBUG_BUILD } from './flags';\nvar VUE_OP = 'ui.vue'; // Mappings from operation to corresponding lifecycle hook.\n\nvar HOOKS = {\n  activate: ['activated', 'deactivated'],\n  create: ['beforeCreate', 'created'],\n  destroy: ['beforeDestroy', 'destroyed'],\n  mount: ['beforeMount', 'mounted'],\n  update: ['beforeUpdate', 'updated']\n};\n/** Grabs active transaction off scope, if any */\n\nfunction getActiveTransaction() {\n  var _a;\n\n  return (_a = getCurrentHub().getScope()) === null || _a === void 0 ? void 0 : _a.getTransaction();\n}\n/** Finish top-level span and activity with a debounce configured using `timeout` option */\n\n\nfunction finishRootSpan(vm, timestamp, timeout) {\n  if (vm.$_sentryRootSpanTimer) {\n    clearTimeout(vm.$_sentryRootSpanTimer);\n  }\n\n  vm.$_sentryRootSpanTimer = setTimeout(function () {\n    var _a;\n\n    if ((_a = vm.$root) === null || _a === void 0 ? void 0 : _a.$_sentryRootSpan) {\n      vm.$root.$_sentryRootSpan.finish(timestamp);\n      vm.$root.$_sentryRootSpan = undefined;\n    }\n  }, timeout);\n}\n\nexport var createTracingMixins = function createTracingMixins(options) {\n  var e_1, _a;\n\n  var hooks = (options.hooks || []).concat(DEFAULT_HOOKS) // Removing potential duplicates\n  .filter(function (value, index, self) {\n    return self.indexOf(value) === index;\n  });\n  var mixins = {};\n\n  var _loop_1 = function _loop_1(operation) {\n    var e_2, _a; // Retrieve corresponding hooks from Vue lifecycle.\n    // eg. mount => ['beforeMount', 'mounted']\n\n\n    var internalHooks = HOOKS[operation];\n\n    if (!internalHooks) {\n      IS_DEBUG_BUILD && logger.warn(\"Unknown hook: \" + operation);\n      return \"continue\";\n    }\n\n    var _loop_2 = function _loop_2(internalHook) {\n      mixins[internalHook] = function () {\n        var _a;\n\n        var isRoot = this.$root === this;\n\n        if (isRoot) {\n          var activeTransaction = getActiveTransaction();\n\n          if (activeTransaction) {\n            this.$_sentryRootSpan = this.$_sentryRootSpan || activeTransaction.startChild({\n              description: 'Application Render',\n              op: VUE_OP\n            });\n          }\n        } // Skip components that we don't want to track to minimize the noise and give a more granular control to the user\n\n\n        var name = formatComponentName(this, false);\n        var shouldTrack = Array.isArray(options.trackComponents) ? options.trackComponents.includes(name) : options.trackComponents; // We always want to track root component\n\n        if (!isRoot && !shouldTrack) {\n          return;\n        }\n\n        this.$_sentrySpans = this.$_sentrySpans || {}; // Start a new span if current hook is a 'before' hook.\n        // Otherwise, retrieve the current span and finish it.\n\n        if (internalHook == internalHooks[0]) {\n          var activeTransaction = ((_a = this.$root) === null || _a === void 0 ? void 0 : _a.$_sentryRootSpan) || getActiveTransaction();\n\n          if (activeTransaction) {\n            this.$_sentrySpans[operation] = activeTransaction.startChild({\n              description: \"Vue <\" + name + \">\",\n              op: VUE_OP + \".\" + operation\n            });\n          }\n        } else {\n          // The span should already be added via the first handler call (in the 'before' hook)\n          var span = this.$_sentrySpans[operation]; // The before hook did not start the tracking span, so the span was not added.\n          // This is probably because it happened before there is an active transaction\n\n          if (!span) return;\n          span.finish();\n          finishRootSpan(this, timestampInSeconds(), options.timeout);\n        }\n      };\n    };\n\n    try {\n      for (var internalHooks_1 = (e_2 = void 0, __values(internalHooks)), internalHooks_1_1 = internalHooks_1.next(); !internalHooks_1_1.done; internalHooks_1_1 = internalHooks_1.next()) {\n        var internalHook = internalHooks_1_1.value;\n\n        _loop_2(internalHook);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (internalHooks_1_1 && !internalHooks_1_1.done && (_a = internalHooks_1.return)) _a.call(internalHooks_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n\n  try {\n    for (var hooks_1 = __values(hooks), hooks_1_1 = hooks_1.next(); !hooks_1_1.done; hooks_1_1 = hooks_1.next()) {\n      var operation = hooks_1_1.value;\n\n      _loop_1(operation);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (hooks_1_1 && !hooks_1_1.done && (_a = hooks_1.return)) _a.call(hooks_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return mixins;\n};","map":null,"metadata":{},"sourceType":"module"}