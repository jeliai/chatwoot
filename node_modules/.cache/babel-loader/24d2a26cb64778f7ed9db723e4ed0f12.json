{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar dlv_1 = __importDefault(require(\"dlv\"));\n\nfunction matches(event, matcher) {\n  if (!matcher) {\n    throw new Error('No matcher supplied!');\n  }\n\n  switch (matcher.type) {\n    case 'all':\n      return all();\n\n    case 'fql':\n      return fql(matcher.ir, event);\n\n    default:\n      throw new Error(\"Matcher of type \".concat(matcher.type, \" unsupported.\"));\n  }\n}\n\nexports.default = matches;\n\nfunction all() {\n  return true;\n}\n\nfunction fql(ir, event) {\n  if (!ir) {\n    return false;\n  }\n\n  try {\n    ir = JSON.parse(ir);\n  } catch (e) {\n    throw new Error(\"Failed to JSON.parse FQL intermediate representation \\\"\".concat(ir, \"\\\": \").concat(e));\n  }\n\n  var result = fqlEvaluate(ir, event);\n\n  if (typeof result !== 'boolean') {\n    // An error was returned, or a lowercase, typeof, or similar function was run alone. Nothing to evaluate.\n    return false;\n  }\n\n  return result;\n} // FQL is 100% type strict in Go. Show no mercy to types which do not comply.\n\n\nfunction fqlEvaluate(ir, event) {\n  // If the given ir chunk is not an array, then we should check the single given path or value for literally `true`.\n  if (!Array.isArray(ir)) {\n    return getValue(ir, event) === true;\n  } // Otherwise, it is a sequence of ordered steps to follow to reach our solution!\n\n\n  var item = ir[0];\n\n  switch (item) {\n    /*** Unary cases ***/\n    // '!' => Invert the result\n    case '!':\n      return !fqlEvaluate(ir[1], event);\n\n    /*** Binary cases ***/\n    // 'or' => Any condition being true returns true\n\n    case 'or':\n      for (var i = 1; i < ir.length; i++) {\n        if (fqlEvaluate(ir[i], event)) {\n          return true;\n        }\n      }\n\n      return false;\n    // 'and' => Any condition being false returns false\n\n    case 'and':\n      for (var i = 1; i < ir.length; i++) {\n        if (!fqlEvaluate(ir[i], event)) {\n          return false;\n        }\n      }\n\n      return true;\n    // Equivalence comparisons\n\n    case '=':\n    case '!=':\n      return compareItems(getValue(ir[1], event), getValue(ir[2], event), item, event);\n    // Numerical comparisons\n\n    case '<=':\n    case '<':\n    case '>':\n    case '>=':\n      // Compare the two values with the given operator.\n      return compareNumbers(getValue(ir[1], event), getValue(ir[2], event), item, event);\n\n    /*** Functions ***/\n    // 'contains(str1, str2)' => The first string has a substring of the second string\n\n    case 'contains':\n      return contains(getValue(ir[1], event), getValue(ir[2], event));\n    // 'match(str, match)' => The given string matches the provided glob matcher\n\n    case 'match':\n      return match(getValue(ir[1], event), getValue(ir[2], event));\n    // 'lowercase(str)' => Returns a lowercased string, null if the item is not a string\n\n    case 'lowercase':\n      var target = getValue(ir[1], event);\n\n      if (typeof target !== 'string') {\n        return null;\n      }\n\n      return target.toLowerCase();\n    // 'typeof(val)' => Returns the FQL type of the value\n\n    case 'typeof':\n      // TODO: Do we need mapping to allow for universal comparisons? e.g. Object -> JSON, Array -> List, Floats?\n      return _typeof(getValue(ir[1], event));\n    // 'length(val)' => Returns the length of an array or string, NaN if neither\n\n    case 'length':\n      return length(getValue(ir[1], event));\n    // If nothing hit, we or the IR messed up somewhere.\n\n    default:\n      throw new Error(\"FQL IR could not evaluate for token: \".concat(item));\n  }\n}\n\nfunction getValue(item, event) {\n  // If item is an array, leave it as-is.\n  if (Array.isArray(item)) {\n    return item;\n  } // If item is an object, it has the form of `{\"value\": VAL}`\n\n\n  if (_typeof(item) === 'object') {\n    return item.value;\n  } // Otherwise, it's an event path, e.g. \"properties.email\"\n\n\n  return (0, dlv_1.default)(event, item);\n}\n\nfunction compareNumbers(first, second, operator, event) {\n  // Check if it's more IR (such as a length() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event);\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event);\n  }\n\n  if (typeof first !== 'number' || typeof second !== 'number') {\n    return false;\n  } // Reminder: NaN is not comparable to any other number (including NaN) and will always return false as desired.\n\n\n  switch (operator) {\n    // '<=' => The first number is less than or equal to the second.\n    case '<=':\n      return first <= second;\n    // '>=' => The first number is greater than or equal to the second\n\n    case '>=':\n      return first >= second;\n    // '<' The first number is less than the second.\n\n    case '<':\n      return first < second;\n    // '>' The first number is greater than the second.\n\n    case '>':\n      return first > second;\n\n    default:\n      throw new Error(\"Invalid operator in compareNumbers: \".concat(operator));\n  }\n}\n\nfunction compareItems(first, second, operator, event) {\n  // Check if it's more IR (such as a lowercase() function)\n  if (isIR(first)) {\n    first = fqlEvaluate(first, event);\n  }\n\n  if (isIR(second)) {\n    second = fqlEvaluate(second, event);\n  }\n\n  if (_typeof(first) === 'object' && _typeof(second) === 'object') {\n    first = JSON.stringify(first);\n    second = JSON.stringify(second);\n  } // Objects with the exact same contents AND order ARE considered identical. (Don't compare by reference)\n  // Even in Go, this MUST be the same byte order.\n  // e.g. {a: 1, b:2} === {a: 1, b:2} BUT {a:1, b:2} !== {b:2, a:1}\n  // Maybe later we'll use a stable stringifier, but we're matching server-side behavior for now.\n\n\n  switch (operator) {\n    // '=' => The two following items are exactly identical\n    case '=':\n      return first === second;\n    // '!=' => The two following items are NOT exactly identical.\n\n    case '!=':\n      return first !== second;\n\n    default:\n      throw new Error(\"Invalid operator in compareItems: \".concat(operator));\n  }\n}\n\nfunction contains(first, second) {\n  if (typeof first !== 'string' || typeof second !== 'string') {\n    return false;\n  }\n\n  return first.indexOf(second) !== -1;\n}\n\nfunction match(str, glob) {\n  if (typeof str !== 'string' || typeof glob !== 'string') {\n    return false;\n  }\n\n  return globMatches(glob, str);\n}\n\nfunction length(item) {\n  // Match server-side behavior.\n  if (item === null) {\n    return 0;\n  } // Type-check to avoid returning .length of an object\n\n\n  if (!Array.isArray(item) && typeof item !== 'string') {\n    return NaN;\n  }\n\n  return item.length;\n} // This is a heuristic technically speaking, but should be close enough. The odds of someone trying to test\n// a func with identical IR notation is pretty low.\n\n\nfunction isIR(value) {\n  // TODO: This can be better checked by checking if this is a {\"value\": THIS}\n  if (!Array.isArray(value)) {\n    return false;\n  } // Function checks\n\n\n  if ((value[0] === 'lowercase' || value[0] === 'length' || value[0] === 'typeof') && value.length === 2) {\n    return true;\n  }\n\n  if ((value[0] === 'contains' || value[0] === 'match') && value.length === 3) {\n    return true;\n  }\n\n  return false;\n} // Any reputable glob matcher is designed to work on filesystems and doesn't allow the override of the separator\n// character \"/\". This is problematic since our server-side representation e.g. evaluates \"match('ab/c', 'a*)\"\n// as TRUE, whereas any glob matcher for JS available does false. So we're rewriting it here.\n// See: https://github.com/segmentio/glob/blob/master/glob.go\n\n\nfunction globMatches(pattern, str) {\n  var _a, _b;\n\n  Pattern: while (pattern.length > 0) {\n    var star = void 0;\n    var chunk = void 0;\n    _a = scanChunk(pattern), star = _a.star, chunk = _a.chunk, pattern = _a.pattern;\n\n    if (star && chunk === '') {\n      // Trailing * matches rest of string\n      return true;\n    } // Look for match at current position\n\n\n    var _c = matchChunk(chunk, str),\n        t = _c.t,\n        ok = _c.ok,\n        err = _c.err;\n\n    if (err) {\n      return false;\n    } // If we're the last chunk, make sure we've exhausted the str\n    // otherwise we'll give a false result even if we could still match\n    // using the star\n\n\n    if (ok && (t.length === 0 || pattern.length > 0)) {\n      str = t;\n      continue;\n    }\n\n    if (star) {\n      // Look for match, skipping i+1 bytes.\n      for (var i = 0; i < str.length; i++) {\n        ;\n        _b = matchChunk(chunk, str.slice(i + 1)), t = _b.t, ok = _b.ok, err = _b.err;\n\n        if (ok) {\n          // If we're the last chunk, make sure we exhausted the str.\n          if (pattern.length === 0 && t.length > 0) {\n            continue;\n          }\n\n          str = t;\n          continue Pattern;\n        }\n\n        if (err) {\n          return false;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return str.length === 0;\n}\n\nfunction scanChunk(pattern) {\n  var result = {\n    star: false,\n    chunk: '',\n    pattern: ''\n  };\n\n  while (pattern.length > 0 && pattern[0] === '*') {\n    pattern = pattern.slice(1);\n    result.star = true;\n  }\n\n  var inRange = false;\n  var i;\n\n  Scan: for (i = 0; i < pattern.length; i++) {\n    switch (pattern[i]) {\n      case '\\\\':\n        // Error check handled in matchChunk: bad pattern.\n        if (i + 1 < pattern.length) {\n          i++;\n        }\n\n        break;\n\n      case '[':\n        inRange = true;\n        break;\n\n      case ']':\n        inRange = false;\n        break;\n\n      case '*':\n        if (!inRange) {\n          break Scan;\n        }\n\n    }\n  }\n\n  result.chunk = pattern.slice(0, i);\n  result.pattern = pattern.slice(i);\n  return result;\n} // matchChunk checks whether chunk matches the beginning of s.\n// If so, it returns the remainder of s (after the match).\n// Chunk is all single-character operators: literals, char classes, and ?.\n\n\nfunction matchChunk(chunk, str) {\n  var _a, _b;\n\n  var result = {\n    t: '',\n    ok: false,\n    err: false\n  };\n\n  while (chunk.length > 0) {\n    if (str.length === 0) {\n      return result;\n    }\n\n    switch (chunk[0]) {\n      case '[':\n        var char = str[0];\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n        var notNegated = true;\n\n        if (chunk.length > 0 && chunk[0] === '^') {\n          notNegated = false;\n          chunk = chunk.slice(1);\n        } // Parse all ranges\n\n\n        var foundMatch = false;\n        var nRange = 0;\n\n        while (true) {\n          if (chunk.length > 0 && chunk[0] === ']' && nRange > 0) {\n            chunk = chunk.slice(1);\n            break;\n          }\n\n          var lo = '';\n          var hi = '';\n          var err = void 0;\n          _a = getEsc(chunk), lo = _a.char, chunk = _a.newChunk, err = _a.err;\n\n          if (err) {\n            return result;\n          }\n\n          hi = lo;\n\n          if (chunk[0] === '-') {\n            ;\n            _b = getEsc(chunk.slice(1)), hi = _b.char, chunk = _b.newChunk, err = _b.err;\n\n            if (err) {\n              return result;\n            }\n          }\n\n          if (lo <= char && char <= hi) {\n            foundMatch = true;\n          }\n\n          nRange++;\n        }\n\n        if (foundMatch !== notNegated) {\n          return result;\n        }\n\n        break;\n\n      case '?':\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n        break;\n\n      case '\\\\':\n        chunk = chunk.slice(1);\n\n        if (chunk.length === 0) {\n          result.err = true;\n          return result;\n        }\n\n      // Fallthrough, missing break intentional.\n\n      default:\n        if (chunk[0] !== str[0]) {\n          return result;\n        }\n\n        str = str.slice(1);\n        chunk = chunk.slice(1);\n    }\n  }\n\n  result.t = str;\n  result.ok = true;\n  result.err = false;\n  return result;\n} // getEsc gets a possibly-escaped character from chunk, for a character class.\n\n\nfunction getEsc(chunk) {\n  var result = {\n    char: '',\n    newChunk: '',\n    err: false\n  };\n\n  if (chunk.length === 0 || chunk[0] === '-' || chunk[0] === ']') {\n    result.err = true;\n    return result;\n  }\n\n  if (chunk[0] === '\\\\') {\n    chunk = chunk.slice(1);\n\n    if (chunk.length === 0) {\n      result.err = true;\n      return result;\n    }\n  } // Unlike Go, JS strings operate on characters instead of bytes.\n  // This is why we aren't copying over the GetRuneFromString stuff.\n\n\n  result.char = chunk[0];\n  result.newChunk = chunk.slice(1);\n\n  if (result.newChunk.length === 0) {\n    result.err = true;\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}