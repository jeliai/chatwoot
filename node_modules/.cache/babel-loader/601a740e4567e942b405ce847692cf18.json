{"ast":null,"code":"import \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport ChatMessage from 'widget/components/ChatMessage.vue';\nimport AgentTypingBubble from 'widget/components/AgentTypingBubble.vue';\nimport DateSeparator from 'shared/components/DateSeparator.vue';\nimport Spinner from 'shared/components/Spinner.vue';\nimport darkModeMixin from 'widget/mixins/darkModeMixin';\nimport { mapActions, mapGetters } from 'vuex';\nexport default {\n  name: 'ConversationWrap',\n  components: {\n    ChatMessage: ChatMessage,\n    AgentTypingBubble: AgentTypingBubble,\n    DateSeparator: DateSeparator,\n    Spinner: Spinner\n  },\n  mixins: [darkModeMixin],\n  props: {\n    groupedMessages: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    }\n  },\n  data: function data() {\n    return {\n      previousScrollHeight: 0,\n      previousConversationSize: 0\n    };\n  },\n  computed: _objectSpread(_objectSpread({}, mapGetters({\n    earliestMessage: 'conversation/getEarliestMessage',\n    allMessagesLoaded: 'conversation/getAllMessagesLoaded',\n    isFetchingList: 'conversation/getIsFetchingList',\n    conversationSize: 'conversation/getConversationSize',\n    isAgentTyping: 'conversation/getIsAgentTyping'\n  })), {}, {\n    colorSchemeClass: function colorSchemeClass() {\n      return \"\".concat(this.darkMode === 'light' ? 'light' : 'dark');\n    }\n  }),\n  watch: {\n    allMessagesLoaded: function allMessagesLoaded() {\n      this.previousScrollHeight = 0;\n    }\n  },\n  mounted: function mounted() {\n    this.$el.addEventListener('scroll', this.handleScroll);\n    this.scrollToBottom();\n  },\n  updated: function updated() {\n    if (this.previousConversationSize !== this.conversationSize) {\n      this.previousConversationSize = this.conversationSize;\n      this.scrollToBottom();\n    }\n  },\n  unmounted: function unmounted() {\n    this.$el.removeEventListener('scroll', this.handleScroll);\n  },\n  methods: _objectSpread(_objectSpread({}, mapActions('conversation', ['fetchOldConversations'])), {}, {\n    scrollToBottom: function scrollToBottom() {\n      var container = this.$el;\n      container.scrollTop = container.scrollHeight - this.previousScrollHeight;\n      this.previousScrollHeight = 0;\n    },\n    handleScroll: function handleScroll() {\n      if (this.isFetchingList || this.allMessagesLoaded || !this.conversationSize) {\n        return;\n      }\n\n      if (this.$el.scrollTop < 100) {\n        this.fetchOldConversations({\n          before: this.earliestMessage.id\n        });\n        this.previousScrollHeight = this.$el.scrollHeight;\n      }\n    }\n  })\n};","map":{"version":3,"sources":["ConversationWrap.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA,OAAA,WAAA,MAAA,mCAAA;AACA,OAAA,iBAAA,MAAA,yCAAA;AACA,OAAA,aAAA,MAAA,qCAAA;AACA,OAAA,OAAA,MAAA,+BAAA;AACA,OAAA,aAAA,MAAA,6BAAA;AAEA,SAAA,UAAA,EAAA,UAAA,QAAA,MAAA;AAEA,eAAA;AACA,EAAA,IAAA,EAAA,kBADA;AAEA,EAAA,UAAA,EAAA;AACA,IAAA,WAAA,EAAA,WADA;AAEA,IAAA,iBAAA,EAAA,iBAFA;AAGA,IAAA,aAAA,EAAA,aAHA;AAIA,IAAA,OAAA,EAAA;AAJA,GAFA;AAQA,EAAA,MAAA,EAAA,CAAA,aAAA,CARA;AASA,EAAA,KAAA,EAAA;AACA,IAAA,eAAA,EAAA;AACA,MAAA,IAAA,EAAA,KADA;AAEA,MAAA,OAAA,EAAA;AAAA,eAAA,EAAA;AAAA;AAFA;AADA,GATA;AAeA,EAAA,IAfA,kBAeA;AACA,WAAA;AACA,MAAA,oBAAA,EAAA,CADA;AAEA,MAAA,wBAAA,EAAA;AAFA,KAAA;AAIA,GApBA;AAqBA,EAAA,QAAA,kCACA,UAAA,CAAA;AACA,IAAA,eAAA,EAAA,iCADA;AAEA,IAAA,iBAAA,EAAA,mCAFA;AAGA,IAAA,cAAA,EAAA,gCAHA;AAIA,IAAA,gBAAA,EAAA,kCAJA;AAKA,IAAA,aAAA,EAAA;AALA,GAAA,CADA;AAQA,IAAA,gBARA,8BAQA;AACA,uBAAA,KAAA,QAAA,KAAA,OAAA,GAAA,OAAA,GAAA,MAAA;AACA;AAVA,IArBA;AAiCA,EAAA,KAAA,EAAA;AACA,IAAA,iBADA,+BACA;AACA,WAAA,oBAAA,GAAA,CAAA;AACA;AAHA,GAjCA;AAsCA,EAAA,OAtCA,qBAsCA;AACA,SAAA,GAAA,CAAA,gBAAA,CAAA,QAAA,EAAA,KAAA,YAAA;AACA,SAAA,cAAA;AACA,GAzCA;AA0CA,EAAA,OA1CA,qBA0CA;AACA,QAAA,KAAA,wBAAA,KAAA,KAAA,gBAAA,EAAA;AACA,WAAA,wBAAA,GAAA,KAAA,gBAAA;AACA,WAAA,cAAA;AACA;AACA,GA/CA;AAgDA,EAAA,SAhDA,uBAgDA;AACA,SAAA,GAAA,CAAA,mBAAA,CAAA,QAAA,EAAA,KAAA,YAAA;AACA,GAlDA;AAmDA,EAAA,OAAA,kCACA,UAAA,CAAA,cAAA,EAAA,CAAA,uBAAA,CAAA,CADA;AAEA,IAAA,cAFA,4BAEA;AACA,UAAA,SAAA,GAAA,KAAA,GAAA;AACA,MAAA,SAAA,CAAA,SAAA,GAAA,SAAA,CAAA,YAAA,GAAA,KAAA,oBAAA;AACA,WAAA,oBAAA,GAAA,CAAA;AACA,KANA;AAOA,IAAA,YAPA,0BAOA;AACA,UACA,KAAA,cAAA,IACA,KAAA,iBADA,IAEA,CAAA,KAAA,gBAHA,EAIA;AACA;AACA;;AAEA,UAAA,KAAA,GAAA,CAAA,SAAA,GAAA,GAAA,EAAA;AACA,aAAA,qBAAA,CAAA;AAAA,UAAA,MAAA,EAAA,KAAA,eAAA,CAAA;AAAA,SAAA;AACA,aAAA,oBAAA,GAAA,KAAA,GAAA,CAAA,YAAA;AACA;AACA;AApBA;AAnDA,CAAA","sourcesContent":["<template>\n  <div class=\"conversation--container\" :class=\"colorSchemeClass\">\n    <div class=\"conversation-wrap\" :class=\"{ 'is-typing': isAgentTyping }\">\n      <div v-if=\"isFetchingList\" class=\"message--loader\">\n        <spinner />\n      </div>\n      <div\n        v-for=\"groupedMessage in groupedMessages\"\n        :key=\"groupedMessage.date\"\n        class=\"messages-wrap\"\n      >\n        <date-separator :date=\"groupedMessage.date\" />\n        <chat-message\n          v-for=\"message in groupedMessage.messages\"\n          :key=\"message.id\"\n          :message=\"message\"\n        />\n      </div>\n      <agent-typing-bubble v-if=\"isAgentTyping\" />\n    </div>\n  </div>\n</template>\n\n<script>\nimport ChatMessage from 'widget/components/ChatMessage.vue';\nimport AgentTypingBubble from 'widget/components/AgentTypingBubble.vue';\nimport DateSeparator from 'shared/components/DateSeparator.vue';\nimport Spinner from 'shared/components/Spinner.vue';\nimport darkModeMixin from 'widget/mixins/darkModeMixin';\n\nimport { mapActions, mapGetters } from 'vuex';\n\nexport default {\n  name: 'ConversationWrap',\n  components: {\n    ChatMessage,\n    AgentTypingBubble,\n    DateSeparator,\n    Spinner,\n  },\n  mixins: [darkModeMixin],\n  props: {\n    groupedMessages: {\n      type: Array,\n      default: () => [],\n    },\n  },\n  data() {\n    return {\n      previousScrollHeight: 0,\n      previousConversationSize: 0,\n    };\n  },\n  computed: {\n    ...mapGetters({\n      earliestMessage: 'conversation/getEarliestMessage',\n      allMessagesLoaded: 'conversation/getAllMessagesLoaded',\n      isFetchingList: 'conversation/getIsFetchingList',\n      conversationSize: 'conversation/getConversationSize',\n      isAgentTyping: 'conversation/getIsAgentTyping',\n    }),\n    colorSchemeClass() {\n      return `${this.darkMode === 'light' ? 'light' : 'dark'}`;\n    },\n  },\n  watch: {\n    allMessagesLoaded() {\n      this.previousScrollHeight = 0;\n    },\n  },\n  mounted() {\n    this.$el.addEventListener('scroll', this.handleScroll);\n    this.scrollToBottom();\n  },\n  updated() {\n    if (this.previousConversationSize !== this.conversationSize) {\n      this.previousConversationSize = this.conversationSize;\n      this.scrollToBottom();\n    }\n  },\n  unmounted() {\n    this.$el.removeEventListener('scroll', this.handleScroll);\n  },\n  methods: {\n    ...mapActions('conversation', ['fetchOldConversations']),\n    scrollToBottom() {\n      const container = this.$el;\n      container.scrollTop = container.scrollHeight - this.previousScrollHeight;\n      this.previousScrollHeight = 0;\n    },\n    handleScroll() {\n      if (\n        this.isFetchingList ||\n        this.allMessagesLoaded ||\n        !this.conversationSize\n      ) {\n        return;\n      }\n\n      if (this.$el.scrollTop < 100) {\n        this.fetchOldConversations({ before: this.earliestMessage.id });\n        this.previousScrollHeight = this.$el.scrollHeight;\n      }\n    },\n  },\n};\n</script>\n\n<style scoped lang=\"scss\">\n@import '~widget/assets/scss/variables.scss';\n@import '~widget/assets/scss/mixins.scss';\n\n.conversation--container {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n  overflow-y: auto;\n  color-scheme: light dark;\n\n  &.light {\n    color-scheme: light;\n  }\n  &.dark {\n    color-scheme: dark;\n  }\n}\n\n.conversation-wrap {\n  flex: 1;\n  padding: $space-large $space-small $space-small $space-small;\n}\n\n.message--loader {\n  text-align: center;\n}\n</style>\n"],"sourceRoot":"app/javascript/widget/components"},"metadata":{},"sourceType":"module"}