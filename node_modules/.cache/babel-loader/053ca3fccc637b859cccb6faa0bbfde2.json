{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport t from \"is-url\";\nimport e from \"nanoid/non-secure\";\nimport r from \"is-plain-object\";\nimport { en as o } from \"@braid/vue-formulate-i18n\";\n\nvar i = function i(t, e) {\n  return {\n    classification: t,\n    component: \"FormulateInput\" + (e || t[0].toUpperCase() + t.substr(1))\n  };\n},\n    n = Object.assign({}, [\"text\", \"email\", \"number\", \"color\", \"date\", \"hidden\", \"month\", \"password\", \"search\", \"tel\", \"time\", \"url\", \"week\", \"datetime-local\"].reduce(function (t, e) {\n  var r;\n  return Object.assign({}, t, ((r = {})[e] = i(\"text\"), r));\n}, {}), {\n  range: i(\"slider\"),\n  textarea: i(\"textarea\", \"TextArea\"),\n  checkbox: i(\"box\"),\n  radio: i(\"box\"),\n  submit: i(\"button\"),\n  button: i(\"button\"),\n  select: i(\"select\"),\n  file: i(\"file\"),\n  image: i(\"file\"),\n  group: i(\"group\")\n});\n\nfunction s(t, e) {\n  var r = {};\n\n  for (var o in t) {\n    r[o] = e(o, t[o]);\n  }\n\n  return r;\n}\n\nfunction a(t, e, r) {\n  if (void 0 === r && (r = !1), t === e) return !0;\n  if (!t || !e) return !1;\n  if (\"object\" != _typeof(t) && \"object\" != _typeof(e)) return t === e;\n  var o = Object.keys(t),\n      i = Object.keys(e),\n      n = o.length;\n  if (i.length !== n) return !1;\n\n  for (var s = 0; s < n; s++) {\n    var l = o[s];\n    if (!r && t[l] !== e[l] || r && !a(t[l], e[l], r)) return !1;\n  }\n\n  return !0;\n}\n\nfunction l(t) {\n  return \"string\" == typeof t ? t.replace(/([_-][a-z0-9])/gi, function (e) {\n    return 0 === t.indexOf(e) || /[_-]/.test(t[t.indexOf(e) - 1]) ? e : e.toUpperCase().replace(/[_-]/, \"\");\n  }) : t;\n}\n\nfunction u(t) {\n  return \"string\" == typeof t ? t[0].toUpperCase() + t.substr(1) : t;\n}\n\nfunction c(t) {\n  return t ? \"string\" == typeof t ? [t] : Array.isArray(t) ? t : \"object\" == _typeof(t) ? Object.values(t) : [] : [];\n}\n\nfunction d(t, e) {\n  return \"string\" == typeof t ? d(t.split(\"|\"), e) : Array.isArray(t) ? t.map(function (t) {\n    return function (t, e) {\n      if (\"function\" == typeof t) return [t, []];\n\n      if (Array.isArray(t) && t.length) {\n        var r = p((t = t.map(function (t) {\n          return t;\n        })).shift()),\n            o = r[0],\n            i = r[1];\n        if (\"string\" == typeof o && e.hasOwnProperty(o)) return [e[o], t, o, i];\n        if (\"function\" == typeof o) return [o, t, o, i];\n      }\n\n      if (\"string\" == typeof t && t) {\n        var n = t.split(\":\"),\n            s = p(n.shift()),\n            a = s[0],\n            l = s[1];\n        if (e.hasOwnProperty(a)) return [e[a], n.length ? n.join(\":\").split(\",\") : [], a, l];\n        throw new Error(\"Unknown validation rule \" + t);\n      }\n\n      return !1;\n    }(t, e);\n  }).filter(function (t) {\n    return !!t;\n  }) : [];\n}\n\nfunction p(t) {\n  return /^[\\^]/.test(t.charAt(0)) ? [l(t.substr(1)), t.charAt(0)] : [l(t), null];\n}\n\nfunction h(t) {\n  switch (_typeof(t)) {\n    case \"symbol\":\n    case \"number\":\n    case \"string\":\n    case \"boolean\":\n    case \"undefined\":\n      return !0;\n\n    default:\n      return null === t;\n  }\n}\n\nfunction f(t, e) {\n  return Object.prototype.hasOwnProperty.call(t, e);\n}\n\nfunction m(t, r) {\n  return !f(t, \"__id\") || r ? Object.defineProperty(t, \"__id\", Object.assign(Object.create(null), {\n    value: r || e(9)\n  })) : t;\n}\n\nfunction v(t) {\n  return \"number\" != typeof t && (void 0 === t || \"\" === t || null === t || !1 === t || Array.isArray(t) && !t.some(function (t) {\n    return !v(t);\n  }) || t && !Array.isArray(t) && \"object\" == _typeof(t) && v(Object.values(t)));\n}\n\nfunction x(t, e) {\n  return Object.keys(t).reduce(function (r, o) {\n    var i = l(o);\n    return e.includes(i) && (r[i] = t[o]), r;\n  }, {});\n}\n\nvar y = function y(t, e, r) {\n  void 0 === r && (r = {}), this.input = t, this.fileList = t.files, this.files = [], this.options = Object.assign({}, {\n    mimes: {}\n  }, r), this.results = !1, this.context = e, this.dataTransferCheck(), e && e.uploadUrl && (this.options.uploadUrl = e.uploadUrl), this.uploadPromise = null, Array.isArray(this.fileList) ? this.rehydrateFileList(this.fileList) : this.addFileList(this.fileList);\n};\n\ny.prototype.rehydrateFileList = function (t) {\n  var e = this,\n      r = t.reduce(function (t, r) {\n    var o = r[e.options ? e.options.fileUrlKey : \"url\"],\n        i = !(!o || -1 === o.lastIndexOf(\".\")) && o.substr(o.lastIndexOf(\".\") + 1),\n        n = e.options.mimes[i] || !1;\n    return t.push(Object.assign({}, r, o ? {\n      name: r.name || o.substr(o.lastIndexOf(\"/\") + 1 || 0),\n      type: r.type ? r.type : n,\n      previewData: o\n    } : {})), t;\n  }, []);\n  this.addFileList(r), this.results = this.mapUUID(t);\n}, y.prototype.addFileList = function (t) {\n  for (var r = this, o = function o(_o) {\n    var i = t[_o],\n        n = e();\n    r.files.push({\n      progress: !1,\n      error: !1,\n      complete: !1,\n      justFinished: !1,\n      name: i.name || \"file-upload\",\n      file: i,\n      uuid: n,\n      path: !1,\n      removeFile: function () {\n        this.removeFile(n);\n      }.bind(r),\n      previewData: i.previewData || !1\n    });\n  }, i = 0; i < t.length; i++) {\n    o(i);\n  }\n}, y.prototype.hasUploader = function () {\n  return !!this.context.uploader;\n}, y.prototype.uploaderIsAxios = function () {\n  return !(!this.hasUploader() || \"function\" != typeof this.context.uploader.request || \"function\" != typeof this.context.uploader.get || \"function\" != typeof this.context.uploader.delete || \"function\" != typeof this.context.uploader.post);\n}, y.prototype.getUploader = function () {\n  for (var t, e = [], r = arguments.length; r--;) {\n    e[r] = arguments[r];\n  }\n\n  if (this.uploaderIsAxios()) {\n    var o = new FormData();\n    if (o.append(this.context.name || \"file\", e[0]), !1 === this.context.uploadUrl) throw new Error(\"No uploadURL specified: https://vueformulate.com/guide/inputs/file/#props\");\n    return this.context.uploader.post(this.context.uploadUrl, o, {\n      headers: {\n        \"Content-Type\": \"multipart/form-data\"\n      },\n      onUploadProgress: function onUploadProgress(t) {\n        e[1](Math.round(100 * t.loaded / t.total));\n      }\n    }).then(function (t) {\n      return t.data;\n    }).catch(function (t) {\n      return e[2](t);\n    });\n  }\n\n  return (t = this.context).uploader.apply(t, e);\n}, y.prototype.upload = function () {\n  var t = this;\n  return this.uploadPromise = this.uploadPromise ? this.uploadPromise.then(function () {\n    return t.__performUpload();\n  }) : this.__performUpload(), this.uploadPromise;\n}, y.prototype.__performUpload = function () {\n  var t = this;\n  return new Promise(function (e, r) {\n    if (!t.hasUploader()) return r(new Error(\"No uploader has been defined\"));\n    Promise.all(t.files.map(function (e) {\n      return e.error = !1, e.complete = !!e.path, e.path ? Promise.resolve(e.path) : t.getUploader(e.file, function (r) {\n        e.progress = r, t.context.rootEmit(\"file-upload-progress\", r), r >= 100 && (e.complete || (e.justFinished = !0, setTimeout(function () {\n          e.justFinished = !1;\n        }, t.options.uploadJustCompleteDuration)), e.complete = !0, t.context.rootEmit(\"file-upload-complete\", e));\n      }, function (o) {\n        e.progress = 0, e.error = o, e.complete = !0, t.context.rootEmit(\"file-upload-error\", o), r(o);\n      }, t.options);\n    })).then(function (r) {\n      t.results = t.mapUUID(r), e(r);\n    }).catch(function (t) {\n      throw new Error(t);\n    });\n  });\n}, y.prototype.removeFile = function (t) {\n  var e = this.files.length;\n\n  if (this.files = this.files.filter(function (e) {\n    return e && e.uuid !== t;\n  }), Array.isArray(this.results) && (this.results = this.results.filter(function (e) {\n    return e && e.__id !== t;\n  })), this.context.performValidation(), window && this.fileList instanceof FileList && this.supportsDataTransfers) {\n    var r = new DataTransfer();\n    this.files.forEach(function (t) {\n      return r.items.add(t.file);\n    }), this.fileList = r.files, this.input.files = this.fileList;\n  } else this.fileList = this.fileList.filter(function (e) {\n    return e && e.__id !== t;\n  });\n\n  e > this.files.length && this.context.rootEmit(\"file-removed\", this.files);\n}, y.prototype.mergeFileList = function (t) {\n  if (this.addFileList(t.files), this.supportsDataTransfers) {\n    var e = new DataTransfer();\n    this.files.forEach(function (t) {\n      t.file instanceof File && e.items.add(t.file);\n    }), this.fileList = e.files, this.input.files = this.fileList, t.files = new DataTransfer().files;\n  }\n\n  this.context.performValidation(), this.loadPreviews(), \"delayed\" !== this.context.uploadBehavior && this.upload();\n}, y.prototype.loadPreviews = function () {\n  this.files.map(function (t) {\n    if (!t.previewData && window && window.FileReader && /^image\\//.test(t.file.type)) {\n      var e = new FileReader();\n      e.onload = function (e) {\n        return Object.assign(t, {\n          previewData: e.target.result\n        });\n      }, e.readAsDataURL(t.file);\n    }\n  });\n}, y.prototype.dataTransferCheck = function () {\n  try {\n    new DataTransfer(), this.supportsDataTransfers = !0;\n  } catch (t) {\n    this.supportsDataTransfers = !1;\n  }\n}, y.prototype.getFiles = function () {\n  return this.files;\n}, y.prototype.mapUUID = function (t) {\n  var e = this;\n  return t.map(function (t, r) {\n    return e.files[r].path = void 0 !== t && t, t && m(t, e.files[r].uuid);\n  });\n}, y.prototype.toString = function () {\n  var t = this.files.length ? this.files.length + \" files\" : \"empty\";\n  return this.results ? JSON.stringify(this.results, null, \"  \") : \"FileUpload(\" + t + \")\";\n};\n\nvar g,\n    b = {\n  accepted: function accepted(t) {\n    var e = t.value;\n    return Promise.resolve([\"yes\", \"on\", \"1\", 1, !0, \"true\"].includes(e));\n  },\n  after: function after(t, e) {\n    var r = t.value;\n    void 0 === e && (e = !1);\n    var o = Date.parse(e || new Date()),\n        i = Date.parse(r);\n    return Promise.resolve(!isNaN(i) && i > o);\n  },\n  alpha: function alpha(t, e) {\n    var r = t.value;\n    void 0 === e && (e = \"default\");\n    var o = {\n      default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,\n      latin: /^[a-zA-Z]+$/\n    },\n        i = o.hasOwnProperty(e) ? e : \"default\";\n    return Promise.resolve(o[i].test(r));\n  },\n  alphanumeric: function alphanumeric(t, e) {\n    var r = t.value;\n    void 0 === e && (e = \"default\");\n    var o = {\n      default: /^[a-zA-Z0-9À-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,\n      latin: /^[a-zA-Z0-9]+$/\n    },\n        i = o.hasOwnProperty(e) ? e : \"default\";\n    return Promise.resolve(o[i].test(r));\n  },\n  before: function before(t, e) {\n    var r = t.value;\n    void 0 === e && (e = !1);\n    var o = Date.parse(e || new Date()),\n        i = Date.parse(r);\n    return Promise.resolve(!isNaN(i) && i < o);\n  },\n  between: function between(t, e, r, o) {\n    var i = t.value;\n    return void 0 === e && (e = 0), void 0 === r && (r = 10), Promise.resolve(null !== e && null !== r && !isNaN(e) && !isNaN(r) && (!isNaN(i) && \"length\" !== o || \"value\" === o ? (i = Number(i), e = Number(e), r = Number(r), i > e && i < r) : (\"string\" == typeof i || \"length\" === o) && (i = isNaN(i) ? i : i.toString()).length > e && i.length < r));\n  },\n  confirm: function confirm(t, e) {\n    var r,\n        o,\n        i = t.value,\n        n = t.getGroupValues,\n        s = t.name;\n    return Promise.resolve((r = n(), (o = e) || (o = /_confirm$/.test(s) ? s.substr(0, s.length - 8) : s + \"_confirm\"), r[o] === i));\n  },\n  date: function date(t, e) {\n    var r = t.value;\n    return void 0 === e && (e = !1), Promise.resolve(e && \"string\" == typeof e ? function (t) {\n      var e = \"^\" + t.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\") + \"$\",\n          r = {\n        MM: \"(0[1-9]|1[012])\",\n        M: \"([1-9]|1[012])\",\n        DD: \"([012][0-9]|3[01])\",\n        D: \"([012]?[0-9]|3[01])\",\n        YYYY: \"\\\\d{4}\",\n        YY: \"\\\\d{2}\"\n      };\n      return new RegExp(Object.keys(r).reduce(function (t, e) {\n        return t.replace(e, r[e]);\n      }, e));\n    }(e).test(r) : !isNaN(Date.parse(r)));\n  },\n  email: function email(t) {\n    var e = t.value;\n    return Promise.resolve(/^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i.test(e));\n  },\n  endsWith: function endsWith(t) {\n    for (var e = t.value, r = [], o = arguments.length - 1; o-- > 0;) {\n      r[o] = arguments[o + 1];\n    }\n\n    return Promise.resolve(\"string\" == typeof e && r.length ? void 0 !== r.find(function (t) {\n      return e.endsWith(t);\n    }) : \"string\" == typeof e && 0 === r.length);\n  },\n  in: function _in(t) {\n    for (var e = t.value, r = [], o = arguments.length - 1; o-- > 0;) {\n      r[o] = arguments[o + 1];\n    }\n\n    return Promise.resolve(void 0 !== r.find(function (t) {\n      return \"object\" == _typeof(t) ? a(t, e) : t === e;\n    }));\n  },\n  matches: function matches(t) {\n    for (var e = t.value, r = [], o = arguments.length - 1; o-- > 0;) {\n      r[o] = arguments[o + 1];\n    }\n\n    return Promise.resolve(!!r.find(function (t) {\n      return \"string\" == typeof t && \"/\" === t.substr(0, 1) && \"/\" === t.substr(-1) && (t = new RegExp(t.substr(1, t.length - 2))), t instanceof RegExp ? t.test(e) : t === e;\n    }));\n  },\n  mime: function mime(t) {\n    for (var e = t.value, r = [], o = arguments.length - 1; o-- > 0;) {\n      r[o] = arguments[o + 1];\n    }\n\n    return Promise.resolve(function () {\n      if (e instanceof y) for (var t = e.getFiles(), o = 0; o < t.length; o++) {\n        var i = t[o].file;\n        if (!r.includes(i.type)) return !1;\n      }\n      return !0;\n    }());\n  },\n  min: function min(t, e, r) {\n    var o = t.value;\n    return void 0 === e && (e = 1), Promise.resolve(Array.isArray(o) ? (e = isNaN(e) ? e : Number(e), o.length >= e) : !isNaN(o) && \"length\" !== r || \"value\" === r ? (o = isNaN(o) ? o : Number(o)) >= e : (\"string\" == typeof o || \"length\" === r) && (o = isNaN(o) ? o : o.toString()).length >= e);\n  },\n  max: function max(t, e, r) {\n    var o = t.value;\n    return void 0 === e && (e = 10), Promise.resolve(Array.isArray(o) ? (e = isNaN(e) ? e : Number(e), o.length <= e) : !isNaN(o) && \"length\" !== r || \"value\" === r ? (o = isNaN(o) ? o : Number(o)) <= e : (\"string\" == typeof o || \"length\" === r) && (o = isNaN(o) ? o : o.toString()).length <= e);\n  },\n  not: function not(t) {\n    for (var e = t.value, r = [], o = arguments.length - 1; o-- > 0;) {\n      r[o] = arguments[o + 1];\n    }\n\n    return Promise.resolve(void 0 === r.find(function (t) {\n      return \"object\" == _typeof(t) ? a(t, e) : t === e;\n    }));\n  },\n  number: function number(t) {\n    var e = t.value;\n    return Promise.resolve(!isNaN(e));\n  },\n  required: function required(t, e) {\n    var r = t.value;\n    return void 0 === e && (e = \"pre\"), Promise.resolve(Array.isArray(r) ? !!r.length : r instanceof y ? r.getFiles().length > 0 : \"string\" == typeof r ? \"trim\" === e ? !!r.trim() : !!r : \"object\" != _typeof(r) || !!r && !!Object.keys(r).length);\n  },\n  startsWith: function startsWith(t) {\n    for (var e = t.value, r = [], o = arguments.length - 1; o-- > 0;) {\n      r[o] = arguments[o + 1];\n    }\n\n    return Promise.resolve(\"string\" == typeof e && r.length ? void 0 !== r.find(function (t) {\n      return e.startsWith(t);\n    }) : \"string\" == typeof e && 0 === r.length);\n  },\n  url: function url(e) {\n    var r = e.value;\n    return Promise.resolve(t(r));\n  },\n  bail: function bail() {\n    return Promise.resolve(!0);\n  },\n  optional: function optional(t) {\n    var e = t.value;\n    return Promise.resolve(!v(e));\n  }\n},\n    E = \"image/\",\n    _ = {\n  csv: \"text/csv\",\n  gif: E + \"gif\",\n  jpg: E + \"jpeg\",\n  jpeg: E + \"jpeg\",\n  png: E + \"png\",\n  pdf: \"application/pdf\",\n  svg: E + \"svg+xml\"\n},\n    F = [\"outer\", \"wrapper\", \"label\", \"element\", \"input\", \"help\", \"errors\", \"error\", \"decorator\", \"rangeValue\", \"uploadArea\", \"uploadAreaMask\", \"files\", \"file\", \"fileName\", \"fileAdd\", \"fileAddInput\", \"fileRemove\", \"fileProgress\", \"fileUploadError\", \"fileImagePreview\", \"fileImagePreviewImage\", \"fileProgressInner\", \"grouping\", \"groupRepeatable\", \"groupRepeatableRemove\", \"groupAddMore\", \"form\", \"formErrors\", \"formError\"],\n    w = {\n  hasErrors: function hasErrors(t) {\n    return t.hasErrors;\n  },\n  hasValue: function hasValue(t) {\n    return t.hasValue;\n  },\n  isValid: function isValid(t) {\n    return t.isValid;\n  }\n},\n    O = function O(t, e, r) {\n  var o = [];\n\n  switch (e) {\n    case \"label\":\n      o.push(t + \"--\" + r.labelPosition);\n      break;\n\n    case \"element\":\n      var i = \"group\" === r.classification ? \"group\" : r.type;\n      o.push(t + \"--\" + i), \"group\" === i && o.push(\"formulate-input-group\");\n      break;\n\n    case \"help\":\n      o.push(t + \"--\" + r.helpPosition);\n      break;\n\n    case \"form\":\n      r.name && o.push(t + \"--\" + r.name);\n  }\n\n  return o;\n},\n    P = (g = [\"\"].concat(Object.keys(w).map(function (t) {\n  return u(t);\n})), F.reduce(function (t, e) {\n  return t.concat(g.reduce(function (t, r) {\n    return t.push(\"\" + e + r + \"Class\"), t;\n  }, []));\n}, []));\n\nfunction V(t, e, r) {\n  switch (_typeof(e)) {\n    case \"string\":\n      return e;\n\n    case \"function\":\n      return e(r, c(t));\n\n    case \"object\":\n      if (Array.isArray(e)) return c(t).concat(e);\n\n    default:\n      return t;\n  }\n}\n\nfunction A(t) {\n  return F.reduce(function (e, r) {\n    var o;\n    return Object.assign(e, ((o = {})[r] = function (t, e) {\n      var r = t.replace(/[A-Z]/g, function (t) {\n        return \"-\" + t.toLowerCase();\n      }),\n          o = \"formulate\" + ([\"form\", \"file\"].includes(r.substr(0, 4)) ? \"\" : \"-input\") + ([\"decorator\", \"range-value\"].includes(r) ? \"-element\" : \"\") + (\"outer\" !== r ? \"-\" + r : \"\");\n      return \"input\" === r ? [] : [o].concat(O(o, t, e));\n    }(r, t), o));\n  }, {});\n}\n\nfunction S(t, e, r, o) {\n  return new Promise(function (r, i) {\n    var n = (o.fauxUploaderDuration || 1500) * (.5 + Math.random()),\n        s = performance.now(),\n        a = function a() {\n      return setTimeout(function () {\n        var o = performance.now() - s,\n            i = Math.min(100, Math.round(o / n * 100));\n        if (e(i), i >= 100) return r({\n          url: \"http://via.placeholder.com/350x150.png\",\n          name: t.name\n        });\n        a();\n      }, 20);\n    };\n\n    a();\n  });\n}\n\nfunction j(t, e) {\n  var r = {};\n\n  for (var o in t) {\n    Object.prototype.hasOwnProperty.call(t, o) && -1 === e.indexOf(o) && (r[o] = t[o]);\n  }\n\n  return r;\n}\n\nvar $ = {\n  inheritAttrs: !1,\n  functional: !0,\n  render: function render(t, e) {\n    for (var r = e.props, o = e.data, i = e.parent, n = e.children, s = i, a = (r.name, r.forceWrap), l = r.context, u = j(r, [\"name\", \"forceWrap\", \"context\"]); s && \"FormulateInput\" !== s.$options.name;) {\n      s = s.$parent;\n    }\n\n    if (!s) return null;\n    if (s.$scopedSlots && s.$scopedSlots[r.name]) return s.$scopedSlots[r.name](Object.assign({}, l, u));\n\n    if (Array.isArray(n) && (n.length > 1 || a && n.length > 0)) {\n      var c = o.attrs,\n          d = (c.name, c.context, j(c, [\"name\", \"context\"]));\n      return t(\"div\", Object.assign({}, o, {\n        attrs: d\n      }), n);\n    }\n\n    return Array.isArray(n) && 1 === n.length ? n[0] : null;\n  }\n};\n\nfunction C(t, e, r) {\n  if (void 0 === e && (e = 0), void 0 === r && (r = {}), t && \"object\" == _typeof(t) && !Array.isArray(t)) {\n    var o = t.children;\n    void 0 === o && (o = null);\n    var i = t.component;\n    void 0 === i && (i = \"FormulateInput\");\n    var n = t.depth;\n    void 0 === n && (n = 1);\n    var s = t.key;\n    void 0 === s && (s = null);\n\n    var a = function (t, e) {\n      var r = {};\n\n      for (var o in t) {\n        Object.prototype.hasOwnProperty.call(t, o) && -1 === e.indexOf(o) && (r[o] = t[o]);\n      }\n\n      return r;\n    }(t, [\"children\", \"component\", \"depth\", \"key\"]),\n        l = a.class || {};\n\n    delete a.class;\n    var u = {},\n        c = Object.keys(a).reduce(function (t, e) {\n      var r;\n      return /^@/.test(e) ? Object.assign(t, ((r = {})[e.substr(1)] = a[e], r)) : t;\n    }, {});\n    Object.keys(c).forEach(function (t) {\n      delete a[\"@\" + t], u[t] = function (t, e, r) {\n        return function () {\n          for (var o, i, n = [], s = arguments.length; s--;) {\n            n[s] = arguments[s];\n          }\n\n          return \"function\" == typeof e ? e.call.apply(e, [this].concat(n)) : \"string\" == typeof e && f(r, e) ? (o = r[e]).call.apply(o, [this].concat(n)) : f(r, t) ? (i = r[t]).call.apply(i, [this].concat(n)) : void 0;\n        };\n      }(t, c[t], r);\n    });\n    var d = \"FormulateInput\" === i ? a.type || \"text\" : i,\n        p = a.name || d || \"el\";\n    s || (s = a.id ? a.id : \"FormulateInput\" !== i && \"string\" == typeof o ? d + \"-\" + function (t, e) {\n      void 0 === e && (e = 0);\n\n      for (var r = 3735928559 ^ e, o = 1103547991 ^ e, i = 0, n = void 0; i < t.length; i++) {\n        n = t.charCodeAt(i), r = Math.imul(r ^ n, 2654435761), o = Math.imul(o ^ n, 1597334677);\n      }\n\n      return r = Math.imul(r ^ r >>> 16, 2246822507) ^ Math.imul(o ^ o >>> 13, 3266489909), 4294967296 * (2097151 & (o = Math.imul(o ^ o >>> 16, 2246822507) ^ Math.imul(r ^ r >>> 13, 3266489909))) + (r >>> 0);\n    }(o) : d + \"-\" + p + \"-\" + n + (a.name ? \"\" : \"-\" + e));\n    var h = Array.isArray(o) ? o.map(function (t) {\n      return Object.assign(t, {\n        depth: n + 1\n      });\n    }) : o;\n    return Object.assign({\n      key: s,\n      depth: n,\n      attrs: a,\n      component: i,\n      class: l,\n      on: u\n    }, h ? {\n      children: h\n    } : {});\n  }\n\n  return null;\n}\n\nvar k = {\n  functional: !0,\n  render: function render(t, e) {\n    var r = e.props,\n        o = e.listeners;\n    return function t(e, r, o) {\n      return Array.isArray(r) ? r.map(function (r, i) {\n        var n = C(r, i, o);\n        return e(n.component, {\n          attrs: n.attrs,\n          class: n.class,\n          key: n.key,\n          on: n.on\n        }, n.children ? t(e, n.children, o) : null);\n      }) : r;\n    }(t, r.schema, o);\n  }\n};\n\nfunction I(t, e) {\n  var r = {};\n\n  for (var o in t) {\n    Object.prototype.hasOwnProperty.call(t, o) && -1 === e.indexOf(o) && (r[o] = t[o]);\n  }\n\n  return r;\n}\n\nvar R = function R(t) {\n  this.registry = new Map(), this.errors = {}, this.ctx = t;\n};\n\nfunction D(t) {\n  return new R(t).dataProps();\n}\n\nfunction L(t) {\n  return {\n    hasInitialValue: function hasInitialValue() {\n      return this.formulateValue && \"object\" == _typeof(this.formulateValue) || this.values && \"object\" == _typeof(this.values) || this.isGrouping && \"object\" == _typeof(this.context.model[this.index]);\n    },\n    isVmodeled: function isVmodeled() {\n      return !!(this.$options.propsData.hasOwnProperty(\"formulateValue\") && this._events && Array.isArray(this._events.input) && this._events.input.length);\n    },\n    initialValues: function initialValues() {\n      return f(this.$options.propsData, \"formulateValue\") && \"object\" == _typeof(this.formulateValue) ? Object.assign({}, this.formulateValue) : f(this.$options.propsData, \"values\") && \"object\" == _typeof(this.values) ? Object.assign({}, this.values) : this.isGrouping && \"object\" == _typeof(this.context.model[this.index]) ? this.context.model[this.index] : {};\n    },\n    mergedGroupErrors: function mergedGroupErrors() {\n      var t = this,\n          e = /^([^.\\d+].*?)\\.(\\d+\\..+)$/;\n      return Object.keys(this.mergedFieldErrors).filter(function (t) {\n        return e.test(t);\n      }).reduce(function (r, o) {\n        var i,\n            n = o.match(e),\n            s = n[1],\n            a = n[2];\n        return r[s] || (r[s] = {}), Object.assign(r[s], ((i = {})[a] = t.mergedFieldErrors[o], i)), r;\n      }, {});\n    }\n  };\n}\n\nfunction N(t) {\n  void 0 === t && (t = []);\n  var e = {\n    applyInitialValues: function applyInitialValues() {\n      this.hasInitialValue && (this.proxy = Object.assign({}, this.initialValues));\n    },\n    setFieldValue: function setFieldValue(t, e) {\n      var r;\n\n      if (void 0 === e) {\n        var o = this.proxy,\n            i = (o[t], I(o, [String(t)]));\n        this.proxy = i;\n      } else Object.assign(this.proxy, ((r = {})[t] = e, r));\n\n      this.$emit(\"input\", Object.assign({}, this.proxy));\n    },\n    valueDeps: function valueDeps(t) {\n      var e = this;\n      return Object.keys(this.proxy).reduce(function (r, o) {\n        return Object.defineProperty(r, o, {\n          enumerable: !0,\n          get: function get() {\n            var r = e.registry.get(o);\n            return e.deps.set(t, e.deps.get(t) || new Set()), r && (e.deps.set(r, e.deps.get(r) || new Set()), e.deps.get(r).add(t.name)), e.deps.get(t).add(o), e.proxy[o];\n          }\n        });\n      }, Object.create(null));\n    },\n    validateDeps: function validateDeps(t) {\n      var e = this;\n      this.deps.has(t) && this.deps.get(t).forEach(function (t) {\n        return e.registry.has(t) && e.registry.get(t).performValidation();\n      });\n    },\n    hasValidationErrors: function hasValidationErrors() {\n      return Promise.all(this.registry.reduce(function (t, e, r) {\n        return t.push(e.performValidation() && e.getValidationErrors()), t;\n      }, [])).then(function (t) {\n        return t.some(function (t) {\n          return t.hasErrors;\n        });\n      });\n    },\n    showErrors: function showErrors() {\n      this.childrenShouldShowErrors = !0, this.registry.map(function (t) {\n        t.formShouldShowErrors = !0;\n      });\n    },\n    hideErrors: function hideErrors() {\n      this.childrenShouldShowErrors = !1, this.registry.map(function (t) {\n        t.formShouldShowErrors = !1, t.behavioralErrorVisibility = !1;\n      });\n    },\n    setValues: function setValues(t) {\n      var e = this;\n      Array.from(new Set(Object.keys(t || {}).concat(Object.keys(this.proxy)))).forEach(function (r) {\n        var o = e.registry.has(r) && e.registry.get(r),\n            i = t ? t[r] : void 0;\n        o && !a(o.proxy, i, !0) && (o.context.model = i), a(i, e.proxy[r], !0) || e.setFieldValue(r, i);\n      });\n    },\n    updateValidation: function updateValidation(t) {\n      f(this.registry.errors, t.name) && (this.registry.errors[t.name] = t.hasErrors), this.$emit(\"validation\", t);\n    },\n    addErrorObserver: function addErrorObserver(t) {\n      this.errorObservers.find(function (e) {\n        return t.callback === e.callback;\n      }) || (this.errorObservers.push(t), \"form\" === t.type ? t.callback(this.mergedFormErrors) : \"group\" === t.type && f(this.mergedGroupErrors, t.field) ? t.callback(this.mergedGroupErrors[t.field]) : f(this.mergedFieldErrors, t.field) && t.callback(this.mergedFieldErrors[t.field]));\n    },\n    removeErrorObserver: function removeErrorObserver(t) {\n      this.errorObservers = this.errorObservers.filter(function (e) {\n        return e.callback !== t;\n      });\n    }\n  };\n  return Object.keys(e).reduce(function (r, o) {\n    var i;\n    return t.includes(o) ? r : Object.assign({}, r, ((i = {})[o] = e[o], i));\n  }, {});\n}\n\nfunction B(t, e) {\n  void 0 === e && (e = []);\n  var r = {\n    formulateSetter: t.setFieldValue,\n    formulateRegister: t.register,\n    formulateDeregister: t.deregister,\n    formulateFieldValidation: t.updateValidation,\n    getFormValues: t.valueDeps,\n    getGroupValues: t.valueDeps,\n    validateDependents: t.validateDeps,\n    observeErrors: t.addErrorObserver,\n    removeErrorObserver: t.removeErrorObserver\n  };\n  return Object.keys(r).filter(function (t) {\n    return !e.includes(t);\n  }).reduce(function (t, e) {\n    var o;\n    return Object.assign(t, ((o = {})[e] = r[e], o));\n  }, {});\n}\n\nR.prototype.add = function (t, e) {\n  var r;\n  return this.registry.set(t, e), this.errors = Object.assign({}, this.errors, ((r = {})[t] = e.getErrorObject().hasErrors, r)), this;\n}, R.prototype.remove = function (t) {\n  this.ctx.deps.delete(this.registry.get(t)), this.ctx.deps.forEach(function (e) {\n    return e.delete(t);\n  });\n  var e = this.ctx.keepModelData;\n  !e && this.registry.has(t) && \"inherit\" !== this.registry.get(t).keepModelData && (e = this.registry.get(t).keepModelData), this.ctx.preventCleanup && (e = !0), this.registry.delete(t);\n  var r = this.errors,\n      o = (r[t], I(r, [String(t)]));\n\n  if (this.errors = o, !e) {\n    var i = this.ctx.proxy,\n        n = (i[t], I(i, [String(t)]));\n    this.ctx.uuid && m(n, this.ctx.uuid), this.ctx.proxy = n, this.ctx.$emit(\"input\", this.ctx.proxy);\n  }\n\n  return this;\n}, R.prototype.has = function (t) {\n  return this.registry.has(t);\n}, R.prototype.get = function (t) {\n  return this.registry.get(t);\n}, R.prototype.map = function (t) {\n  var e = {};\n  return this.registry.forEach(function (r, o) {\n    var i;\n    return Object.assign(e, ((i = {})[o] = t(r, o), i));\n  }), e;\n}, R.prototype.keys = function () {\n  return Array.from(this.registry.keys());\n}, R.prototype.register = function (t, e) {\n  var r = this;\n  if (f(e.$options.propsData, \"ignored\")) return !1;\n  if (this.registry.has(t)) return this.ctx.$nextTick(function () {\n    return !r.registry.has(t) && r.register(t, e);\n  }), !1;\n  this.add(t, e);\n  var o = f(e.$options.propsData, \"formulateValue\"),\n      i = f(e.$options.propsData, \"value\"),\n      n = this.ctx.debounce || this.ctx.debounceDelay || this.ctx.context && this.ctx.context.debounceDelay;\n  n && !f(e.$options.propsData, \"debounce\") && (e.debounceDelay = n), o || !this.ctx.hasInitialValue || v(this.ctx.initialValues[t]) ? !o && !i || a(e.proxy, this.ctx.initialValues[t], !0) || this.ctx.setFieldValue(t, e.proxy) : e.context.model = this.ctx.initialValues[t], this.childrenShouldShowErrors && (e.formShouldShowErrors = !0);\n}, R.prototype.reduce = function (t, e) {\n  return this.registry.forEach(function (r, o) {\n    e = t(e, r, o);\n  }), e;\n}, R.prototype.dataProps = function () {\n  var t = this;\n  return {\n    proxy: {},\n    registry: this,\n    register: this.register.bind(this),\n    deregister: function deregister(e) {\n      return t.remove(e);\n    },\n    childrenShouldShowErrors: !1,\n    errorObservers: [],\n    deps: new Map(),\n    preventCleanup: !1\n  };\n};\n\nvar M = function M(t) {\n  this.form = t;\n};\n\nfunction U(t, e, r, o, i, n, s, a, l, u) {\n  \"boolean\" != typeof s && (l = a, a = s, s = !1);\n  var c,\n      d = \"function\" == typeof r ? r.options : r;\n  if (t && t.render && (d.render = t.render, d.staticRenderFns = t.staticRenderFns, d._compiled = !0, i && (d.functional = !0)), o && (d._scopeId = o), n ? (c = function c(t) {\n    (t = t || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) || \"undefined\" == typeof __VUE_SSR_CONTEXT__ || (t = __VUE_SSR_CONTEXT__), e && e.call(this, l(t)), t && t._registeredComponents && t._registeredComponents.add(n);\n  }, d._ssrRegister = c) : e && (c = s ? function (t) {\n    e.call(this, u(t, this.$root.$options.shadowRoot));\n  } : function (t) {\n    e.call(this, a(t));\n  }), c) if (d.functional) {\n    var p = d.render;\n\n    d.render = function (t, e) {\n      return c.call(e), p(t, e);\n    };\n  } else {\n    var h = d.beforeCreate;\n    d.beforeCreate = h ? [].concat(h, c) : [c];\n  }\n  return r;\n}\n\nM.prototype.hasValidationErrors = function () {\n  return this.form.hasValidationErrors();\n}, M.prototype.values = function () {\n  var t = this;\n  return new Promise(function (e, r) {\n    var o = [],\n        i = function t(e) {\n      if (\"object\" != _typeof(e)) return e;\n      var r = Array.isArray(e) ? [] : {};\n\n      for (var o in e) {\n        e[o] instanceof y || h(e[o]) ? r[o] = e[o] : r[o] = t(e[o]);\n      }\n\n      return r;\n    }(t.form.proxy),\n        n = function n(e) {\n      \"object\" == _typeof(t.form.proxy[e]) && t.form.proxy[e] instanceof y && o.push(t.form.proxy[e].upload().then(function (t) {\n        var r;\n        return Object.assign(i, ((r = {})[e] = t, r));\n      }));\n    };\n\n    for (var s in i) {\n      n(s);\n    }\n\n    Promise.all(o).then(function () {\n      return e(i);\n    }).catch(function (t) {\n      return r(t);\n    });\n  });\n};\n\nvar G = {\n  name: \"FormulateForm\",\n  inheritAttrs: !1,\n  provide: function provide() {\n    return Object.assign({}, B(this, [\"getGroupValues\"]), {\n      observeContext: this.addContextObserver,\n      removeContextObserver: this.removeContextObserver\n    });\n  },\n  model: {\n    prop: \"formulateValue\",\n    event: \"input\"\n  },\n  props: {\n    name: {\n      type: [String, Boolean],\n      default: !1\n    },\n    formulateValue: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    values: {\n      type: [Object, Boolean],\n      default: !1\n    },\n    errors: {\n      type: [Object, Boolean],\n      default: !1\n    },\n    formErrors: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    schema: {\n      type: [Array, Boolean],\n      default: !1\n    },\n    keepModelData: {\n      type: [Boolean, String],\n      default: !1\n    },\n    invalidMessage: {\n      type: [Boolean, Function, String],\n      default: !1\n    },\n    debounce: {\n      type: [Boolean, Number],\n      default: !1\n    }\n  },\n  data: function data() {\n    return Object.assign({}, D(this), {\n      formShouldShowErrors: !1,\n      contextObservers: [],\n      namedErrors: [],\n      namedFieldErrors: {},\n      isLoading: !1,\n      hasFailedSubmit: !1\n    });\n  },\n  computed: Object.assign({}, L(), {\n    schemaListeners: function schemaListeners() {\n      var t = this.$listeners;\n      t.submit;\n      return function (t, e) {\n        var r = {};\n\n        for (var o in t) {\n          Object.prototype.hasOwnProperty.call(t, o) && -1 === e.indexOf(o) && (r[o] = t[o]);\n        }\n\n        return r;\n      }(t, [\"submit\"]);\n    },\n    pseudoProps: function pseudoProps() {\n      return x(this.$attrs, P.filter(function (t) {\n        return /^form/.test(t);\n      }));\n    },\n    attributes: function attributes() {\n      var t = this,\n          e = Object.keys(this.$attrs).filter(function (e) {\n        return !f(t.pseudoProps, l(e));\n      }).reduce(function (e, r) {\n        var o;\n        return Object.assign({}, e, ((o = {})[r] = t.$attrs[r], o));\n      }, {});\n      return \"string\" == typeof this.name && Object.assign(e, {\n        name: this.name\n      }), e;\n    },\n    hasErrors: function hasErrors() {\n      return Object.values(this.registry.errors).some(function (t) {\n        return t;\n      });\n    },\n    isValid: function isValid() {\n      return !this.hasErrors;\n    },\n    formContext: function formContext() {\n      return {\n        errors: this.mergedFormErrors,\n        pseudoProps: this.pseudoProps,\n        hasErrors: this.hasErrors,\n        value: this.proxy,\n        hasValue: !v(this.proxy),\n        isValid: this.isValid,\n        isLoading: this.isLoading,\n        classes: this.classes\n      };\n    },\n    classes: function classes() {\n      return this.$formulate.classes(Object.assign({}, this.$props, this.pseudoProps, {\n        value: this.proxy,\n        errors: this.mergedFormErrors,\n        hasErrors: this.hasErrors,\n        hasValue: !v(this.proxy),\n        isValid: this.isValid,\n        isLoading: this.isLoading,\n        type: \"form\",\n        classification: \"form\",\n        attrs: this.$attrs\n      }));\n    },\n    invalidErrors: function invalidErrors() {\n      if (this.hasFailedSubmit && this.hasErrors) switch (_typeof(this.invalidMessage)) {\n        case \"string\":\n          return [this.invalidMessage];\n\n        case \"object\":\n          return Array.isArray(this.invalidMessage) ? this.invalidMessage : [];\n\n        case \"function\":\n          var t = this.invalidMessage(this.failingFields);\n          return Array.isArray(t) ? t : [t];\n      }\n      return [];\n    },\n    mergedFormErrors: function mergedFormErrors() {\n      return this.formErrors.concat(this.namedErrors).concat(this.invalidErrors);\n    },\n    mergedFieldErrors: function mergedFieldErrors() {\n      var t = {};\n      if (this.errors) for (var e in this.errors) {\n        t[e] = c(this.errors[e]);\n      }\n\n      for (var r in this.namedFieldErrors) {\n        t[r] = c(this.namedFieldErrors[r]);\n      }\n\n      return t;\n    },\n    hasFormErrorObservers: function hasFormErrorObservers() {\n      return !!this.errorObservers.filter(function (t) {\n        return \"form\" === t.type;\n      }).length;\n    },\n    failingFields: function failingFields() {\n      var t = this;\n      return Object.keys(this.registry.errors).reduce(function (e, r) {\n        var o;\n        return Object.assign({}, e, t.registry.errors[r] ? ((o = {})[r] = t.registry.get(r), o) : {});\n      }, {});\n    }\n  }),\n  watch: Object.assign({}, {\n    mergedFieldErrors: {\n      handler: function handler(t) {\n        this.errorObservers.filter(function (t) {\n          return \"input\" === t.type;\n        }).forEach(function (e) {\n          return e.callback(t[e.field] || []);\n        });\n      },\n      immediate: !0\n    },\n    mergedGroupErrors: {\n      handler: function handler(t) {\n        this.errorObservers.filter(function (t) {\n          return \"group\" === t.type;\n        }).forEach(function (e) {\n          return e.callback(t[e.field] || {});\n        });\n      },\n      immediate: !0\n    }\n  }, {\n    formulateValue: {\n      handler: function handler(t) {\n        this.isVmodeled && t && \"object\" == _typeof(t) && this.setValues(t);\n      },\n      deep: !0\n    },\n    mergedFormErrors: function mergedFormErrors(t) {\n      this.errorObservers.filter(function (t) {\n        return \"form\" === t.type;\n      }).forEach(function (e) {\n        return e.callback(t);\n      });\n    }\n  }),\n  created: function created() {\n    this.$formulate.register(this), this.applyInitialValues(), this.$emit(\"created\", this);\n  },\n  destroyed: function destroyed() {\n    this.$formulate.deregister(this);\n  },\n  methods: Object.assign({}, N(), {\n    applyErrors: function applyErrors(t) {\n      var e = t.formErrors,\n          r = t.inputErrors;\n      this.namedErrors = e, this.namedFieldErrors = r;\n    },\n    addContextObserver: function addContextObserver(t) {\n      this.contextObservers.find(function (e) {\n        return e === t;\n      }) || (this.contextObservers.push(t), t(this.formContext));\n    },\n    removeContextObserver: function removeContextObserver(t) {\n      this.contextObservers.filter(function (e) {\n        return e !== t;\n      });\n    },\n    registerErrorComponent: function registerErrorComponent(t) {\n      this.errorComponents.includes(t) || this.errorComponents.push(t);\n    },\n    formSubmitted: function formSubmitted() {\n      var t = this;\n\n      if (!this.isLoading) {\n        this.isLoading = !0, this.showErrors();\n        var e = new M(this),\n            r = this.$listeners[\"submit-raw\"] || this.$listeners.submitRaw,\n            o = \"function\" == typeof r ? r(e) : Promise.resolve(e);\n        return (o instanceof Promise ? o : Promise.resolve(o)).then(function (t) {\n          var r = t instanceof M ? t : e;\n          return r.hasValidationErrors().then(function (t) {\n            return [r, t];\n          });\n        }).then(function (e) {\n          var r = e[0];\n          return e[1] || \"function\" != typeof t.$listeners.submit ? t.onFailedValidation() : r.values().then(function (e) {\n            t.hasFailedSubmit = !1;\n            var r = t.$listeners.submit(e);\n            return (r instanceof Promise ? r : Promise.resolve()).then(function () {\n              return e;\n            });\n          });\n        }).finally(function () {\n          t.isLoading = !1;\n        });\n      }\n    },\n    onFailedValidation: function onFailedValidation() {\n      return this.hasFailedSubmit = !0, this.$emit(\"failed-validation\", Object.assign({}, this.failingFields)), this.$formulate.failedValidation(this);\n    }\n  })\n},\n    T = function T() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"form\", t._b({\n    class: t.classes.form,\n    on: {\n      submit: function submit(e) {\n        return e.preventDefault(), t.formSubmitted(e);\n      }\n    }\n  }, \"form\", t.attributes, !1), [t.schema ? r(\"FormulateSchema\", t._g({\n    attrs: {\n      schema: t.schema\n    }\n  }, t.schemaListeners)) : t._e(), t._v(\" \"), t.hasFormErrorObservers ? t._e() : r(\"FormulateErrors\", {\n    attrs: {\n      context: t.formContext\n    }\n  }), t._v(\" \"), t._t(\"default\", null, null, t.formContext)], 2);\n};\n\nT._withStripped = !0;\nvar q = U({\n  render: T,\n  staticRenderFns: []\n}, void 0, G, void 0, !1, void 0, !1, void 0, void 0, void 0);\nvar H = {\n  context: function context() {\n    return K.call(this, Object.assign({}, {\n      addLabel: this.logicalAddLabel,\n      removeLabel: this.logicalRemoveLabel,\n      attributes: this.elementAttributes,\n      blurHandler: z.bind(this),\n      classification: this.classification,\n      component: this.component,\n      debounceDelay: this.debounceDelay,\n      disableErrors: this.disableErrors,\n      errors: this.explicitErrors,\n      formShouldShowErrors: this.formShouldShowErrors,\n      getValidationErrors: this.getValidationErrors.bind(this),\n      groupErrors: this.mergedGroupErrors,\n      hasGivenName: this.hasGivenName,\n      hasValue: this.hasValue,\n      hasLabel: this.label && \"button\" !== this.classification,\n      hasValidationErrors: this.hasValidationErrors.bind(this),\n      help: this.help,\n      helpPosition: this.logicalHelpPosition,\n      id: this.id || this.defaultId,\n      ignored: f(this.$options.propsData, \"ignored\"),\n      isValid: this.isValid,\n      imageBehavior: this.imageBehavior,\n      label: this.label,\n      labelPosition: this.logicalLabelPosition,\n      limit: this.limit === 1 / 0 ? this.limit : parseInt(this.limit, 10),\n      name: this.nameOrFallback,\n      minimum: parseInt(this.minimum, 10),\n      performValidation: this.performValidation.bind(this),\n      pseudoProps: this.pseudoProps,\n      preventWindowDrops: this.preventWindowDrops,\n      removePosition: this.mergedRemovePosition,\n      repeatable: this.repeatable,\n      rootEmit: this.$emit.bind(this),\n      rules: this.ruleDetails,\n      setErrors: this.setErrors.bind(this),\n      showValidationErrors: this.showValidationErrors,\n      slotComponents: this.slotComponents,\n      slotProps: this.slotProps,\n      type: this.type,\n      uploadBehavior: this.uploadBehavior,\n      uploadUrl: this.mergedUploadUrl,\n      uploader: this.uploader || this.$formulate.getUploader(),\n      validationErrors: this.validationErrors,\n      value: this.value,\n      visibleValidationErrors: this.visibleValidationErrors,\n      isSubField: this.isSubField,\n      classes: this.classes\n    }, this.typeContext));\n  },\n  nameOrFallback: function nameOrFallback() {\n    if (!0 === this.name && \"button\" !== this.classification) {\n      var t = this.id || this.elementAttributes.id.replace(/[^0-9]/g, \"\");\n      return this.type + \"_\" + t;\n    }\n\n    if (!1 === this.name || \"button\" === this.classification && !0 === this.name) return !1;\n    return this.name;\n  },\n  hasGivenName: function hasGivenName() {\n    return \"boolean\" != typeof this.name;\n  },\n  typeContext: function typeContext() {\n    var t = this;\n\n    switch (this.classification) {\n      case \"select\":\n        return {\n          options: W.call(this, this.options),\n          optionGroups: !!this.optionGroups && s(this.optionGroups, function (e, r) {\n            return W.call(t, r);\n          }),\n          placeholder: this.$attrs.placeholder || !1\n        };\n\n      case \"slider\":\n        return {\n          showValue: !!this.showValue\n        };\n\n      default:\n        return this.options ? {\n          options: W.call(this, this.options)\n        } : {};\n    }\n  },\n  elementAttributes: function elementAttributes() {\n    var t = Object.assign({}, this.filteredAttributes);\n    this.id ? t.id = this.id : t.id = this.defaultId;\n    this.hasGivenName && (t.name = this.name);\n    this.help && !f(t, \"aria-describedby\") && (t[\"aria-describedby\"] = t.id + \"-help\");\n    !this.classes.input || Array.isArray(this.classes.input) && !this.classes.input.length || (t.class = this.classes.input);\n    return t;\n  },\n  logicalLabelPosition: function logicalLabelPosition() {\n    if (this.labelPosition) return this.labelPosition;\n\n    switch (this.classification) {\n      case \"box\":\n        return \"after\";\n\n      default:\n        return \"before\";\n    }\n  },\n  logicalHelpPosition: function logicalHelpPosition() {\n    if (this.helpPosition) return this.helpPosition;\n\n    switch (this.classification) {\n      case \"group\":\n        return \"before\";\n\n      default:\n        return \"after\";\n    }\n  },\n  mergedRemovePosition: function mergedRemovePosition() {\n    return \"group\" === this.type && (this.removePosition || \"before\");\n  },\n  mergedUploadUrl: function mergedUploadUrl() {\n    return this.uploadUrl || this.$formulate.getUploadUrl();\n  },\n  mergedGroupErrors: function mergedGroupErrors() {\n    var t = this,\n        e = Object.keys(this.groupErrors).concat(Object.keys(this.localGroupErrors)),\n        r = /^(\\d+)\\.(.*)$/;\n    return Array.from(new Set(e)).filter(function (t) {\n      return r.test(t);\n    }).reduce(function (e, o) {\n      var i,\n          n = o.match(r),\n          s = n[1],\n          a = n[2];\n      f(e, s) || (e[s] = {});\n      var l = Array.from(new Set(c(t.groupErrors[o]).concat(c(t.localGroupErrors[o]))));\n      return e[s] = Object.assign(e[s], ((i = {})[a] = l, i)), e;\n    }, {});\n  },\n  hasValue: function hasValue() {\n    var t = this,\n        e = this.proxy;\n    if (\"box\" === this.classification && this.isGrouped || \"select\" === this.classification && f(this.filteredAttributes, \"multiple\")) return Array.isArray(e) ? e.some(function (e) {\n      return e === t.value;\n    }) : this.value === e;\n    return !v(e);\n  },\n  visibleValidationErrors: function visibleValidationErrors() {\n    return this.showValidationErrors && this.validationErrors.length ? this.validationErrors : [];\n  },\n  slotComponents: function slotComponents() {\n    var t = this.$formulate.slotComponent.bind(this.$formulate);\n    return {\n      addMore: t(this.type, \"addMore\"),\n      buttonContent: t(this.type, \"buttonContent\"),\n      errors: t(this.type, \"errors\"),\n      file: t(this.type, \"file\"),\n      help: t(this.type, \"help\"),\n      label: t(this.type, \"label\"),\n      prefix: t(this.type, \"prefix\"),\n      remove: t(this.type, \"remove\"),\n      repeatable: t(this.type, \"repeatable\"),\n      suffix: t(this.type, \"suffix\"),\n      uploadAreaMask: t(this.type, \"uploadAreaMask\")\n    };\n  },\n  logicalAddLabel: function logicalAddLabel() {\n    if (\"file\" === this.classification) return !0 === this.addLabel ? \"+ Add \" + u(this.type) : this.addLabel;\n\n    if (\"boolean\" == typeof this.addLabel) {\n      var t = this.label || this.name;\n      return \"+ \" + (\"string\" == typeof t ? t + \" \" : \"\") + \" Add\";\n    }\n\n    return this.addLabel;\n  },\n  logicalRemoveLabel: function logicalRemoveLabel() {\n    if (\"boolean\" == typeof this.removeLabel) return \"Remove\";\n    return this.removeLabel;\n  },\n  classes: function classes() {\n    return this.$formulate.classes(Object.assign({}, this.$props, this.pseudoProps, {\n      attrs: this.filteredAttributes,\n      classification: this.classification,\n      hasErrors: this.hasVisibleErrors,\n      hasValue: this.hasValue,\n      helpPosition: this.logicalHelpPosition,\n      isValid: this.isValid,\n      labelPosition: this.logicalLabelPosition,\n      type: this.type,\n      value: this.proxy\n    }));\n  },\n  showValidationErrors: function showValidationErrors() {\n    if (this.showErrors || this.formShouldShowErrors) return !0;\n    if (\"file\" === this.classification && \"live\" === this.uploadBehavior && Z.call(this)) return !0;\n    return this.behavioralErrorVisibility;\n  },\n  slotProps: function slotProps() {\n    var t = this.$formulate.slotProps.bind(this.$formulate);\n    return {\n      label: t(this.type, \"label\", this.typeProps),\n      help: t(this.type, \"help\", this.typeProps),\n      errors: t(this.type, \"errors\", this.typeProps),\n      repeatable: t(this.type, \"repeatable\", this.typeProps),\n      addMore: t(this.type, \"addMore\", this.typeProps),\n      remove: t(this.type, \"remove\", this.typeProps),\n      component: t(this.type, \"component\", this.typeProps)\n    };\n  },\n  pseudoProps: function pseudoProps() {\n    return x(this.localAttributes, P);\n  },\n  isValid: function isValid() {\n    return !this.hasErrors;\n  },\n  ruleDetails: function ruleDetails() {\n    return this.parsedValidation.map(function (t) {\n      var e = t[1];\n      return {\n        ruleName: t[2],\n        args: e\n      };\n    });\n  },\n  isVmodeled: function isVmodeled() {\n    return !!(this.$options.propsData.hasOwnProperty(\"formulateValue\") && this._events && Array.isArray(this._events.input) && this._events.input.length);\n  },\n  mergedValidationName: function mergedValidationName() {\n    var t = this,\n        e = this.$formulate.options.validationNameStrategy || [\"validationName\", \"name\", \"label\", \"type\"];\n\n    if (Array.isArray(e)) {\n      return this[e.find(function (e) {\n        return \"string\" == typeof t[e];\n      })];\n    }\n\n    if (\"function\" == typeof e) return e.call(this, this);\n    return this.type;\n  },\n  explicitErrors: function explicitErrors() {\n    return c(this.errors).concat(this.localErrors).concat(c(this.error));\n  },\n  allErrors: function allErrors() {\n    return this.explicitErrors.concat(c(this.validationErrors));\n  },\n  hasVisibleErrors: function hasVisibleErrors() {\n    return Array.isArray(this.validationErrors) && this.validationErrors.length && this.showValidationErrors || !!this.explicitErrors.length;\n  },\n  hasErrors: function hasErrors() {\n    return !!this.allErrors.length;\n  },\n  filteredAttributes: function filteredAttributes() {\n    var t = this,\n        e = Object.keys(this.pseudoProps).concat(Object.keys(this.typeProps));\n    return Object.keys(this.localAttributes).reduce(function (r, o) {\n      return e.includes(l(o)) || (r[o] = t.localAttributes[o]), r;\n    }, {});\n  },\n  typeProps: function typeProps() {\n    return x(this.localAttributes, this.$formulate.typeProps(this.type));\n  },\n  listeners: function listeners() {\n    var t = this.$listeners;\n    t.input;\n    return function (t, e) {\n      var r = {};\n\n      for (var o in t) {\n        Object.prototype.hasOwnProperty.call(t, o) && -1 === e.indexOf(o) && (r[o] = t[o]);\n      }\n\n      return r;\n    }(t, [\"input\"]);\n  }\n};\n\nfunction W(t) {\n  return t ? (Array.isArray(t) ? t : Object.keys(t).map(function (e) {\n    return {\n      label: t[e],\n      value: e\n    };\n  })).map(Y.bind(this)) : [];\n}\n\nfunction Y(t) {\n  return \"number\" == typeof t && (t = String(t)), \"string\" == typeof t ? {\n    label: t,\n    value: t,\n    id: this.elementAttributes.id + \"_\" + t\n  } : (\"number\" == typeof t.value && (t.value = String(t.value)), Object.assign({\n    value: \"\",\n    label: \"\",\n    id: this.elementAttributes.id + \"_\" + (t.value || t.label)\n  }, t));\n}\n\nfunction z() {\n  var t = this;\n  \"blur\" !== this.errorBehavior && \"value\" !== this.errorBehavior || (this.behavioralErrorVisibility = !0), this.$nextTick(function () {\n    return t.$emit(\"blur-context\", t.context);\n  });\n}\n\nfunction K(t) {\n  var e = this;\n  return Object.defineProperty(t, \"model\", {\n    get: Z.bind(this),\n    set: function set(t) {\n      if (!e.mntd || !e.debounceDelay) return J.call(e, t);\n      e.dSet(J, [t], e.debounceDelay);\n    },\n    enumerable: !0\n  });\n}\n\nfunction Z() {\n  var t = this.isVmodeled ? \"formulateValue\" : \"proxy\";\n  return \"checkbox\" === this.type && !Array.isArray(this[t]) && this.options ? [] : this[t] || 0 === this[t] ? this[t] : \"\";\n}\n\nfunction J(t) {\n  var e = !1;\n  a(t, this.proxy, \"group\" === this.type) || (this.proxy = t, e = !0), !this.context.ignored && this.context.name && \"function\" == typeof this.formulateSetter && this.formulateSetter(this.context.name, t), e && this.$emit(\"input\", t);\n}\n\nvar X = {\n  name: \"FormulateInput\",\n  inheritAttrs: !1,\n  provide: function provide() {\n    return {\n      formulateRegisterRule: this.registerRule,\n      formulateRemoveRule: this.removeRule\n    };\n  },\n  inject: {\n    formulateSetter: {\n      default: void 0\n    },\n    formulateFieldValidation: {\n      default: function _default() {\n        return function () {\n          return {};\n        };\n      }\n    },\n    formulateRegister: {\n      default: void 0\n    },\n    formulateDeregister: {\n      default: void 0\n    },\n    getFormValues: {\n      default: function _default() {\n        return function () {\n          return {};\n        };\n      }\n    },\n    getGroupValues: {\n      default: void 0\n    },\n    validateDependents: {\n      default: function _default() {\n        return function () {};\n      }\n    },\n    observeErrors: {\n      default: void 0\n    },\n    removeErrorObserver: {\n      default: void 0\n    },\n    isSubField: {\n      default: function _default() {\n        return function () {\n          return !1;\n        };\n      }\n    }\n  },\n  model: {\n    prop: \"formulateValue\",\n    event: \"input\"\n  },\n  props: {\n    type: {\n      type: String,\n      default: \"text\"\n    },\n    name: {\n      type: [String, Boolean],\n      default: !0\n    },\n    formulateValue: {\n      default: \"\"\n    },\n    value: {\n      default: !1\n    },\n    options: {\n      type: [Object, Array, Boolean],\n      default: !1\n    },\n    optionGroups: {\n      type: [Object, Boolean],\n      default: !1\n    },\n    id: {\n      type: [String, Boolean, Number],\n      default: !1\n    },\n    label: {\n      type: [String, Boolean],\n      default: !1\n    },\n    labelPosition: {\n      type: [String, Boolean],\n      default: !1\n    },\n    limit: {\n      type: [String, Number],\n      default: 1 / 0,\n      validator: function validator(t) {\n        return 1 / 0;\n      }\n    },\n    minimum: {\n      type: [String, Number],\n      default: 0,\n      validator: function validator(t) {\n        return parseInt(t, 10) == t;\n      }\n    },\n    help: {\n      type: [String, Boolean],\n      default: !1\n    },\n    helpPosition: {\n      type: [String, Boolean],\n      default: !1\n    },\n    isGrouped: {\n      type: Boolean,\n      default: !1\n    },\n    errors: {\n      type: [String, Array, Boolean],\n      default: !1\n    },\n    removePosition: {\n      type: [String, Boolean],\n      default: !1\n    },\n    repeatable: {\n      type: Boolean,\n      default: !1\n    },\n    validation: {\n      type: [String, Boolean, Array],\n      default: !1\n    },\n    validationName: {\n      type: [String, Boolean],\n      default: !1\n    },\n    error: {\n      type: [String, Boolean],\n      default: !1\n    },\n    errorBehavior: {\n      type: String,\n      default: \"blur\",\n      validator: function validator(t) {\n        return [\"blur\", \"live\", \"submit\", \"value\"].includes(t);\n      }\n    },\n    showErrors: {\n      type: Boolean,\n      default: !1\n    },\n    groupErrors: {\n      type: Object,\n      default: function _default() {\n        return {};\n      },\n      validator: function validator(t) {\n        var e = /^\\d+\\./;\n        return !Object.keys(t).some(function (t) {\n          return !e.test(t);\n        });\n      }\n    },\n    imageBehavior: {\n      type: String,\n      default: \"preview\"\n    },\n    uploadUrl: {\n      type: [String, Boolean],\n      default: !1\n    },\n    uploader: {\n      type: [Function, Object, Boolean],\n      default: !1\n    },\n    uploadBehavior: {\n      type: String,\n      default: \"live\"\n    },\n    preventWindowDrops: {\n      type: Boolean,\n      default: !0\n    },\n    showValue: {\n      type: [String, Boolean],\n      default: !1\n    },\n    validationMessages: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    validationRules: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    checked: {\n      type: [String, Boolean],\n      default: !1\n    },\n    disableErrors: {\n      type: Boolean,\n      default: !1\n    },\n    addLabel: {\n      type: [Boolean, String],\n      default: !0\n    },\n    removeLabel: {\n      type: [Boolean, String],\n      default: !1\n    },\n    keepModelData: {\n      type: [Boolean, String],\n      default: \"inherit\"\n    },\n    ignored: {\n      type: [Boolean, String],\n      default: !1\n    },\n    debounce: {\n      type: [Boolean, Number],\n      default: !1\n    },\n    preventDeregister: {\n      type: Boolean,\n      default: !1\n    }\n  },\n  data: function data() {\n    return {\n      defaultId: this.$formulate.nextId(this),\n      localAttributes: {},\n      localErrors: [],\n      localGroupErrors: {},\n      proxy: this.getInitialValue(),\n      behavioralErrorVisibility: \"live\" === this.errorBehavior,\n      formShouldShowErrors: !1,\n      validationErrors: [],\n      pendingValidation: Promise.resolve(),\n      ruleRegistry: [],\n      messageRegistry: {},\n      touched: !1,\n      debounceDelay: this.debounce,\n      dSet: function dSet(e, r, o) {\n        var i = this;\n        t && clearTimeout(t), t = setTimeout(function () {\n          return e.call.apply(e, [i].concat(r));\n        }, o);\n      },\n      mntd: !1\n    };\n    var t;\n  },\n  computed: Object.assign({}, H, {\n    classification: function classification() {\n      var t = this.$formulate.classify(this.type);\n      return \"box\" === t && this.options ? \"group\" : t;\n    },\n    component: function component() {\n      return \"group\" === this.classification ? \"FormulateInputGroup\" : this.$formulate.component(this.type);\n    },\n    parsedValidationRules: function parsedValidationRules() {\n      var t = this,\n          e = {};\n      return Object.keys(this.validationRules).forEach(function (r) {\n        e[l(r)] = t.validationRules[r];\n      }), e;\n    },\n    parsedValidation: function parsedValidation() {\n      return d(this.validation, this.$formulate.rules(this.parsedValidationRules));\n    },\n    messages: function messages() {\n      var t = this,\n          e = {};\n      return Object.keys(this.validationMessages).forEach(function (r) {\n        e[l(r)] = t.validationMessages[r];\n      }), Object.keys(this.messageRegistry).forEach(function (r) {\n        e[l(r)] = t.messageRegistry[r];\n      }), e;\n    }\n  }),\n  watch: {\n    $attrs: {\n      handler: function handler(t) {\n        this.updateLocalAttributes(t);\n      },\n      deep: !0\n    },\n    proxy: {\n      handler: function handler(t, e) {\n        this.performValidation(), this.isVmodeled || a(t, e, \"group\" === this.type) || (this.context.model = t), this.validateDependents(this), !this.touched && t && (this.touched = !0);\n      },\n      deep: !0\n    },\n    formulateValue: {\n      handler: function handler(t, e) {\n        this.isVmodeled && !a(t, e, \"group\" === this.type) && (this.context.model = t);\n      },\n      deep: !0\n    },\n    showValidationErrors: {\n      handler: function handler(t) {\n        this.$emit(\"error-visibility\", t);\n      },\n      immediate: !0\n    },\n    validation: {\n      handler: function handler() {\n        this.performValidation();\n      },\n      deep: !0\n    },\n    touched: function touched(t) {\n      \"value\" === this.errorBehavior && t && (this.behavioralErrorVisibility = t);\n    },\n    debounce: function debounce(t) {\n      this.debounceDelay = t;\n    }\n  },\n  created: function created() {\n    this.applyInitialValue(), this.formulateRegister && \"function\" == typeof this.formulateRegister && this.formulateRegister(this.nameOrFallback, this), this.applyDefaultValue(), this.disableErrors || \"function\" != typeof this.observeErrors || (this.observeErrors({\n      callback: this.setErrors,\n      type: \"input\",\n      field: this.nameOrFallback\n    }), \"group\" === this.type && this.observeErrors({\n      callback: this.setGroupErrors,\n      type: \"group\",\n      field: this.nameOrFallback\n    })), this.updateLocalAttributes(this.$attrs), this.performValidation(), this.hasValue && (this.touched = !0);\n  },\n  mounted: function mounted() {\n    this.mntd = !0;\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.disableErrors || \"function\" != typeof this.removeErrorObserver || (this.removeErrorObserver(this.setErrors), \"group\" === this.type && this.removeErrorObserver(this.setGroupErrors)), \"function\" != typeof this.formulateDeregister || this.preventDeregister || this.formulateDeregister(this.nameOrFallback);\n  },\n  methods: {\n    getInitialValue: function getInitialValue() {\n      var t = this.$formulate.classify(this.type);\n      return \"box\" === (t = \"box\" === t && this.options ? \"group\" : t) && this.checked ? this.value || !0 : f(this.$options.propsData, \"value\") && \"box\" !== t ? this.value : f(this.$options.propsData, \"formulateValue\") ? this.formulateValue : \"group\" === t ? Object.defineProperty(\"group\" === this.type ? [{}] : [], \"__init\", {\n        value: !0\n      }) : \"\";\n    },\n    applyInitialValue: function applyInitialValue() {\n      a(this.context.model, this.proxy) || \"box\" === this.classification && !f(this.$options.propsData, \"options\") || (this.context.model = this.proxy, this.$emit(\"input\", this.proxy));\n    },\n    applyDefaultValue: function applyDefaultValue() {\n      \"select\" === this.type && !this.context.placeholder && v(this.proxy) && !this.isVmodeled && !1 === this.value && this.context.options.length && (f(this.$attrs, \"multiple\") ? this.context.model = [] : this.context.model = this.context.options[0].value);\n    },\n    updateLocalAttributes: function updateLocalAttributes(t) {\n      a(t, this.localAttributes) || (this.localAttributes = t);\n    },\n    performValidation: function performValidation() {\n      var t = this,\n          e = d(this.validation, this.$formulate.rules(this.parsedValidationRules));\n      return e = this.ruleRegistry.length ? this.ruleRegistry.concat(e) : e, this.pendingValidation = this.runRules(e).then(function (e) {\n        return t.didValidate(e);\n      }), this.pendingValidation;\n    },\n    runRules: function runRules(t) {\n      var e = this,\n          r = function r(t) {\n        var r = t[0],\n            o = t[1],\n            i = t[2],\n            n = (t[3], r.apply(void 0, [{\n          value: e.context.model,\n          getFormValues: function getFormValues() {\n            for (var t, r = [], o = arguments.length; o--;) {\n              r[o] = arguments[o];\n            }\n\n            return (t = e).getFormValues.apply(t, [e].concat(r));\n          },\n          getGroupValues: function getGroupValues() {\n            for (var t, r = [], o = arguments.length; o--;) {\n              r[o] = arguments[o];\n            }\n\n            return (t = e)[\"get\" + (e.getGroupValues ? \"Group\" : \"Form\") + \"Values\"].apply(t, [e].concat(r));\n          },\n          name: e.context.name\n        }].concat(o)));\n        return (n = n instanceof Promise ? n : Promise.resolve(n)).then(function (t) {\n          return !t && e.getMessage(i, o);\n        });\n      };\n\n      return new Promise(function (e) {\n        var o = function o(t, i) {\n          void 0 === i && (i = []);\n          var n = t.shift();\n          Array.isArray(n) && n.length ? Promise.all(n.map(r)).then(function (t) {\n            return t.filter(function (t) {\n              return !!t;\n            });\n          }).then(function (r) {\n            return (r = Array.isArray(r) ? r : []).length && n.bail || !t.length ? e(i.concat(r).filter(function (t) {\n              return !v(t);\n            })) : o(t, i.concat(r));\n          }) : e([]);\n        };\n\n        o(function (t) {\n          var e = [],\n              r = t.findIndex(function (t) {\n            return \"bail\" === t[2].toLowerCase();\n          }),\n              o = t.findIndex(function (t) {\n            return \"optional\" === t[2].toLowerCase();\n          });\n\n          if (o >= 0) {\n            var i = t.splice(o, 1);\n            e.push(Object.defineProperty(i, \"bail\", {\n              value: !0\n            }));\n          }\n\n          if (r >= 0) {\n            var n = t.splice(0, r + 1).slice(0, -1);\n            n.length && e.push(n), t.map(function (t) {\n              return e.push(Object.defineProperty([t], \"bail\", {\n                value: !0\n              }));\n            });\n          } else e.push(t);\n\n          return e.reduce(function (t, e) {\n            var r = function r(t, e) {\n              if (void 0 === e && (e = !1), t.length < 2) return Object.defineProperty([t], \"bail\", {\n                value: e\n              });\n              var o = [],\n                  i = t.findIndex(function (t) {\n                return \"^\" === t[3];\n              });\n\n              if (i >= 0) {\n                var n = t.splice(0, i);\n                n.length && o.push.apply(o, r(n, e)), o.push(Object.defineProperty([t.shift()], \"bail\", {\n                  value: !0\n                })), t.length && o.push.apply(o, r(t, e));\n              } else o.push(t);\n\n              return o;\n            };\n\n            return t.concat(r(e));\n          }, []);\n        }(t));\n      });\n    },\n    didValidate: function didValidate(t) {\n      var e = !a(t, this.validationErrors);\n\n      if (this.validationErrors = t, e) {\n        var r = this.getErrorObject();\n        this.$emit(\"validation\", r), this.formulateFieldValidation && \"function\" == typeof this.formulateFieldValidation && this.formulateFieldValidation(r);\n      }\n    },\n    getMessage: function getMessage(t, e) {\n      var r = this;\n      return this.getMessageFunc(t)({\n        args: e,\n        name: this.mergedValidationName,\n        value: this.context.model,\n        vm: this,\n        formValues: this.getFormValues(this),\n        getFormValues: function getFormValues() {\n          for (var t, e = [], o = arguments.length; o--;) {\n            e[o] = arguments[o];\n          }\n\n          return (t = r).getFormValues.apply(t, [r].concat(e));\n        },\n        getGroupValues: function getGroupValues() {\n          for (var t, e = [], o = arguments.length; o--;) {\n            e[o] = arguments[o];\n          }\n\n          return (t = r)[\"get\" + (r.getGroupValues ? \"Group\" : \"Form\") + \"Values\"].apply(t, [r].concat(e));\n        }\n      });\n    },\n    getMessageFunc: function getMessageFunc(t) {\n      var e = this;\n      if (\"optional\" === (t = l(t))) return function () {\n        return [];\n      };\n      if (this.messages && void 0 !== this.messages[t]) switch (_typeof(this.messages[t])) {\n        case \"function\":\n          return this.messages[t];\n\n        case \"string\":\n        case \"boolean\":\n          return function () {\n            return e.messages[t];\n          };\n      }\n      return function (r) {\n        return e.$formulate.validationMessage(t, r, e);\n      };\n    },\n    hasValidationErrors: function hasValidationErrors() {\n      var t = this;\n      return new Promise(function (e) {\n        t.$nextTick(function () {\n          t.pendingValidation.then(function () {\n            return e(!!t.validationErrors.length);\n          });\n        });\n      });\n    },\n    getValidationErrors: function getValidationErrors() {\n      var t = this;\n      return new Promise(function (e) {\n        t.$nextTick(function () {\n          return t.pendingValidation.then(function () {\n            return e(t.getErrorObject());\n          });\n        });\n      });\n    },\n    getErrorObject: function getErrorObject() {\n      return {\n        name: this.context.nameOrFallback || this.context.name,\n        errors: this.validationErrors.filter(function (t) {\n          return \"string\" == typeof t;\n        }),\n        hasErrors: !!this.validationErrors.length\n      };\n    },\n    setErrors: function setErrors(t) {\n      this.localErrors = c(t);\n    },\n    setGroupErrors: function setGroupErrors(t) {\n      this.localGroupErrors = t;\n    },\n    registerRule: function registerRule(t, e, r, o) {\n      void 0 === o && (o = null), this.ruleRegistry.some(function (t) {\n        return t[2] === r;\n      }) || (this.ruleRegistry.push([t, e, r]), null !== o && (this.messageRegistry[r] = o));\n    },\n    removeRule: function removeRule(t) {\n      var e = this.ruleRegistry.findIndex(function (e) {\n        return e[2] === t;\n      });\n      e >= 0 && (this.ruleRegistry.splice(e, 1), delete this.messageRegistry[t]);\n    }\n  }\n},\n    Q = function Q() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.outer,\n    attrs: {\n      \"data-classification\": t.classification,\n      \"data-has-errors\": t.hasErrors,\n      \"data-is-showing-errors\": t.hasVisibleErrors,\n      \"data-has-value\": t.hasValue,\n      \"data-type\": t.type\n    }\n  }, [r(\"div\", {\n    class: t.context.classes.wrapper\n  }, [\"before\" === t.context.labelPosition ? t._t(\"label\", [t.context.hasLabel ? r(t.context.slotComponents.label, t._b({\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }, \"component\", t.context.slotProps.label, !1)) : t._e()], null, t.context) : t._e(), t._v(\" \"), \"before\" === t.context.helpPosition ? t._t(\"help\", [t.context.help ? r(t.context.slotComponents.help, t._b({\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }, \"component\", t.context.slotProps.help, !1)) : t._e()], null, t.context) : t._e(), t._v(\" \"), t._t(\"element\", [r(t.context.component, t._g(t._b({\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }, \"component\", t.context.slotProps.component, !1), t.listeners), [t._t(\"default\", null, null, t.context)], 2)], null, t.context), t._v(\" \"), \"after\" === t.context.labelPosition ? t._t(\"label\", [t.context.hasLabel ? r(t.context.slotComponents.label, t._b({\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }, \"component\", t.context.slotProps.label, !1)) : t._e()], null, t.context) : t._e()], 2), t._v(\" \"), \"after\" === t.context.helpPosition ? t._t(\"help\", [t.context.help ? r(t.context.slotComponents.help, t._b({\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }, \"component\", t.context.slotProps.help, !1)) : t._e()], null, t.context) : t._e(), t._v(\" \"), t._t(\"errors\", [t.context.disableErrors ? t._e() : r(t.context.slotComponents.errors, t._b({\n    tag: \"component\",\n    attrs: {\n      type: \"FormulateErrors\" === t.context.slotComponents.errors && \"input\",\n      context: t.context\n    }\n  }, \"component\", t.context.slotProps.errors, !1))], null, t.context)], 2);\n};\n\nQ._withStripped = !0;\n\nvar tt = U({\n  render: Q,\n  staticRenderFns: []\n}, void 0, X, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    et = {\n  inject: {\n    observeErrors: {\n      default: !1\n    },\n    removeErrorObserver: {\n      default: !1\n    },\n    observeContext: {\n      default: !1\n    },\n    removeContextObserver: {\n      default: !1\n    }\n  },\n  props: {\n    context: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    type: {\n      type: String,\n      default: \"form\"\n    }\n  },\n  data: function data() {\n    return {\n      boundSetErrors: this.setErrors.bind(this),\n      boundSetFormContext: this.setFormContext.bind(this),\n      localErrors: [],\n      formContext: {\n        classes: {\n          formErrors: \"formulate-form-errors\",\n          formError: \"formulate-form-error\"\n        }\n      }\n    };\n  },\n  computed: {\n    visibleValidationErrors: function visibleValidationErrors() {\n      return Array.isArray(this.context.visibleValidationErrors) ? this.context.visibleValidationErrors : [];\n    },\n    errors: function errors() {\n      return Array.isArray(this.context.errors) ? this.context.errors : [];\n    },\n    mergedErrors: function mergedErrors() {\n      return this.errors.concat(this.localErrors);\n    },\n    visibleErrors: function visibleErrors() {\n      return Array.from(new Set(this.mergedErrors.concat(this.visibleValidationErrors))).filter(function (t) {\n        return \"string\" == typeof t;\n      });\n    },\n    outerClass: function outerClass() {\n      return \"input\" === this.type && this.context.classes ? this.context.classes.errors : this.formContext.classes.formErrors;\n    },\n    itemClass: function itemClass() {\n      return \"input\" === this.type && this.context.classes ? this.context.classes.error : this.formContext.classes.formError;\n    },\n    role: function role() {\n      return \"form\" === this.type ? \"alert\" : \"status\";\n    },\n    ariaLive: function ariaLive() {\n      return \"form\" === this.type ? \"assertive\" : \"polite\";\n    },\n    slotComponent: function slotComponent() {\n      return this.$formulate.slotComponent(null, \"errorList\");\n    }\n  },\n  created: function created() {\n    \"form\" === this.type && \"function\" == typeof this.observeErrors && (Array.isArray(this.context.errors) || this.observeErrors({\n      callback: this.boundSetErrors,\n      type: \"form\"\n    }), this.observeContext(this.boundSetFormContext));\n  },\n  destroyed: function destroyed() {\n    \"form\" === this.type && \"function\" == typeof this.removeErrorObserver && (Array.isArray(this.context.errors) || this.removeErrorObserver(this.boundSetErrors), this.removeContextObserver(this.boundSetFormContext));\n  },\n  methods: {\n    setErrors: function setErrors(t) {\n      this.localErrors = c(t);\n    },\n    setFormContext: function setFormContext(t) {\n      this.formContext = t;\n    }\n  }\n},\n    rt = function rt() {\n  var t = this.$createElement;\n  return (this._self._c || t)(this.slotComponent, {\n    tag: \"component\",\n    attrs: {\n      \"visible-errors\": this.visibleErrors,\n      \"item-class\": this.itemClass,\n      \"outer-class\": this.outerClass,\n      role: this.role,\n      \"aria-live\": this.ariaLive,\n      type: this.type\n    }\n  });\n};\n\nrt._withStripped = !0;\n\nvar ot = U({\n  render: rt,\n  staticRenderFns: []\n}, void 0, et, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    it = {\n  props: {\n    context: {\n      type: Object,\n      required: !0\n    }\n  }\n},\n    nt = function nt() {\n  var t = this.$createElement,\n      e = this._self._c || t;\n  return this.context.help ? e(\"div\", {\n    class: this.context.classes.help,\n    attrs: {\n      id: this.context.id + \"-help\"\n    },\n    domProps: {\n      textContent: this._s(this.context.help)\n    }\n  }) : this._e();\n};\n\nnt._withStripped = !0;\n\nvar st = U({\n  render: nt,\n  staticRenderFns: []\n}, void 0, it, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    at = {\n  props: {\n    file: {\n      type: Object,\n      required: !0\n    },\n    imagePreview: {\n      type: Boolean,\n      default: !1\n    },\n    context: {\n      type: Object,\n      required: !0\n    }\n  }\n},\n    lt = function lt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.file\n  }, [t.imagePreview && t.file.previewData ? r(\"div\", {\n    class: t.context.classes.fileImagePreview\n  }, [r(\"img\", {\n    class: t.context.classes.fileImagePreviewImage,\n    attrs: {\n      src: t.file.previewData\n    }\n  })]) : t._e(), t._v(\" \"), r(\"div\", {\n    class: t.context.classes.fileName,\n    attrs: {\n      title: t.file.name\n    },\n    domProps: {\n      textContent: t._s(t.file.name)\n    }\n  }), t._v(\" \"), !1 !== t.file.progress ? r(\"div\", {\n    class: t.context.classes.fileProgress,\n    attrs: {\n      \"data-just-finished\": t.file.justFinished,\n      \"data-is-finished\": !t.file.justFinished && t.file.complete\n    }\n  }, [r(\"div\", {\n    class: t.context.classes.fileProgressInner,\n    style: {\n      width: t.file.progress + \"%\"\n    }\n  })]) : t._e(), t._v(\" \"), t.file.complete && !t.file.justFinished || !1 === t.file.progress ? r(\"div\", {\n    class: t.context.classes.fileRemove,\n    on: {\n      click: t.file.removeFile\n    }\n  }) : t._e()]);\n};\n\nlt._withStripped = !0;\n\nvar ut = U({\n  render: lt,\n  staticRenderFns: []\n}, void 0, at, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    ct = {\n  name: \"FormulateGrouping\",\n  props: {\n    context: {\n      type: Object,\n      required: !0\n    }\n  },\n  provide: function provide() {\n    return {\n      isSubField: function isSubField() {\n        return !0;\n      },\n      registerProvider: this.registerProvider,\n      deregisterProvider: this.deregisterProvider\n    };\n  },\n  data: function data() {\n    return {\n      providers: [],\n      keys: []\n    };\n  },\n  inject: [\"formulateRegisterRule\", \"formulateRemoveRule\"],\n  computed: {\n    items: function items() {\n      var t = this;\n      return Array.isArray(this.context.model) ? this.context.repeatable || 0 !== this.context.model.length ? this.context.model.length < this.context.minimum ? new Array(this.context.minimum || 1).fill(\"\").map(function (e, r) {\n        return t.setId(t.context.model[r] || {}, r);\n      }) : this.context.model.map(function (e, r) {\n        return t.setId(e, r);\n      }) : [this.setId({}, 0)] : new Array(this.context.minimum || 1).fill(\"\").map(function (e, r) {\n        return t.setId({}, r);\n      });\n    },\n    formShouldShowErrors: function formShouldShowErrors() {\n      return this.context.formShouldShowErrors;\n    },\n    groupErrors: function groupErrors() {\n      var t = this;\n      return this.items.map(function (e, r) {\n        return f(t.context.groupErrors, r) ? t.context.groupErrors[r] : {};\n      });\n    }\n  },\n  watch: {\n    providers: function providers() {\n      this.formShouldShowErrors && this.showErrors();\n    },\n    formShouldShowErrors: function formShouldShowErrors(t) {\n      t && this.showErrors();\n    },\n    items: {\n      handler: function handler(t, e) {\n        a(t, e, !0) || (this.keys = t.map(function (t) {\n          return t.__id;\n        }));\n      },\n      immediate: !0\n    }\n  },\n  created: function created() {\n    this.formulateRegisterRule(this.validateGroup.bind(this), [], \"formulateGrouping\", !0);\n  },\n  destroyed: function destroyed() {\n    this.formulateRemoveRule(\"formulateGrouping\");\n  },\n  methods: {\n    validateGroup: function validateGroup() {\n      return Promise.all(this.providers.reduce(function (t, e) {\n        return e && \"function\" == typeof e.hasValidationErrors && t.push(e.hasValidationErrors()), t;\n      }, [])).then(function (t) {\n        return !t.some(function (t) {\n          return !!t;\n        });\n      });\n    },\n    showErrors: function showErrors() {\n      this.providers.forEach(function (t) {\n        return t && \"function\" == typeof t.showErrors && t.showErrors();\n      });\n    },\n    setItem: function setItem(t, e) {\n      var r = this;\n      Array.isArray(this.context.model) && this.context.model.length >= this.context.minimum && !this.context.model.__init ? this.context.model.splice(t, 1, this.setId(e, t)) : this.context.model = this.items.map(function (o, i) {\n        return i === t ? r.setId(e, t) : o;\n      });\n    },\n    removeItem: function removeItem(t) {\n      var e = this;\n      Array.isArray(this.context.model) && this.context.model.length > this.context.minimum ? (this.context.model = this.context.model.filter(function (e, r) {\n        return r !== t && e;\n      }), this.context.rootEmit(\"repeatableRemoved\", this.context.model)) : !Array.isArray(this.context.model) && this.items.length > this.context.minimum && (this.context.model = new Array(this.items.length - 1).fill(\"\").map(function (t, r) {\n        return e.setId({}, r);\n      }), this.context.rootEmit(\"repeatableRemoved\", this.context.model));\n    },\n    registerProvider: function registerProvider(t) {\n      this.providers.some(function (e) {\n        return e === t;\n      }) || this.providers.push(t);\n    },\n    deregisterProvider: function deregisterProvider(t) {\n      this.providers = this.providers.filter(function (e) {\n        return e !== t;\n      });\n    },\n    setId: function setId(t, e) {\n      return t.__id ? t : m(t, this.keys[e]);\n    }\n  }\n},\n    dt = function dt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"FormulateSlot\", {\n    class: t.context.classes.grouping,\n    attrs: {\n      name: \"grouping\",\n      context: t.context,\n      \"force-wrap\": t.context.repeatable\n    }\n  }, t._l(t.items, function (e, o) {\n    return r(\"FormulateRepeatableProvider\", {\n      key: e.__id,\n      attrs: {\n        index: o,\n        context: t.context,\n        uuid: e.__id,\n        errors: t.groupErrors[o]\n      },\n      on: {\n        remove: t.removeItem,\n        input: function input(e) {\n          return t.setItem(o, e);\n        }\n      }\n    }, [t._t(\"default\")], 2);\n  }), 1);\n};\n\ndt._withStripped = !0;\n\nvar pt = U({\n  render: dt,\n  staticRenderFns: []\n}, void 0, ct, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    ht = {\n  props: {\n    context: {\n      type: Object,\n      required: !0\n    }\n  }\n},\n    ft = function ft() {\n  var t = this.$createElement;\n  return (this._self._c || t)(\"label\", {\n    class: this.context.classes.label,\n    attrs: {\n      id: this.context.id + \"_label\",\n      for: this.context.id\n    },\n    domProps: {\n      textContent: this._s(this.context.label)\n    }\n  });\n};\n\nft._withStripped = !0;\n\nvar mt = U({\n  render: ft,\n  staticRenderFns: []\n}, void 0, ht, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    vt = {\n  props: {\n    context: {\n      type: Object,\n      required: !0\n    },\n    addMore: {\n      type: Function,\n      required: !0\n    }\n  }\n},\n    xt = function xt() {\n  var t = this.$createElement,\n      e = this._self._c || t;\n  return e(\"div\", {\n    class: this.context.classes.groupAddMore\n  }, [e(\"FormulateInput\", {\n    attrs: {\n      type: \"button\",\n      label: this.context.addLabel,\n      \"data-minor\": \"\",\n      \"data-ghost\": \"\"\n    },\n    on: {\n      click: this.addMore\n    }\n  })], 1);\n};\n\nxt._withStripped = !0;\n\nvar yt = U({\n  render: xt,\n  staticRenderFns: []\n}, void 0, vt, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    gt = {\n  props: {\n    context: {\n      type: Object,\n      required: !0\n    }\n  },\n  computed: {\n    type: function type() {\n      return this.context.type;\n    },\n    attributes: function attributes() {\n      return this.context.attributes || {};\n    },\n    hasValue: function hasValue() {\n      return this.context.hasValue;\n    }\n  }\n},\n    bt = {\n  name: \"FormulateInputBox\",\n  mixins: [gt],\n  computed: {\n    usesDecorator: function usesDecorator() {\n      return this.$formulate.options.useInputDecorators;\n    }\n  }\n},\n    Et = function Et() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.element,\n    attrs: {\n      \"data-type\": t.context.type\n    }\n  }, [r(\"FormulateSlot\", {\n    attrs: {\n      name: \"prefix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.prefix ? r(t.context.slotComponents.prefix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), \"radio\" === t.type ? r(\"input\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      type: \"radio\"\n    },\n    domProps: {\n      value: t.context.value,\n      checked: t._q(t.context.model, t.context.value)\n    },\n    on: {\n      blur: t.context.blurHandler,\n      change: function change(e) {\n        return t.$set(t.context, \"model\", t.context.value);\n      }\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)) : r(\"input\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      type: \"checkbox\"\n    },\n    domProps: {\n      value: t.context.value,\n      checked: Array.isArray(t.context.model) ? t._i(t.context.model, t.context.value) > -1 : t.context.model\n    },\n    on: {\n      blur: t.context.blurHandler,\n      change: function change(e) {\n        var r = t.context.model,\n            o = e.target,\n            i = !!o.checked;\n\n        if (Array.isArray(r)) {\n          var n = t.context.value,\n              s = t._i(r, n);\n\n          o.checked ? s < 0 && t.$set(t.context, \"model\", r.concat([n])) : s > -1 && t.$set(t.context, \"model\", r.slice(0, s).concat(r.slice(s + 1)));\n        } else t.$set(t.context, \"model\", i);\n      }\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)), t._v(\" \"), t.usesDecorator ? r(\"label\", {\n    tag: \"component\",\n    class: t.context.classes.decorator,\n    attrs: {\n      for: t.attributes.id\n    }\n  }) : t._e(), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"suffix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.suffix ? r(t.context.slotComponents.suffix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1)], 1);\n};\n\nEt._withStripped = !0;\n\nvar _t = U({\n  render: Et,\n  staticRenderFns: []\n}, void 0, bt, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    Ft = {\n  props: {\n    visibleErrors: {\n      type: Array,\n      required: !0\n    },\n    itemClass: {\n      type: [String, Array, Object, Boolean],\n      default: !1\n    },\n    outerClass: {\n      type: [String, Array, Object, Boolean],\n      default: !1\n    },\n    role: {\n      type: [String],\n      default: \"status\"\n    },\n    ariaLive: {\n      type: [String, Boolean],\n      default: \"polite\"\n    },\n    type: {\n      type: String,\n      required: !0\n    }\n  }\n},\n    wt = function wt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return t.visibleErrors.length ? r(\"ul\", {\n    class: t.outerClass\n  }, t._l(t.visibleErrors, function (e) {\n    return r(\"li\", {\n      key: e,\n      class: t.itemClass,\n      attrs: {\n        role: t.role,\n        \"aria-live\": t.ariaLive\n      },\n      domProps: {\n        textContent: t._s(e)\n      }\n    });\n  }), 0) : t._e();\n};\n\nwt._withStripped = !0;\n\nvar Ot = U({\n  render: wt,\n  staticRenderFns: []\n}, void 0, Ft, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    Pt = {\n  name: \"FormulateInputText\",\n  mixins: [gt]\n},\n    Vt = function Vt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.element,\n    attrs: {\n      \"data-type\": t.context.type\n    }\n  }, [r(\"FormulateSlot\", {\n    attrs: {\n      name: \"prefix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.prefix ? r(t.context.slotComponents.prefix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), \"checkbox\" === t.type ? r(\"input\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      type: \"checkbox\"\n    },\n    domProps: {\n      checked: Array.isArray(t.context.model) ? t._i(t.context.model, null) > -1 : t.context.model\n    },\n    on: {\n      blur: t.context.blurHandler,\n      change: function change(e) {\n        var r = t.context.model,\n            o = e.target,\n            i = !!o.checked;\n\n        if (Array.isArray(r)) {\n          var n = t._i(r, null);\n\n          o.checked ? n < 0 && t.$set(t.context, \"model\", r.concat([null])) : n > -1 && t.$set(t.context, \"model\", r.slice(0, n).concat(r.slice(n + 1)));\n        } else t.$set(t.context, \"model\", i);\n      }\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)) : \"radio\" === t.type ? r(\"input\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      type: \"radio\"\n    },\n    domProps: {\n      checked: t._q(t.context.model, null)\n    },\n    on: {\n      blur: t.context.blurHandler,\n      change: function change(e) {\n        return t.$set(t.context, \"model\", null);\n      }\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)) : r(\"input\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      type: t.type\n    },\n    domProps: {\n      value: t.context.model\n    },\n    on: {\n      blur: t.context.blurHandler,\n      input: function input(e) {\n        e.target.composing || t.$set(t.context, \"model\", e.target.value);\n      }\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"suffix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.suffix ? r(t.context.slotComponents.suffix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1)], 1);\n};\n\nVt._withStripped = !0;\n\nvar At = U({\n  render: Vt,\n  staticRenderFns: []\n}, void 0, Pt, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    St = {\n  name: \"FormulateFiles\",\n  props: {\n    files: {\n      type: y,\n      required: !0\n    },\n    imagePreview: {\n      type: Boolean,\n      default: !1\n    },\n    context: {\n      type: Object,\n      required: !0\n    }\n  },\n  computed: {\n    fileUploads: function fileUploads() {\n      return this.files.files || [];\n    },\n    isMultiple: function isMultiple() {\n      return f(this.context.attributes, \"multiple\");\n    }\n  },\n  watch: {\n    files: function files() {\n      this.imagePreview && this.files.loadPreviews();\n    }\n  },\n  mounted: function mounted() {\n    this.imagePreview && this.files.loadPreviews();\n  },\n  methods: {\n    appendFiles: function appendFiles() {\n      var t = this.$refs.addFiles;\n      t.files.length && this.files.mergeFileList(t);\n    }\n  }\n},\n    jt = function jt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return t.fileUploads.length ? r(\"ul\", {\n    class: t.context.classes.files\n  }, [t._l(t.fileUploads, function (e) {\n    return r(\"li\", {\n      key: e.uuid,\n      attrs: {\n        \"data-has-error\": !!e.error,\n        \"data-has-preview\": !(!t.imagePreview || !e.previewData)\n      }\n    }, [r(\"FormulateSlot\", {\n      attrs: {\n        name: \"file\",\n        context: t.context,\n        file: e,\n        \"image-preview\": t.imagePreview\n      }\n    }, [r(t.context.slotComponents.file, {\n      tag: \"component\",\n      attrs: {\n        context: t.context,\n        file: e,\n        \"image-preview\": t.imagePreview\n      }\n    })], 1), t._v(\" \"), e.error ? r(\"div\", {\n      class: t.context.classes.fileUploadError,\n      domProps: {\n        textContent: t._s(e.error)\n      }\n    }) : t._e()], 1);\n  }), t._v(\" \"), t.isMultiple && t.context.addLabel ? r(\"div\", {\n    class: t.context.classes.fileAdd,\n    attrs: {\n      role: \"button\"\n    }\n  }, [t._v(\"\\n    \" + t._s(t.context.addLabel) + \"\\n    \"), r(\"input\", {\n    ref: \"addFiles\",\n    class: t.context.classes.fileAddInput,\n    attrs: {\n      type: \"file\",\n      multiple: \"\"\n    },\n    on: {\n      change: t.appendFiles\n    }\n  })]) : t._e()], 2) : t._e();\n};\n\njt._withStripped = !0;\n\nvar $t = {\n  name: \"FormulateInputFile\",\n  components: {\n    FormulateFiles: U({\n      render: jt,\n      staticRenderFns: []\n    }, void 0, St, void 0, !1, void 0, !1, void 0, void 0, void 0)\n  },\n  mixins: [gt],\n  data: function data() {\n    return {\n      isOver: !1\n    };\n  },\n  computed: {\n    hasFiles: function hasFiles() {\n      return !!(this.context.model instanceof y && this.context.model.files.length);\n    }\n  },\n  created: function created() {\n    Array.isArray(this.context.model) && \"string\" == typeof this.context.model[0][this.$formulate.getFileUrlKey()] && (this.context.model = this.$formulate.createUpload({\n      files: this.context.model\n    }, this.context));\n  },\n  mounted: function mounted() {\n    window && this.context.preventWindowDrops && (window.addEventListener(\"dragover\", this.preventDefault), window.addEventListener(\"drop\", this.preventDefault));\n  },\n  destroyed: function destroyed() {\n    window && this.context.preventWindowDrops && (window.removeEventListener(\"dragover\", this.preventDefault), window.removeEventListener(\"drop\", this.preventDefault));\n  },\n  methods: {\n    preventDefault: function preventDefault(t) {\n      \"INPUT\" !== t.target.tagName && \"file\" !== t.target.getAttribute(\"type\") && (t = t || event).preventDefault();\n    },\n    handleFile: function handleFile() {\n      var t = this;\n      this.isOver = !1;\n      var e = this.$refs.file;\n      e.files.length && (this.context.model = this.$formulate.createUpload(e, this.context), this.$nextTick(function () {\n        return t.attemptImmediateUpload();\n      }));\n    },\n    attemptImmediateUpload: function attemptImmediateUpload() {\n      var t = this;\n      \"live\" === this.context.uploadBehavior && this.context.model instanceof y && this.context.hasValidationErrors().then(function (e) {\n        e || t.context.model.upload();\n      });\n    },\n    handleDragOver: function handleDragOver(t) {\n      t.preventDefault(), this.isOver = !0;\n    },\n    handleDragLeave: function handleDragLeave(t) {\n      t.preventDefault(), this.isOver = !1;\n    }\n  }\n},\n    Ct = function Ct() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.element,\n    attrs: {\n      \"data-type\": t.context.type,\n      \"data-has-files\": t.hasFiles\n    }\n  }, [r(\"FormulateSlot\", {\n    attrs: {\n      name: \"prefix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.prefix ? r(t.context.slotComponents.prefix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), r(\"div\", {\n    class: t.context.classes.uploadArea,\n    attrs: {\n      \"data-has-files\": t.hasFiles\n    }\n  }, [r(\"input\", t._g(t._b({\n    ref: \"file\",\n    attrs: {\n      \"data-is-drag-hover\": t.isOver,\n      type: \"file\"\n    },\n    on: {\n      blur: t.context.blurHandler,\n      change: t.handleFile,\n      dragover: t.handleDragOver,\n      dragleave: t.handleDragLeave\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"uploadAreaMask\",\n      context: t.context,\n      \"has-files\": t.hasFiles\n    }\n  }, [r(t.context.slotComponents.uploadAreaMask, {\n    directives: [{\n      name: \"show\",\n      rawName: \"v-show\",\n      value: !t.hasFiles,\n      expression: \"!hasFiles\"\n    }],\n    tag: \"component\",\n    class: t.context.classes.uploadAreaMask,\n    attrs: {\n      \"has-files\": \"div\" !== t.context.slotComponents.uploadAreaMask && t.hasFiles,\n      \"data-has-files\": \"div\" === t.context.slotComponents.uploadAreaMask && t.hasFiles\n    }\n  })], 1), t._v(\" \"), t.hasFiles ? r(\"FormulateFiles\", {\n    attrs: {\n      files: t.context.model,\n      \"image-preview\": \"image\" === t.context.type && \"preview\" === t.context.imageBehavior,\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"suffix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.suffix ? r(t.context.slotComponents.suffix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1)], 1);\n};\n\nCt._withStripped = !0;\n\nvar kt = U({\n  render: Ct,\n  staticRenderFns: []\n}, void 0, $t, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    It = {\n  props: {\n    context: {\n      type: Object,\n      required: !0\n    },\n    removeItem: {\n      type: Function,\n      required: !0\n    },\n    index: {\n      type: Number,\n      required: !0\n    }\n  }\n},\n    Rt = function Rt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.groupRepeatable\n  }, [\"after\" === t.context.removePosition ? t._t(\"default\") : t._e(), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"remove\",\n      context: t.context,\n      index: t.index,\n      \"remove-item\": t.removeItem\n    }\n  }, [r(t.context.slotComponents.remove, t._b({\n    tag: \"component\",\n    attrs: {\n      context: t.context,\n      index: t.index,\n      \"remove-item\": t.removeItem\n    }\n  }, \"component\", t.context.slotProps.remove, !1))], 1), t._v(\" \"), \"before\" === t.context.removePosition ? t._t(\"default\") : t._e()], 2);\n};\n\nRt._withStripped = !0;\nvar Dt = U({\n  render: Rt,\n  staticRenderFns: []\n}, void 0, It, void 0, !1, void 0, !1, void 0, void 0, void 0);\n\nfunction Lt(t, e) {\n  var r = {};\n\n  for (var o in t) {\n    Object.prototype.hasOwnProperty.call(t, o) && -1 === e.indexOf(o) && (r[o] = t[o]);\n  }\n\n  return r;\n}\n\nvar Nt = {\n  name: \"FormulateInputGroup\",\n  props: {\n    context: {\n      type: Object,\n      required: !0\n    }\n  },\n  computed: {\n    options: function options() {\n      return this.context.options || [];\n    },\n    subType: function subType() {\n      return \"group\" === this.context.type ? \"grouping\" : \"inputs\";\n    },\n    optionsWithContext: function optionsWithContext() {\n      var t = this,\n          e = this.context,\n          r = e.attributes,\n          o = (r.id, Lt(r, [\"id\"])),\n          i = (e.blurHandler, e.classification, e.component, e.getValidationErrors, e.hasLabel, e.hasValidationErrors, e.isSubField, e.isValid, e.labelPosition, e.options, e.performValidation, e.setErrors, e.slotComponents, e.slotProps, e.validationErrors, e.visibleValidationErrors, e.classes, e.showValidationErrors, e.rootEmit, e.help, e.pseudoProps, e.rules, e.model, Lt(e, [\"attributes\", \"blurHandler\", \"classification\", \"component\", \"getValidationErrors\", \"hasLabel\", \"hasValidationErrors\", \"isSubField\", \"isValid\", \"labelPosition\", \"options\", \"performValidation\", \"setErrors\", \"slotComponents\", \"slotProps\", \"validationErrors\", \"visibleValidationErrors\", \"classes\", \"showValidationErrors\", \"rootEmit\", \"help\", \"pseudoProps\", \"rules\", \"model\"]));\n      return this.options.map(function (e) {\n        return t.groupItemContext(i, e, o);\n      });\n    },\n    totalItems: function totalItems() {\n      return Array.isArray(this.context.model) && this.context.model.length > this.context.minimum ? this.context.model.length : this.context.minimum || 1;\n    },\n    canAddMore: function canAddMore() {\n      return this.context.repeatable && this.totalItems < this.context.limit;\n    },\n    labelledBy: function labelledBy() {\n      return this.context.label && this.context.id + \"_label\";\n    }\n  },\n  methods: {\n    addItem: function addItem() {\n      if (Array.isArray(this.context.model)) for (var t = this.context.minimum - this.context.model.length + 1, e = Math.max(t, 1), r = 0; r < e; r++) {\n        this.context.model.push(m({}));\n      } else this.context.model = new Array(this.totalItems + 1).fill(\"\").map(function () {\n        return m({});\n      });\n      this.context.rootEmit(\"repeatableAdded\", this.context.model);\n    },\n    groupItemContext: function groupItemContext(t, e, r) {\n      return Object.assign({}, t, e, r, {\n        isGrouped: !0\n      }, t.hasGivenName ? {} : {\n        name: !0\n      });\n    }\n  }\n},\n    Bt = function Bt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.element,\n    attrs: {\n      \"data-is-repeatable\": t.context.repeatable,\n      role: \"group\",\n      \"aria-labelledby\": t.labelledBy\n    }\n  }, [r(\"FormulateSlot\", {\n    attrs: {\n      name: \"prefix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.prefix ? r(t.context.slotComponents.prefix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), \"grouping\" !== t.subType ? t._l(t.optionsWithContext, function (e) {\n    return r(\"FormulateInput\", t._b({\n      key: e.id,\n      staticClass: \"formulate-input-group-item\",\n      attrs: {\n        \"disable-errors\": !0,\n        \"prevent-deregister\": !0\n      },\n      on: {\n        blur: t.context.blurHandler\n      },\n      model: {\n        value: t.context.model,\n        callback: function callback(e) {\n          t.$set(t.context, \"model\", e);\n        },\n        expression: \"context.model\"\n      }\n    }, \"FormulateInput\", e, !1));\n  }) : [r(\"FormulateGrouping\", {\n    attrs: {\n      context: t.context\n    }\n  }, [t._t(\"default\")], 2), t._v(\" \"), t.canAddMore ? r(\"FormulateSlot\", {\n    attrs: {\n      name: \"addmore\",\n      context: t.context,\n      \"add-more\": t.addItem\n    }\n  }, [r(t.context.slotComponents.addMore, t._b({\n    tag: \"component\",\n    attrs: {\n      context: t.context,\n      \"add-more\": t.addItem\n    },\n    on: {\n      add: t.addItem\n    }\n  }, \"component\", t.context.slotProps.addMore, !1))], 1) : t._e()], t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"suffix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.suffix ? r(t.context.slotComponents.suffix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1)], 2);\n};\n\nBt._withStripped = !0;\n\nvar Mt = U({\n  render: Bt,\n  staticRenderFns: []\n}, void 0, Nt, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    Ut = {\n  name: \"FormulateInputButton\",\n  mixins: [gt]\n},\n    Gt = function Gt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.element,\n    attrs: {\n      \"data-type\": t.context.type\n    }\n  }, [r(\"FormulateSlot\", {\n    attrs: {\n      name: \"prefix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.prefix ? r(t.context.slotComponents.prefix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), r(\"button\", t._g(t._b({\n    attrs: {\n      type: t.type\n    }\n  }, \"button\", t.attributes, !1), t.$listeners), [t._t(\"default\", [r(t.context.slotComponents.buttonContent, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  })], {\n    context: t.context\n  })], 2), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"suffix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.suffix ? r(t.context.slotComponents.suffix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1)], 1);\n};\n\nGt._withStripped = !0;\n\nvar Tt = U({\n  render: Gt,\n  staticRenderFns: []\n}, void 0, Ut, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    qt = {\n  name: \"FormulateInputSelect\",\n  mixins: [gt],\n  computed: {\n    options: function options() {\n      return this.context.options || {};\n    },\n    optionGroups: function optionGroups() {\n      return this.context.optionGroups || !1;\n    },\n    placeholderSelected: function placeholderSelected() {\n      return !(this.hasValue || !this.context.attributes || !this.context.attributes.placeholder);\n    }\n  }\n},\n    Ht = function Ht() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.element,\n    attrs: {\n      \"data-type\": t.context.type,\n      \"data-multiple\": t.attributes && void 0 !== t.attributes.multiple\n    }\n  }, [r(\"FormulateSlot\", {\n    attrs: {\n      name: \"prefix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.prefix ? r(t.context.slotComponents.prefix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), r(\"select\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      \"data-placeholder-selected\": t.placeholderSelected\n    },\n    on: {\n      blur: t.context.blurHandler,\n      change: function change(e) {\n        var r = Array.prototype.filter.call(e.target.options, function (t) {\n          return t.selected;\n        }).map(function (t) {\n          return \"_value\" in t ? t._value : t.value;\n        });\n        t.$set(t.context, \"model\", e.target.multiple ? r : r[0]);\n      }\n    }\n  }, \"select\", t.attributes, !1), t.$listeners), [t.context.placeholder ? r(\"option\", {\n    attrs: {\n      value: \"\",\n      hidden: \"hidden\",\n      disabled: \"\"\n    },\n    domProps: {\n      selected: !t.hasValue\n    }\n  }, [t._v(\"\\n      \" + t._s(t.context.placeholder) + \"\\n    \")]) : t._e(), t._v(\" \"), t.optionGroups ? t._l(t.optionGroups, function (e, o) {\n    return r(\"optgroup\", {\n      key: o,\n      attrs: {\n        label: o\n      }\n    }, t._l(e, function (e) {\n      return r(\"option\", t._b({\n        key: e.id,\n        attrs: {\n          disabled: !!e.disabled\n        },\n        domProps: {\n          value: e.value,\n          textContent: t._s(e.label)\n        }\n      }, \"option\", e.attributes || e.attrs || {}, !1));\n    }), 0);\n  }) : t._l(t.options, function (e) {\n    return r(\"option\", t._b({\n      key: e.id,\n      attrs: {\n        disabled: !!e.disabled\n      },\n      domProps: {\n        value: e.value,\n        textContent: t._s(e.label)\n      }\n    }, \"option\", e.attributes || e.attrs || {}, !1));\n  })], 2), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"suffix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.suffix ? r(t.context.slotComponents.suffix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1)], 1);\n};\n\nHt._withStripped = !0;\n\nvar Wt = U({\n  render: Ht,\n  staticRenderFns: []\n}, void 0, qt, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    Yt = {\n  name: \"FormulateInputSlider\",\n  mixins: [gt]\n},\n    zt = function zt() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.element,\n    attrs: {\n      \"data-type\": t.context.type\n    }\n  }, [r(\"FormulateSlot\", {\n    attrs: {\n      name: \"prefix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.prefix ? r(t.context.slotComponents.prefix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), \"checkbox\" === t.type ? r(\"input\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      type: \"checkbox\"\n    },\n    domProps: {\n      checked: Array.isArray(t.context.model) ? t._i(t.context.model, null) > -1 : t.context.model\n    },\n    on: {\n      blur: t.context.blurHandler,\n      change: function change(e) {\n        var r = t.context.model,\n            o = e.target,\n            i = !!o.checked;\n\n        if (Array.isArray(r)) {\n          var n = t._i(r, null);\n\n          o.checked ? n < 0 && t.$set(t.context, \"model\", r.concat([null])) : n > -1 && t.$set(t.context, \"model\", r.slice(0, n).concat(r.slice(n + 1)));\n        } else t.$set(t.context, \"model\", i);\n      }\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)) : \"radio\" === t.type ? r(\"input\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      type: \"radio\"\n    },\n    domProps: {\n      checked: t._q(t.context.model, null)\n    },\n    on: {\n      blur: t.context.blurHandler,\n      change: function change(e) {\n        return t.$set(t.context, \"model\", null);\n      }\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)) : r(\"input\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    attrs: {\n      type: t.type\n    },\n    domProps: {\n      value: t.context.model\n    },\n    on: {\n      blur: t.context.blurHandler,\n      input: function input(e) {\n        e.target.composing || t.$set(t.context, \"model\", e.target.value);\n      }\n    }\n  }, \"input\", t.attributes, !1), t.$listeners)), t._v(\" \"), t.context.showValue ? r(\"div\", {\n    class: t.context.classes.rangeValue,\n    domProps: {\n      textContent: t._s(t.context.model)\n    }\n  }) : t._e(), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"suffix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.suffix ? r(t.context.slotComponents.suffix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1)], 1);\n};\n\nzt._withStripped = !0;\n\nvar Kt = U({\n  render: zt,\n  staticRenderFns: []\n}, void 0, Yt, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    Zt = {\n  props: {\n    context: {\n      type: Object,\n      required: !0\n    }\n  }\n},\n    Jt = function Jt() {\n  var t = this.$createElement;\n  return (this._self._c || t)(\"span\", {\n    class: \"formulate-input-element--\" + this.context.type + \"--label\",\n    domProps: {\n      textContent: this._s(this.context.value || this.context.label || this.context.name || \"Submit\")\n    }\n  });\n};\n\nJt._withStripped = !0;\n\nvar Xt = U({\n  render: Jt,\n  staticRenderFns: []\n}, void 0, Zt, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    Qt = {\n  name: \"FormulateInputTextArea\",\n  mixins: [gt]\n},\n    te = function te() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"div\", {\n    class: t.context.classes.element,\n    attrs: {\n      \"data-type\": \"textarea\"\n    }\n  }, [r(\"FormulateSlot\", {\n    attrs: {\n      name: \"prefix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.prefix ? r(t.context.slotComponents.prefix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1), t._v(\" \"), r(\"textarea\", t._g(t._b({\n    directives: [{\n      name: \"model\",\n      rawName: \"v-model\",\n      value: t.context.model,\n      expression: \"context.model\"\n    }],\n    domProps: {\n      value: t.context.model\n    },\n    on: {\n      blur: t.context.blurHandler,\n      input: function input(e) {\n        e.target.composing || t.$set(t.context, \"model\", e.target.value);\n      }\n    }\n  }, \"textarea\", t.attributes, !1), t.$listeners)), t._v(\" \"), r(\"FormulateSlot\", {\n    attrs: {\n      name: \"suffix\",\n      context: t.context\n    }\n  }, [t.context.slotComponents.suffix ? r(t.context.slotComponents.suffix, {\n    tag: \"component\",\n    attrs: {\n      context: t.context\n    }\n  }) : t._e()], 1)], 1);\n};\n\nte._withStripped = !0;\n\nvar ee = U({\n  render: te,\n  staticRenderFns: []\n}, void 0, Qt, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    re = {\n  provide: function provide() {\n    var t = this;\n    return Object.assign({}, B(this, [\"getFormValues\"]), {\n      formulateSetter: function formulateSetter(e, r) {\n        return t.setGroupValue(e, r);\n      }\n    });\n  },\n  inject: {\n    registerProvider: \"registerProvider\",\n    deregisterProvider: \"deregisterProvider\"\n  },\n  props: {\n    index: {\n      type: Number,\n      required: !0\n    },\n    context: {\n      type: Object,\n      required: !0\n    },\n    uuid: {\n      type: String,\n      required: !0\n    },\n    errors: {\n      type: Object,\n      required: !0\n    }\n  },\n  data: function data() {\n    return Object.assign({}, D(this), {\n      isGrouping: !0\n    });\n  },\n  computed: Object.assign({}, L(), {\n    mergedFieldErrors: function mergedFieldErrors() {\n      return this.errors;\n    }\n  }),\n  watch: Object.assign({}, {\n    mergedFieldErrors: {\n      handler: function handler(t) {\n        this.errorObservers.filter(function (t) {\n          return \"input\" === t.type;\n        }).forEach(function (e) {\n          return e.callback(t[e.field] || []);\n        });\n      },\n      immediate: !0\n    },\n    mergedGroupErrors: {\n      handler: function handler(t) {\n        this.errorObservers.filter(function (t) {\n          return \"group\" === t.type;\n        }).forEach(function (e) {\n          return e.callback(t[e.field] || {});\n        });\n      },\n      immediate: !0\n    }\n  }, {\n    \"context.model\": {\n      handler: function handler(t) {\n        a(t[this.index], this.proxy, !0) || this.setValues(t[this.index]);\n      },\n      deep: !0\n    }\n  }),\n  created: function created() {\n    this.applyInitialValues(), this.registerProvider(this);\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.preventCleanup = !0, this.deregisterProvider(this);\n  },\n  methods: Object.assign({}, N(), {\n    setGroupValue: function setGroupValue(t, e) {\n      a(this.proxy[t], e, !0) || this.setFieldValue(t, e);\n    },\n    removeItem: function removeItem() {\n      this.$emit(\"remove\", this.index);\n    }\n  })\n},\n    oe = function oe() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return r(\"FormulateSlot\", {\n    attrs: {\n      name: \"repeatable\",\n      context: t.context,\n      index: t.index,\n      \"remove-item\": t.removeItem\n    }\n  }, [r(t.context.slotComponents.repeatable, t._b({\n    tag: \"component\",\n    attrs: {\n      context: t.context,\n      index: t.index,\n      \"remove-item\": t.removeItem\n    }\n  }, \"component\", t.context.slotProps.repeatable, !1), [r(\"FormulateSlot\", {\n    attrs: {\n      context: t.context,\n      index: t.index,\n      name: \"default\"\n    }\n  })], 1)], 1);\n};\n\noe._withStripped = !0;\n\nvar ie = U({\n  render: oe,\n  staticRenderFns: []\n}, void 0, re, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    ne = {\n  props: {\n    index: {\n      type: Number,\n      default: null\n    },\n    context: {\n      type: Object,\n      required: !0\n    },\n    removeItem: {\n      type: Function,\n      required: !0\n    }\n  }\n},\n    se = function se() {\n  var t = this,\n      e = t.$createElement,\n      r = t._self._c || e;\n  return t.context.repeatable ? r(\"a\", {\n    class: t.context.classes.groupRepeatableRemove,\n    attrs: {\n      \"data-disabled\": t.context.model.length <= t.context.minimum,\n      role: \"button\"\n    },\n    domProps: {\n      textContent: t._s(t.context.removeLabel)\n    },\n    on: {\n      click: function click(e) {\n        return e.preventDefault(), t.removeItem(e);\n      },\n      keypress: function keypress(e) {\n        return !e.type.indexOf(\"key\") && t._k(e.keyCode, \"enter\", 13, e.key, \"Enter\") ? null : t.removeItem(e);\n      }\n    }\n  }) : t._e();\n};\n\nse._withStripped = !0;\n\nvar ae = U({\n  render: se,\n  staticRenderFns: []\n}, void 0, ne, void 0, !1, void 0, !1, void 0, void 0, void 0),\n    le = function le() {\n  this.options = {}, this.defaults = {\n    components: {\n      FormulateSlot: $,\n      FormulateForm: q,\n      FormulateFile: ut,\n      FormulateHelp: st,\n      FormulateLabel: mt,\n      FormulateInput: tt,\n      FormulateErrors: ot,\n      FormulateSchema: k,\n      FormulateAddMore: yt,\n      FormulateGrouping: pt,\n      FormulateInputBox: _t,\n      FormulateInputText: At,\n      FormulateInputFile: kt,\n      FormulateErrorList: Ot,\n      FormulateRepeatable: Dt,\n      FormulateInputGroup: Mt,\n      FormulateInputButton: Tt,\n      FormulateInputSelect: Wt,\n      FormulateInputSlider: Kt,\n      FormulateButtonContent: Xt,\n      FormulateInputTextArea: ee,\n      FormulateRepeatableRemove: ae,\n      FormulateRepeatableProvider: ie\n    },\n    slotComponents: {\n      addMore: \"FormulateAddMore\",\n      buttonContent: \"FormulateButtonContent\",\n      errorList: \"FormulateErrorList\",\n      errors: \"FormulateErrors\",\n      file: \"FormulateFile\",\n      help: \"FormulateHelp\",\n      label: \"FormulateLabel\",\n      prefix: !1,\n      remove: \"FormulateRepeatableRemove\",\n      repeatable: \"FormulateRepeatable\",\n      suffix: !1,\n      uploadAreaMask: \"div\"\n    },\n    slotProps: {},\n    library: n,\n    rules: b,\n    mimes: _,\n    locale: !1,\n    uploader: S,\n    uploadUrl: !1,\n    fileUrlKey: \"url\",\n    uploadJustCompleteDuration: 1e3,\n    errorHandler: function errorHandler(t) {\n      return t;\n    },\n    plugins: [o],\n    locales: {},\n    failedValidation: function failedValidation() {\n      return !1;\n    },\n    idPrefix: \"formulate-\",\n    baseClasses: function baseClasses(t) {\n      return t;\n    },\n    coreClasses: A,\n    classes: {},\n    useInputDecorators: !0,\n    validationNameStrategy: !1\n  }, this.registry = new Map(), this.idRegistry = {};\n};\n\nle.prototype.install = function (t, e) {\n  var r = this;\n  t.prototype.$formulate = this, this.options = this.defaults;\n  var o = this.defaults.plugins;\n\n  for (var i in e && Array.isArray(e.plugins) && e.plugins.length && (o = o.concat(e.plugins)), o.forEach(function (t) {\n    return \"function\" == typeof t ? t(r) : null;\n  }), this.extend(e || {}), this.options.components) {\n    t.component(i, this.options.components[i]);\n  }\n}, le.prototype.nextId = function (t) {\n  var e = !(!t.$route || !t.$route.path) && t.$route.path ? t.$route.path.replace(/[/\\\\.\\s]/g, \"-\") : \"global\";\n  return Object.prototype.hasOwnProperty.call(this.idRegistry, e) || (this.idRegistry[e] = 0), \"\" + this.options.idPrefix + e + \"-\" + ++this.idRegistry[e];\n}, le.prototype.extend = function (t) {\n  if (\"object\" == _typeof(t)) return this.options = this.merge(this.options, t), this;\n  throw new Error(\"Formulate.extend expects an object, was \" + _typeof(t));\n}, le.prototype.merge = function (t, e, o) {\n  void 0 === o && (o = !0);\n  var i = {};\n\n  for (var n in t) {\n    e.hasOwnProperty(n) ? r(e[n]) && r(t[n]) ? i[n] = this.merge(t[n], e[n], o) : o && Array.isArray(t[n]) && Array.isArray(e[n]) ? i[n] = t[n].concat(e[n]) : i[n] = e[n] : i[n] = t[n];\n  }\n\n  for (var s in e) {\n    i.hasOwnProperty(s) || (i[s] = e[s]);\n  }\n\n  return i;\n}, le.prototype.classify = function (t) {\n  return this.options.library.hasOwnProperty(t) ? this.options.library[t].classification : \"unknown\";\n}, le.prototype.classes = function (t) {\n  var e = this,\n      r = this.options.coreClasses(t),\n      o = this.options.baseClasses(r, t);\n  return Object.keys(o).reduce(function (r, i) {\n    var n,\n        s = V(o[i], e.options.classes[i], t);\n    return s = function (t, e, r, o) {\n      return Object.keys(w).reduce(function (e, i) {\n        if (w[i](o)) {\n          var n = \"\" + t + u(i),\n              s = n + \"Class\";\n          if (r[n]) e = V(e, \"string\" == typeof r[n] ? c(r[n]) : r[n], o);\n          if (o[s]) e = V(e, \"string\" == typeof o[s] ? c(o[s]) : o[n + \"Class\"], o);\n        }\n\n        return e;\n      }, e);\n    }(i, s = V(s, t[i + \"Class\"], t), e.options.classes, t), Object.assign(r, ((n = {})[i] = s, n));\n  }, {});\n}, le.prototype.typeProps = function (t) {\n  var e = function e(t) {\n    return Object.keys(t).reduce(function (e, r) {\n      return Array.isArray(t[r]) ? e.concat(t[r]) : e;\n    }, []);\n  },\n      r = e(this.options.slotProps);\n\n  return this.options.library[t] ? r.concat(e(this.options.library[t].slotProps || {})) : r;\n}, le.prototype.slotProps = function (t, e, r) {\n  var o = Array.isArray(this.options.slotProps[e]) ? this.options.slotProps[e] : [],\n      i = this.options.library[t];\n  return i && i.slotProps && Array.isArray(i.slotProps[e]) && (o = o.concat(i.slotProps[e])), o.reduce(function (t, e) {\n    var o;\n    return Object.assign(t, ((o = {})[e] = r[e], o));\n  }, {});\n}, le.prototype.component = function (t) {\n  return !!this.options.library.hasOwnProperty(t) && this.options.library[t].component;\n}, le.prototype.slotComponent = function (t, e) {\n  var r = this.options.library[t];\n  return r && r.slotComponents && r.slotComponents[e] ? r.slotComponents[e] : this.options.slotComponents[e];\n}, le.prototype.rules = function (t) {\n  return void 0 === t && (t = {}), Object.assign({}, this.options.rules, t);\n}, le.prototype.i18n = function (t) {\n  if (t.$i18n) switch (_typeof(t.$i18n.locale)) {\n    case \"string\":\n      return t.$i18n.locale;\n\n    case \"function\":\n      return t.$i18n.locale();\n  }\n  return !1;\n}, le.prototype.getLocale = function (t) {\n  var e = this;\n  return this.selectedLocale || (this.selectedLocale = [this.options.locale, this.i18n(t), \"en\"].reduce(function (t, r) {\n    if (t) return t;\n\n    if (r) {\n      var o = function (t) {\n        return t.split(\"-\").reduce(function (t, e) {\n          return t.length && t.unshift(t[0] + \"-\" + e), t.length ? t : [e];\n        }, []);\n      }(r).find(function (t) {\n        return f(e.options.locales, t);\n      });\n\n      o && (t = o);\n    }\n\n    return t;\n  }, !1)), this.selectedLocale;\n}, le.prototype.setLocale = function (t) {\n  f(this.options.locales, t) && (this.options.locale = t, this.selectedLocale = t, this.registry.forEach(function (t, e) {\n    t.hasValidationErrors();\n  }));\n}, le.prototype.validationMessage = function (t, e, r) {\n  var o = this.options.locales[this.getLocale(r)];\n  return o.hasOwnProperty(t) ? o[t](e) : o.hasOwnProperty(\"default\") ? o.default(e) : \"Invalid field value\";\n}, le.prototype.register = function (t) {\n  \"FormulateForm\" === t.$options.name && t.name && this.registry.set(t.name, t);\n}, le.prototype.deregister = function (t) {\n  \"FormulateForm\" === t.$options.name && t.name && this.registry.has(t.name) && this.registry.delete(t.name);\n}, le.prototype.handle = function (t, e, r) {\n  void 0 === r && (r = !1);\n  var o = r ? t : this.options.errorHandler(t, e);\n  return e && this.registry.has(e) && this.registry.get(e).applyErrors({\n    formErrors: c(o.formErrors),\n    inputErrors: o.inputErrors || {}\n  }), o;\n}, le.prototype.reset = function (t, e) {\n  void 0 === e && (e = {}), this.resetValidation(t), this.setValues(t, e);\n}, le.prototype.submit = function (t) {\n  this.registry.get(t).formSubmitted();\n}, le.prototype.resetValidation = function (t) {\n  var e = this.registry.get(t);\n  e.hideErrors(t), e.namedErrors = [], e.namedFieldErrors = {};\n}, le.prototype.setValues = function (t, e) {\n  e && !Array.isArray(e) && \"object\" == _typeof(e) && this.registry.get(t).setValues(Object.assign({}, e));\n}, le.prototype.getUploader = function () {\n  return this.options.uploader || !1;\n}, le.prototype.getUploadUrl = function () {\n  return this.options.uploadUrl || !1;\n}, le.prototype.getFileUrlKey = function () {\n  return this.options.fileUrlKey || \"url\";\n}, le.prototype.createUpload = function (t, e) {\n  return new y(t, e, this.options);\n}, le.prototype.failedValidation = function (t) {\n  return this.options.failedValidation(this);\n};\nvar ue = new le();\nexport default ue;","map":null,"metadata":{},"sourceType":"module"}