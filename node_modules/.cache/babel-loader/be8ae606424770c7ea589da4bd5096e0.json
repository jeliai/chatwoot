{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * This file is a modified version of prosemirror-suggestions\n * https://github.com/quartzy/prosemirror-suggestions/blob/master/src/suggestions.js\n */\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nexport var triggerCharacters = function triggerCharacters(char) {\n  return function ($position) {\n    var regexp = new RegExp(\"(?:^)?\".concat(char, \"[^\\\\s\").concat(char, \"]*\"), 'g');\n    var textFrom = $position.before();\n    var textTo = $position.end();\n    var text = $position.doc.textBetween(textFrom, textTo, '\\0', '\\0');\n    var match; // eslint-disable-next-line\n\n    while (match = regexp.exec(text)) {\n      var prefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n\n      if (!/^[\\s\\0]?$/.test(prefix)) {\n        // eslint-disable-next-line\n        continue;\n      }\n\n      var from = match.index + $position.start();\n      var to = from + match[0].length;\n\n      if (from < $position.pos && to >= $position.pos) {\n        return {\n          range: {\n            from: from,\n            to: to\n          },\n          text: match[0]\n        };\n      }\n    }\n\n    return null;\n  };\n};\nexport var suggestionsPlugin = function suggestionsPlugin(_ref) {\n  var matcher = _ref.matcher,\n      _ref$suggestionClass = _ref.suggestionClass,\n      suggestionClass = _ref$suggestionClass === void 0 ? 'prosemirror-mention-node' : _ref$suggestionClass,\n      _ref$onEnter = _ref.onEnter,\n      onEnter = _ref$onEnter === void 0 ? function () {\n    return false;\n  } : _ref$onEnter,\n      _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? function () {\n    return false;\n  } : _ref$onChange,\n      _ref$onExit = _ref.onExit,\n      onExit = _ref$onExit === void 0 ? function () {\n    return false;\n  } : _ref$onExit,\n      _ref$onKeyDown = _ref.onKeyDown,\n      onKeyDown = _ref$onKeyDown === void 0 ? function () {\n    return false;\n  } : _ref$onKeyDown;\n  return new Plugin({\n    key: new PluginKey('mentions'),\n    view: function view() {\n      var _this = this;\n\n      return {\n        update: function update(view, prevState) {\n          var prev = _this.key.getState(prevState);\n\n          var next = _this.key.getState(view.state);\n\n          var moved = prev.active && next.active && prev.range.from !== next.range.from;\n          var started = !prev.active && next.active;\n          var stopped = prev.active && !next.active;\n          var changed = !started && !stopped && prev.text !== next.text;\n          if (stopped || moved) onExit({\n            view: view,\n            range: prev.range,\n            text: prev.text\n          });\n          if (changed && !moved) onChange({\n            view: view,\n            range: next.range,\n            text: next.text\n          });\n          if (started || moved) onEnter({\n            view: view,\n            range: next.range,\n            text: next.text\n          });\n        }\n      };\n    },\n    state: {\n      init: function init() {\n        return {\n          active: false,\n          range: {},\n          text: null\n        };\n      },\n      apply: function apply(tr, prev) {\n        var selection = tr.selection;\n\n        var next = _objectSpread({}, prev);\n\n        if (selection.from === selection.to) {\n          if (selection.from < prev.range.from || selection.from > prev.range.to) {\n            next.active = false;\n          }\n\n          var $position = selection.$from;\n          var match = matcher($position);\n\n          if (match) {\n            next.active = true;\n            next.range = match.range;\n            next.text = match.text;\n          } else {\n            next.active = false;\n          }\n        } else {\n          next.active = false;\n        }\n\n        if (!next.active) {\n          next.range = {};\n          next.text = null;\n        }\n\n        return next;\n      }\n    },\n    props: {\n      handleKeyDown: function handleKeyDown(view, event) {\n        var _this$getState = this.getState(view.state),\n            active = _this$getState.active;\n\n        if (!active) return false;\n        return onKeyDown({\n          view: view,\n          event: event\n        });\n      },\n      decorations: function decorations(editorState) {\n        var _this$getState2 = this.getState(editorState),\n            active = _this$getState2.active,\n            range = _this$getState2.range;\n\n        if (!active) return null;\n        return DecorationSet.create(editorState.doc, [Decoration.inline(range.from, range.to, {\n          nodeName: 'span',\n          class: suggestionClass\n        })]);\n      }\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module"}