{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { isOffline } from '../../core/connection';\nimport { Context } from '../../core/context';\nimport { attempt } from '../../core/queue/delivery';\nimport { pWhile } from '../../lib/p-while';\n\nfunction flushQueue(xt, queue) {\n  return __awaiter(this, void 0, void 0, function () {\n    var failedQueue;\n\n    var _this = this;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          failedQueue = [];\n\n          if (isOffline()) {\n            return [2\n            /*return*/\n            , queue];\n          }\n\n          return [4\n          /*yield*/\n          , pWhile(function () {\n            return queue.length > 0 && !isOffline();\n          }, function () {\n            return __awaiter(_this, void 0, void 0, function () {\n              var ctx, result, success;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    ctx = queue.pop();\n\n                    if (!ctx) {\n                      return [2\n                      /*return*/\n                      ];\n                    }\n\n                    return [4\n                    /*yield*/\n                    , attempt(ctx, xt)];\n\n                  case 1:\n                    result = _a.sent();\n                    success = result instanceof Context;\n\n                    if (!success) {\n                      failedQueue.push(ctx);\n                    }\n\n                    return [2\n                    /*return*/\n                    ];\n                }\n              });\n            });\n          }) // re-add failed tasks\n          ];\n\n        case 1:\n          _a.sent(); // re-add failed tasks\n\n\n          failedQueue.map(function (failed) {\n            return queue.pushWithBackoff(failed);\n          });\n          return [2\n          /*return*/\n          , queue];\n      }\n    });\n  });\n}\n\nexport function scheduleFlush(flushing, buffer, xt, scheduleFlush) {\n  var _this = this;\n\n  if (flushing) {\n    return;\n  } // eslint-disable-next-line @typescript-eslint/no-misused-promises\n\n\n  setTimeout(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var isFlushing, newBuffer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            isFlushing = true;\n            return [4\n            /*yield*/\n            , flushQueue(xt, buffer)];\n\n          case 1:\n            newBuffer = _a.sent();\n            isFlushing = false;\n\n            if (buffer.todo > 0) {\n              scheduleFlush(isFlushing, newBuffer, xt, scheduleFlush);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, Math.random() * 5000);\n}","map":null,"metadata":{},"sourceType":"module"}