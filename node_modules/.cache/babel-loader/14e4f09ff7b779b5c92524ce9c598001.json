{"ast":null,"code":"import { __assign, __extends, __spreadArrays } from \"tslib\";\nimport { PriorityQueue } from '.';\nimport { Context } from '../../core/context';\nimport { isBrowser } from '../../core/environment';\nvar loc = {\n  getItem: function getItem() {},\n  setItem: function setItem() {},\n  removeItem: function removeItem() {}\n};\n\ntry {\n  loc = isBrowser() && window.localStorage ? window.localStorage : loc;\n} catch (err) {\n  console.warn('Unable to access localStorage', err);\n}\n\nfunction persisted(key) {\n  var items = loc.getItem(key);\n  return (items ? JSON.parse(items) : []).map(function (p) {\n    return new Context(p.event, p.id);\n  });\n}\n\nfunction persistItems(key, items) {\n  var existing = persisted(key);\n\n  var all = __spreadArrays(items, existing);\n\n  var merged = all.reduce(function (acc, item) {\n    var _a;\n\n    return __assign(__assign({}, acc), (_a = {}, _a[item.id] = item, _a));\n  }, {});\n  loc.setItem(key, JSON.stringify(Object.values(merged)));\n}\n\nfunction seen(key) {\n  var stored = loc.getItem(key);\n  return stored ? JSON.parse(stored) : {};\n}\n\nfunction persistSeen(key, memory) {\n  var stored = seen(key);\n  loc.setItem(key, JSON.stringify(__assign(__assign({}, stored), memory)));\n}\n\nfunction remove(key) {\n  loc.removeItem(key);\n}\n\nvar now = function now() {\n  return new Date().getTime();\n};\n\nfunction mutex(key, onUnlock, attempt) {\n  if (attempt === void 0) {\n    attempt = 0;\n  }\n\n  var lockTimeout = 50;\n  var lockKey = \"persisted-queue:v1:\" + key + \":lock\";\n\n  var expired = function expired(lock) {\n    return new Date().getTime() > lock;\n  };\n\n  var rawLock = loc.getItem(lockKey);\n  var lock = rawLock ? JSON.parse(rawLock) : null;\n  var allowed = lock === null || expired(lock);\n\n  if (allowed) {\n    loc.setItem(lockKey, JSON.stringify(now() + lockTimeout));\n    onUnlock();\n    loc.removeItem(lockKey);\n    return;\n  }\n\n  if (!allowed && attempt < 3) {\n    setTimeout(function () {\n      mutex(key, onUnlock, attempt + 1);\n    }, lockTimeout);\n  } else {\n    throw new Error('Unable to retrieve lock');\n  }\n}\n\nvar PersistedPriorityQueue =\n/** @class */\nfunction (_super) {\n  __extends(PersistedPriorityQueue, _super);\n\n  function PersistedPriorityQueue(maxAttempts, key) {\n    var _this = _super.call(this, maxAttempts, []) || this;\n\n    var itemsKey = \"persisted-queue:v1:\" + key + \":items\";\n    var seenKey = \"persisted-queue:v1:\" + key + \":seen\";\n    var saved = [];\n    var lastSeen = {};\n    mutex(key, function () {\n      try {\n        saved = persisted(itemsKey);\n        lastSeen = seen(seenKey);\n        remove(itemsKey);\n        remove(seenKey);\n        _this.queue = __spreadArrays(saved, _this.queue);\n        _this.seen = __assign(__assign({}, lastSeen), _this.seen);\n      } catch (err) {\n        console.error(err);\n      }\n    });\n    window.addEventListener('beforeunload', function () {\n      if (_this.todo > 0) {\n        var items_1 = __spreadArrays(_this.queue, _this.future);\n\n        try {\n          mutex(key, function () {\n            persistItems(itemsKey, items_1);\n            persistSeen(seenKey, _this.seen);\n          });\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    });\n    return _this;\n  }\n\n  return PersistedPriorityQueue;\n}(PriorityQueue);\n\nexport { PersistedPriorityQueue };","map":null,"metadata":{},"sourceType":"module"}