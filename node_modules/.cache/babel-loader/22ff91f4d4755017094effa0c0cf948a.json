{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.values.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\nimport { MESSAGE_TYPE } from 'widget/helpers/constants';\nimport { isASubmittedFormMessage } from 'shared/helpers/MessageTypeHelper';\nimport getUuid from '../../../helpers/uuid';\nexport var createTemporaryMessage = function createTemporaryMessage(_ref) {\n  var attachments = _ref.attachments,\n      content = _ref.content;\n  var timestamp = new Date().getTime() / 1000;\n  return {\n    id: getUuid(),\n    content: content,\n    attachments: attachments,\n    status: 'in_progress',\n    created_at: timestamp,\n    message_type: MESSAGE_TYPE.INCOMING\n  };\n};\n\nvar getSenderName = function getSenderName(message) {\n  return message.sender ? message.sender.name : '';\n};\n\nvar shouldShowAvatar = function shouldShowAvatar(message, nextMessage) {\n  var currentSender = getSenderName(message);\n  var nextSender = getSenderName(nextMessage);\n  return currentSender !== nextSender || message.message_type !== nextMessage.message_type || isASubmittedFormMessage(nextMessage);\n};\n\nexport var groupConversationBySender = function groupConversationBySender(conversationsForADate) {\n  return conversationsForADate.map(function (message, index) {\n    var showAvatar;\n    var isLastMessage = index === conversationsForADate.length - 1;\n\n    if (isASubmittedFormMessage(message)) {\n      showAvatar = false;\n    } else if (isLastMessage) {\n      showAvatar = true;\n    } else {\n      var nextMessage = conversationsForADate[index + 1];\n      showAvatar = shouldShowAvatar(message, nextMessage);\n    }\n\n    return _objectSpread({\n      showAvatar: showAvatar\n    }, message);\n  });\n};\nexport var findUndeliveredMessage = function findUndeliveredMessage(messageInbox, _ref2) {\n  var content = _ref2.content;\n  return Object.values(messageInbox).filter(function (message) {\n    return message.content === content && message.status === 'in_progress';\n  });\n};\nexport var getNonDeletedMessages = function getNonDeletedMessages(_ref3) {\n  var messages = _ref3.messages;\n  return messages.filter(function (item) {\n    return !(item.content_attributes && item.content_attributes.deleted);\n  });\n};","map":{"version":3,"sources":["/Users/s.dastan/Desktop/chatwoot/chatwoot/app/javascript/widget/store/modules/conversation/helpers.js"],"names":["MESSAGE_TYPE","isASubmittedFormMessage","getUuid","createTemporaryMessage","attachments","content","timestamp","Date","getTime","id","status","created_at","message_type","INCOMING","getSenderName","message","sender","name","shouldShowAvatar","nextMessage","currentSender","nextSender","groupConversationBySender","conversationsForADate","map","index","showAvatar","isLastMessage","length","findUndeliveredMessage","messageInbox","Object","values","filter","getNonDeletedMessages","messages","item","content_attributes","deleted"],"mappings":";;;;;;;;;;;;;;;AAAA,SAASA,YAAT,QAA6B,0BAA7B;AACA,SAASC,uBAAT,QAAwC,kCAAxC;AAEA,OAAOC,OAAP,MAAoB,uBAApB;AACA,OAAO,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,OAA8B;AAAA,MAA3BC,WAA2B,QAA3BA,WAA2B;AAAA,MAAdC,OAAc,QAAdA,OAAc;AAClE,MAAMC,SAAS,GAAG,IAAIC,IAAJ,GAAWC,OAAX,KAAuB,IAAzC;AACA,SAAO;AACLC,IAAAA,EAAE,EAAEP,OAAO,EADN;AAELG,IAAAA,OAAO,EAAPA,OAFK;AAGLD,IAAAA,WAAW,EAAXA,WAHK;AAILM,IAAAA,MAAM,EAAE,aAJH;AAKLC,IAAAA,UAAU,EAAEL,SALP;AAMLM,IAAAA,YAAY,EAAEZ,YAAY,CAACa;AANtB,GAAP;AAQD,CAVM;;AAYP,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,OAAO;AAAA,SAAKA,OAAO,CAACC,MAAR,GAAiBD,OAAO,CAACC,MAAR,CAAeC,IAAhC,GAAuC,EAA5C;AAAA,CAA7B;;AAEA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACH,OAAD,EAAUI,WAAV,EAA0B;AACjD,MAAMC,aAAa,GAAGN,aAAa,CAACC,OAAD,CAAnC;AACA,MAAMM,UAAU,GAAGP,aAAa,CAACK,WAAD,CAAhC;AAEA,SACEC,aAAa,KAAKC,UAAlB,IACAN,OAAO,CAACH,YAAR,KAAyBO,WAAW,CAACP,YADrC,IAEAX,uBAAuB,CAACkB,WAAD,CAHzB;AAKD,CATD;;AAWA,OAAO,IAAMG,yBAAyB,GAAG,SAA5BA,yBAA4B,CAAAC,qBAAqB;AAAA,SAC5DA,qBAAqB,CAACC,GAAtB,CAA0B,UAACT,OAAD,EAAUU,KAAV,EAAoB;AAC5C,QAAIC,UAAJ;AACA,QAAMC,aAAa,GAAGF,KAAK,KAAKF,qBAAqB,CAACK,MAAtB,GAA+B,CAA/D;;AACA,QAAI3B,uBAAuB,CAACc,OAAD,CAA3B,EAAsC;AACpCW,MAAAA,UAAU,GAAG,KAAb;AACD,KAFD,MAEO,IAAIC,aAAJ,EAAmB;AACxBD,MAAAA,UAAU,GAAG,IAAb;AACD,KAFM,MAEA;AACL,UAAMP,WAAW,GAAGI,qBAAqB,CAACE,KAAK,GAAG,CAAT,CAAzC;AACAC,MAAAA,UAAU,GAAGR,gBAAgB,CAACH,OAAD,EAAUI,WAAV,CAA7B;AACD;;AACD;AAASO,MAAAA,UAAU,EAAVA;AAAT,OAAwBX,OAAxB;AACD,GAZD,CAD4D;AAAA,CAAvD;AAeP,OAAO,IAAMc,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACC,YAAD;AAAA,MAAiBzB,OAAjB,SAAiBA,OAAjB;AAAA,SACpC0B,MAAM,CAACC,MAAP,CAAcF,YAAd,EAA4BG,MAA5B,CACE,UAAAlB,OAAO;AAAA,WAAIA,OAAO,CAACV,OAAR,KAAoBA,OAApB,IAA+BU,OAAO,CAACL,MAAR,KAAmB,aAAtD;AAAA,GADT,CADoC;AAAA,CAA/B;AAKP,OAAO,IAAMwB,qBAAqB,GAAG,SAAxBA,qBAAwB,QAAkB;AAAA,MAAfC,QAAe,SAAfA,QAAe;AACrD,SAAOA,QAAQ,CAACF,MAAT,CACL,UAAAG,IAAI;AAAA,WAAI,EAAEA,IAAI,CAACC,kBAAL,IAA2BD,IAAI,CAACC,kBAAL,CAAwBC,OAArD,CAAJ;AAAA,GADC,CAAP;AAGD,CAJM","sourcesContent":["import { MESSAGE_TYPE } from 'widget/helpers/constants';\nimport { isASubmittedFormMessage } from 'shared/helpers/MessageTypeHelper';\n\nimport getUuid from '../../../helpers/uuid';\nexport const createTemporaryMessage = ({ attachments, content }) => {\n  const timestamp = new Date().getTime() / 1000;\n  return {\n    id: getUuid(),\n    content,\n    attachments,\n    status: 'in_progress',\n    created_at: timestamp,\n    message_type: MESSAGE_TYPE.INCOMING,\n  };\n};\n\nconst getSenderName = message => (message.sender ? message.sender.name : '');\n\nconst shouldShowAvatar = (message, nextMessage) => {\n  const currentSender = getSenderName(message);\n  const nextSender = getSenderName(nextMessage);\n\n  return (\n    currentSender !== nextSender ||\n    message.message_type !== nextMessage.message_type ||\n    isASubmittedFormMessage(nextMessage)\n  );\n};\n\nexport const groupConversationBySender = conversationsForADate =>\n  conversationsForADate.map((message, index) => {\n    let showAvatar;\n    const isLastMessage = index === conversationsForADate.length - 1;\n    if (isASubmittedFormMessage(message)) {\n      showAvatar = false;\n    } else if (isLastMessage) {\n      showAvatar = true;\n    } else {\n      const nextMessage = conversationsForADate[index + 1];\n      showAvatar = shouldShowAvatar(message, nextMessage);\n    }\n    return { showAvatar, ...message };\n  });\n\nexport const findUndeliveredMessage = (messageInbox, { content }) =>\n  Object.values(messageInbox).filter(\n    message => message.content === content && message.status === 'in_progress'\n  );\n\nexport const getNonDeletedMessages = ({ messages }) => {\n  return messages.filter(\n    item => !(item.content_attributes && item.content_attributes.deleted)\n  );\n};\n"]},"metadata":{},"sourceType":"module"}