{"ast":null,"code":"import \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptor.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.object.get-own-property-descriptors.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport Vue from 'vue';\nimport { MESSAGE_TYPE } from 'widget/helpers/constants';\nimport { findUndeliveredMessage } from './helpers';\nexport var mutations = {\n  clearConversations: function clearConversations($state) {\n    Vue.set($state, 'conversations', {});\n  },\n  pushMessageToConversation: function pushMessageToConversation($state, message) {\n    var id = message.id,\n        status = message.status,\n        type = message.message_type;\n    var messagesInbox = $state.conversations;\n    var isMessageIncoming = type === MESSAGE_TYPE.INCOMING;\n    var isTemporaryMessage = status === 'in_progress';\n\n    if (!isMessageIncoming || isTemporaryMessage) {\n      Vue.set(messagesInbox, id, message);\n      return;\n    }\n\n    var _findUndeliveredMessa = findUndeliveredMessage(messagesInbox, message),\n        _findUndeliveredMessa2 = _slicedToArray(_findUndeliveredMessa, 1),\n        messageInConversation = _findUndeliveredMessa2[0];\n\n    if (!messageInConversation) {\n      Vue.set(messagesInbox, id, message);\n    } else {\n      Vue.delete(messagesInbox, messageInConversation.id);\n      Vue.set(messagesInbox, id, message);\n    }\n  },\n  updateAttachmentMessageStatus: function updateAttachmentMessageStatus($state, _ref) {\n    var message = _ref.message,\n        tempId = _ref.tempId;\n    var id = message.id;\n    var messagesInbox = $state.conversations;\n    var messageInConversation = messagesInbox[tempId];\n\n    if (messageInConversation) {\n      Vue.delete(messagesInbox, tempId);\n      Vue.set(messagesInbox, id, _objectSpread({}, message));\n    }\n  },\n  setConversationUIFlag: function setConversationUIFlag($state, uiFlags) {\n    $state.uiFlags = _objectSpread(_objectSpread({}, $state.uiFlags), uiFlags);\n  },\n  setConversationListLoading: function setConversationListLoading($state, status) {\n    $state.uiFlags.isFetchingList = status;\n  },\n  setMessagesInConversation: function setMessagesInConversation($state, payload) {\n    if (!payload.length) {\n      $state.uiFlags.allMessagesLoaded = true;\n      return;\n    }\n\n    payload.map(function (message) {\n      return Vue.set($state.conversations, message.id, message);\n    });\n  },\n  updateMessage: function updateMessage($state, _ref2) {\n    var id = _ref2.id,\n        content_attributes = _ref2.content_attributes;\n    $state.conversations[id] = _objectSpread(_objectSpread({}, $state.conversations[id]), {}, {\n      content_attributes: _objectSpread(_objectSpread({}, $state.conversations[id].content_attributes || {}), content_attributes)\n    });\n  },\n  updateMessageMeta: function updateMessageMeta($state, _ref3) {\n    var id = _ref3.id,\n        meta = _ref3.meta;\n    var message = $state.conversations[id];\n    if (!message) return;\n    var newMeta = message.meta ? _objectSpread(_objectSpread({}, message.meta), meta) : _objectSpread({}, meta);\n    Vue.set(message, 'meta', _objectSpread({}, newMeta));\n  },\n  deleteMessage: function deleteMessage($state, id) {\n    var messagesInbox = $state.conversations;\n    Vue.delete(messagesInbox, id);\n  },\n  toggleAgentTypingStatus: function toggleAgentTypingStatus($state, _ref4) {\n    var status = _ref4.status;\n    $state.uiFlags.isAgentTyping = status === 'on';\n  },\n  setMetaUserLastSeenAt: function setMetaUserLastSeenAt($state, lastSeen) {\n    $state.meta.userLastSeenAt = lastSeen;\n  }\n};","map":{"version":3,"sources":["/Users/s.dastan/Desktop/chatwoot/chatwoot/app/javascript/widget/store/modules/conversation/mutations.js"],"names":["Vue","MESSAGE_TYPE","findUndeliveredMessage","mutations","clearConversations","$state","set","pushMessageToConversation","message","id","status","type","message_type","messagesInbox","conversations","isMessageIncoming","INCOMING","isTemporaryMessage","messageInConversation","delete","updateAttachmentMessageStatus","tempId","setConversationUIFlag","uiFlags","setConversationListLoading","isFetchingList","setMessagesInConversation","payload","length","allMessagesLoaded","map","updateMessage","content_attributes","updateMessageMeta","meta","newMeta","deleteMessage","toggleAgentTypingStatus","isAgentTyping","setMetaUserLastSeenAt","lastSeen","userLastSeenAt"],"mappings":"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","sourcesContent":["import Vue from 'vue';\nimport { MESSAGE_TYPE } from 'widget/helpers/constants';\nimport { findUndeliveredMessage } from './helpers';\n\nexport const mutations = {\n  clearConversations($state) {\n    Vue.set($state, 'conversations', {});\n  },\n  pushMessageToConversation($state, message) {\n    const { id, status, message_type: type } = message;\n\n    const messagesInbox = $state.conversations;\n    const isMessageIncoming = type === MESSAGE_TYPE.INCOMING;\n    const isTemporaryMessage = status === 'in_progress';\n\n    if (!isMessageIncoming || isTemporaryMessage) {\n      Vue.set(messagesInbox, id, message);\n      return;\n    }\n\n    const [messageInConversation] = findUndeliveredMessage(\n      messagesInbox,\n      message\n    );\n    if (!messageInConversation) {\n      Vue.set(messagesInbox, id, message);\n    } else {\n      Vue.delete(messagesInbox, messageInConversation.id);\n      Vue.set(messagesInbox, id, message);\n    }\n  },\n\n  updateAttachmentMessageStatus($state, { message, tempId }) {\n    const { id } = message;\n    const messagesInbox = $state.conversations;\n\n    const messageInConversation = messagesInbox[tempId];\n\n    if (messageInConversation) {\n      Vue.delete(messagesInbox, tempId);\n      Vue.set(messagesInbox, id, { ...message });\n    }\n  },\n\n  setConversationUIFlag($state, uiFlags) {\n    $state.uiFlags = {\n      ...$state.uiFlags,\n      ...uiFlags,\n    };\n  },\n\n  setConversationListLoading($state, status) {\n    $state.uiFlags.isFetchingList = status;\n  },\n\n  setMessagesInConversation($state, payload) {\n    if (!payload.length) {\n      $state.uiFlags.allMessagesLoaded = true;\n      return;\n    }\n\n    payload.map(message => Vue.set($state.conversations, message.id, message));\n  },\n\n  updateMessage($state, { id, content_attributes }) {\n    $state.conversations[id] = {\n      ...$state.conversations[id],\n      content_attributes: {\n        ...($state.conversations[id].content_attributes || {}),\n        ...content_attributes,\n      },\n    };\n  },\n\n  updateMessageMeta($state, { id, meta }) {\n    const message = $state.conversations[id];\n    if (!message) return;\n\n    const newMeta = message.meta ? { ...message.meta, ...meta } : { ...meta };\n    Vue.set(message, 'meta', {\n      ...newMeta,\n    });\n  },\n\n  deleteMessage($state, id) {\n    const messagesInbox = $state.conversations;\n    Vue.delete(messagesInbox, id);\n  },\n\n  toggleAgentTypingStatus($state, { status }) {\n    $state.uiFlags.isAgentTyping = status === 'on';\n  },\n\n  setMetaUserLastSeenAt($state, lastSeen) {\n    $state.meta.userLastSeenAt = lastSeen;\n  },\n};\n"]},"metadata":{},"sourceType":"module"}