{"ast":null,"code":"import \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.array.find.js\";\nimport \"core-js/modules/es.symbol.js\";\nimport \"core-js/modules/es.symbol.description.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.symbol.iterator.js\";\nimport \"core-js/modules/es.array.iterator.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.array.slice.js\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport VueRouter from 'vue-router';\nimport { frontendURL } from '../helper/URLHelper';\nimport { clearBrowserSessionCookies } from '../store/utils/api';\nimport authRoute from './auth/auth.routes';\nimport dashboard from './dashboard/dashboard.routes';\nimport login from './login/login.routes';\nimport store from '../store';\nimport { validateLoggedInRoutes } from '../helper/routeHelpers';\nimport AnalyticsHelper from '../helper/AnalyticsHelper';\nvar routes = [].concat(_toConsumableArray(login.routes), _toConsumableArray(dashboard.routes), _toConsumableArray(authRoute.routes));\nwindow.roleWiseRoutes = {\n  agent: [],\n  administrator: []\n}; // generateRoleWiseRoute - updates window object with agent/admin route\n\nvar generateRoleWiseRoute = function generateRoleWiseRoute(route) {\n  route.forEach(function (element) {\n    if (element.children) {\n      generateRoleWiseRoute(element.children);\n    }\n\n    if (element.roles) {\n      element.roles.forEach(function (roleEl) {\n        window.roleWiseRoutes[roleEl].push(element.name);\n      });\n    }\n  });\n}; // Create a object of routes\n// accessible by each role.\n// returns an object with roles as keys and routeArr as values\n\n\ngenerateRoleWiseRoute(routes);\nexport var router = new VueRouter({\n  mode: 'history',\n  routes: routes\n});\nvar unProtectedRoutes = ['login', 'auth_signup', 'auth_reset_password'];\nvar authIgnoreRoutes = ['auth_confirmation', 'pushBack', 'auth_password_edit'];\nvar routeValidators = [{\n  protected: false,\n  loggedIn: true,\n  handler: function handler(_, getters) {\n    var user = getters.getCurrentUser;\n    return \"accounts/\".concat(user.account_id, \"/dashboard\");\n  }\n}, {\n  protected: true,\n  loggedIn: false,\n  handler: function handler() {\n    return 'login';\n  }\n}, {\n  protected: true,\n  loggedIn: true,\n  handler: function handler(to, getters) {\n    return validateLoggedInRoutes(to, getters.getCurrentUser, window.roleWiseRoutes);\n  }\n}, {\n  protected: false,\n  loggedIn: false,\n  handler: function handler() {\n    return null;\n  }\n}];\nexport var validateAuthenticateRoutePermission = function validateAuthenticateRoutePermission(to, from, next, _ref) {\n  var getters = _ref.getters;\n  var isLoggedIn = getters.isLoggedIn;\n  var isProtectedRoute = !unProtectedRoutes.includes(to.name);\n  var strategy = routeValidators.find(function (validator) {\n    return validator.protected === isProtectedRoute && validator.loggedIn === isLoggedIn;\n  });\n  var nextRoute = strategy.handler(to, getters);\n  return nextRoute ? next(frontendURL(nextRoute)) : next();\n};\n\nvar validateSSOLoginParams = function validateSSOLoginParams(to) {\n  var isLoginRoute = to.name === 'login';\n\n  var _ref2 = to.query || {},\n      email = _ref2.email,\n      ssoAuthToken = _ref2.sso_auth_token;\n\n  var hasValidSSOParams = email && ssoAuthToken;\n  return isLoginRoute && hasValidSSOParams;\n};\n\nexport var validateRouteAccess = function validateRouteAccess(to, from, next, _ref3) {\n  var getters = _ref3.getters;\n\n  // Disable navigation to signup page if signups are disabled\n  // Signup route has an attribute (requireSignupEnabled)\n  // defined in it's route definition\n  if (window.chatwootConfig.signupEnabled !== 'true' && to.meta && to.meta.requireSignupEnabled) {\n    return next(frontendURL('login'));\n  } // For routes which doesn't care about authentication, skip validation\n\n\n  if (authIgnoreRoutes.includes(to.name)) {\n    return next();\n  }\n\n  return validateAuthenticateRoutePermission(to, from, next, {\n    getters: getters\n  });\n};\nexport var initalizeRouter = function initalizeRouter() {\n  var userAuthentication = store.dispatch('setUser');\n  router.beforeEach(function (to, from, next) {\n    AnalyticsHelper.page(to.name || '', {\n      path: to.path,\n      name: to.name\n    });\n\n    if (validateSSOLoginParams(to)) {\n      clearBrowserSessionCookies();\n      next();\n      return;\n    }\n\n    userAuthentication.then(function () {\n      if (!to.name) {\n        var _store$getters = store.getters,\n            isLoggedIn = _store$getters.isLoggedIn,\n            user = _store$getters.getCurrentUser;\n\n        if (isLoggedIn) {\n          return next(frontendURL(\"accounts/\".concat(user.account_id, \"/dashboard\")));\n        }\n\n        return next('/app/login');\n      }\n\n      return validateRouteAccess(to, from, next, store);\n    });\n  });\n};\nexport default router;","map":{"version":3,"sources":["/Users/s.dastan/Desktop/chatwoot/chatwoot/app/javascript/dashboard/routes/index.js"],"names":["VueRouter","frontendURL","clearBrowserSessionCookies","authRoute","dashboard","login","store","validateLoggedInRoutes","AnalyticsHelper","routes","window","roleWiseRoutes","agent","administrator","generateRoleWiseRoute","route","forEach","element","children","roles","roleEl","push","name","router","mode","unProtectedRoutes","authIgnoreRoutes","routeValidators","protected","loggedIn","handler","_","getters","user","getCurrentUser","account_id","to","validateAuthenticateRoutePermission","from","next","isLoggedIn","isProtectedRoute","includes","strategy","find","validator","nextRoute","validateSSOLoginParams","isLoginRoute","query","email","ssoAuthToken","sso_auth_token","hasValidSSOParams","validateRouteAccess","chatwootConfig","signupEnabled","meta","requireSignupEnabled","initalizeRouter","userAuthentication","dispatch","beforeEach","page","path","then"],"mappings":"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","sourcesContent":["import VueRouter from 'vue-router';\n\nimport { frontendURL } from '../helper/URLHelper';\nimport { clearBrowserSessionCookies } from '../store/utils/api';\nimport authRoute from './auth/auth.routes';\nimport dashboard from './dashboard/dashboard.routes';\nimport login from './login/login.routes';\nimport store from '../store';\nimport { validateLoggedInRoutes } from '../helper/routeHelpers';\nimport AnalyticsHelper from '../helper/AnalyticsHelper';\n\nconst routes = [...login.routes, ...dashboard.routes, ...authRoute.routes];\n\nwindow.roleWiseRoutes = {\n  agent: [],\n  administrator: [],\n};\n\n// generateRoleWiseRoute - updates window object with agent/admin route\nconst generateRoleWiseRoute = route => {\n  route.forEach(element => {\n    if (element.children) {\n      generateRoleWiseRoute(element.children);\n    }\n    if (element.roles) {\n      element.roles.forEach(roleEl => {\n        window.roleWiseRoutes[roleEl].push(element.name);\n      });\n    }\n  });\n};\n// Create a object of routes\n// accessible by each role.\n// returns an object with roles as keys and routeArr as values\ngenerateRoleWiseRoute(routes);\n\nexport const router = new VueRouter({ mode: 'history', routes });\n\nconst unProtectedRoutes = ['login', 'auth_signup', 'auth_reset_password'];\n\nconst authIgnoreRoutes = [\n  'auth_confirmation',\n  'pushBack',\n  'auth_password_edit',\n];\n\nconst routeValidators = [\n  {\n    protected: false,\n    loggedIn: true,\n    handler: (_, getters) => {\n      const user = getters.getCurrentUser;\n      return `accounts/${user.account_id}/dashboard`;\n    },\n  },\n  {\n    protected: true,\n    loggedIn: false,\n    handler: () => 'login',\n  },\n  {\n    protected: true,\n    loggedIn: true,\n    handler: (to, getters) =>\n      validateLoggedInRoutes(to, getters.getCurrentUser, window.roleWiseRoutes),\n  },\n  {\n    protected: false,\n    loggedIn: false,\n    handler: () => null,\n  },\n];\n\nexport const validateAuthenticateRoutePermission = (\n  to,\n  from,\n  next,\n  { getters }\n) => {\n  const isLoggedIn = getters.isLoggedIn;\n  const isProtectedRoute = !unProtectedRoutes.includes(to.name);\n  const strategy = routeValidators.find(\n    validator =>\n      validator.protected === isProtectedRoute &&\n      validator.loggedIn === isLoggedIn\n  );\n  const nextRoute = strategy.handler(to, getters);\n  return nextRoute ? next(frontendURL(nextRoute)) : next();\n};\n\nconst validateSSOLoginParams = to => {\n  const isLoginRoute = to.name === 'login';\n  const { email, sso_auth_token: ssoAuthToken } = to.query || {};\n  const hasValidSSOParams = email && ssoAuthToken;\n  return isLoginRoute && hasValidSSOParams;\n};\n\nexport const validateRouteAccess = (to, from, next, { getters }) => {\n  // Disable navigation to signup page if signups are disabled\n  // Signup route has an attribute (requireSignupEnabled)\n  // defined in it's route definition\n  if (\n    window.chatwootConfig.signupEnabled !== 'true' &&\n    to.meta &&\n    to.meta.requireSignupEnabled\n  ) {\n    return next(frontendURL('login'));\n  }\n\n  // For routes which doesn't care about authentication, skip validation\n  if (authIgnoreRoutes.includes(to.name)) {\n    return next();\n  }\n\n  return validateAuthenticateRoutePermission(to, from, next, { getters });\n};\n\nexport const initalizeRouter = () => {\n  const userAuthentication = store.dispatch('setUser');\n  router.beforeEach((to, from, next) => {\n    AnalyticsHelper.page(to.name || '', {\n      path: to.path,\n      name: to.name,\n    });\n\n    if (validateSSOLoginParams(to)) {\n      clearBrowserSessionCookies();\n      next();\n      return;\n    }\n\n    userAuthentication.then(() => {\n      if (!to.name) {\n        const { isLoggedIn, getCurrentUser: user } = store.getters;\n        if (isLoggedIn) {\n          return next(frontendURL(`accounts/${user.account_id}/dashboard`));\n        }\n        return next('/app/login');\n      }\n\n      return validateRouteAccess(to, from, next, store);\n    });\n  });\n};\n\nexport default router;\n"]},"metadata":{},"sourceType":"module"}