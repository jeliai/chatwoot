{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { groupBy } from '../../lib/group-by';\nimport { PersistedPriorityQueue } from '../../lib/priority-queue/persisted';\nimport { isOnline } from '../connection';\nimport { Context, ContextCancelation } from '../context';\nimport { Emitter } from '../emitter';\nimport { attempt, ensure } from './delivery';\n\nvar EventQueue =\n/** @class */\nfunction (_super) {\n  __extends(EventQueue, _super);\n\n  function EventQueue(priorityQueue) {\n    var _this = _super.call(this) || this;\n\n    _this.plugins = [];\n    _this.failedInitializations = [];\n    _this.flushing = false;\n    _this.queue = priorityQueue !== null && priorityQueue !== void 0 ? priorityQueue : new PersistedPriorityQueue(4, 'event-queue');\n\n    _this.scheduleFlush();\n\n    return _this;\n  }\n\n  EventQueue.prototype.register = function (ctx, plugin, instance) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , Promise.resolve(plugin.load(ctx, instance)).then(function () {\n              _this.plugins.push(plugin);\n            }).catch(function (err) {\n              if (plugin.type === 'destination') {\n                _this.failedInitializations.push(plugin.name);\n\n                console.warn(plugin.name, err);\n                ctx.log('warn', 'Failed to load destination', {\n                  plugin: plugin.name,\n                  error: err\n                });\n                return;\n              }\n\n              throw err;\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  EventQueue.prototype.deregister = function (ctx, plugin, instance) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 4]);\n\n            if (!plugin.unload) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , Promise.resolve(plugin.unload(ctx, instance))];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            this.plugins = this.plugins.filter(function (p) {\n              return p.name !== plugin.name;\n            });\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _a.sent();\n            ctx.log('warn', 'Failed to unload destination', {\n              plugin: plugin.name,\n              error: e_1\n            });\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  EventQueue.prototype.dispatch = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var willDeliver;\n      return __generator(this, function (_a) {\n        ctx.log('debug', 'Dispatching');\n        ctx.stats.increment('message_dispatched');\n        this.queue.push(ctx);\n        willDeliver = this.subscribeToDelivery(ctx);\n        this.scheduleFlush(0);\n        return [2\n        /*return*/\n        , willDeliver];\n      });\n    });\n  };\n\n  EventQueue.prototype.subscribeToDelivery = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var onDeliver = function onDeliver(flushed, delivered) {\n            if (flushed.isSame(ctx)) {\n              _this.off('flush', onDeliver);\n\n              if (delivered) {\n                resolve(flushed);\n              } else {\n                reject(flushed);\n              }\n            }\n          };\n\n          _this.on('flush', onDeliver);\n        })];\n      });\n    });\n  };\n\n  EventQueue.prototype.dispatchSingle = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        ctx.log('debug', 'Dispatching');\n        ctx.stats.increment('message_dispatched');\n        this.queue.updateAttempts(ctx);\n        ctx.attempts = 1;\n        return [2\n        /*return*/\n        , this.deliver(ctx).catch(function (err) {\n          if (err instanceof ContextCancelation && err.retry === false) {\n            return ctx;\n          }\n\n          var accepted = _this.enqueuRetry(err, ctx);\n\n          if (!accepted) {\n            throw err;\n          }\n\n          return _this.subscribeToDelivery(ctx);\n        })];\n      });\n    });\n  };\n\n  EventQueue.prototype.isEmpty = function () {\n    return this.queue.length === 0;\n  };\n\n  EventQueue.prototype.scheduleFlush = function (timeout) {\n    var _this = this;\n\n    if (timeout === void 0) {\n      timeout = 500;\n    }\n\n    if (this.flushing) {\n      return;\n    }\n\n    this.flushing = true;\n    setTimeout(function () {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _this.flush().then(function () {\n        setTimeout(function () {\n          _this.flushing = false;\n\n          if (_this.queue.length) {\n            _this.scheduleFlush(0);\n          } else {\n            _this.scheduleFlush(500);\n          }\n        }, 0);\n      });\n    }, timeout);\n  };\n\n  EventQueue.prototype.deliver = function (ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var start, done, err_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            start = Date.now();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.flushOne(ctx)];\n\n          case 2:\n            ctx = _a.sent();\n            done = Date.now() - start;\n            ctx.stats.gauge('delivered', done);\n            ctx.log('debug', 'Delivered', ctx.event);\n            return [2\n            /*return*/\n            , ctx];\n\n          case 3:\n            err_1 = _a.sent();\n            ctx.log('error', 'Failed to deliver', err_1);\n            ctx.stats.increment('delivery_failed');\n            throw err_1;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  EventQueue.prototype.enqueuRetry = function (err, ctx) {\n    var notRetriable = err instanceof ContextCancelation && err.retry === false;\n    var retriable = !notRetriable;\n\n    if (retriable) {\n      var accepted = this.queue.pushWithBackoff(ctx);\n      return accepted;\n    }\n\n    return false;\n  };\n\n  EventQueue.prototype.flush = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ctx, err_2, accepted;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.queue.length === 0 || !isOnline()) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            ctx = this.queue.pop();\n\n            if (!ctx) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            ctx.attempts = this.queue.getAttempts(ctx);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.deliver(ctx)];\n\n          case 2:\n            ctx = _a.sent();\n            this.emit('flush', ctx, true);\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_2 = _a.sent();\n            accepted = this.enqueuRetry(err_2, ctx);\n\n            if (!accepted) {\n              this.emit('flush', ctx, false);\n            }\n\n            return [2\n            /*return*/\n            , []];\n\n          case 4:\n            return [2\n            /*return*/\n            , [ctx]];\n        }\n      });\n    });\n  };\n\n  EventQueue.prototype.isReady = function () {\n    // return this.plugins.every((p) => p.isLoaded())\n    // should we wait for every plugin to load?\n    return true;\n  };\n\n  EventQueue.prototype.availableExtensions = function (denyList) {\n    var available = denyList.All === false ? this.plugins.filter(function (p) {\n      return denyList[p.name] !== undefined || p.type !== 'destination';\n    }) : // !== false includes plugins not present on the denyList\n    this.plugins.filter(function (p) {\n      return denyList[p.name] !== false;\n    });\n\n    var _a = groupBy(available, 'type'),\n        _b = _a.before,\n        before = _b === void 0 ? [] : _b,\n        _c = _a.enrichment,\n        enrichment = _c === void 0 ? [] : _c,\n        _d = _a.destination,\n        destination = _d === void 0 ? [] : _d,\n        _e = _a.after,\n        after = _e === void 0 ? [] : _e;\n\n    return {\n      before: before,\n      enrichment: enrichment,\n      destinations: destination,\n      after: after\n    };\n  };\n\n  EventQueue.prototype.flushOne = function (ctx) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _c, before, enrichment, _i, before_1, beforeWare, temp, _d, enrichment_1, enrichmentWare, temp, _e, destinations, after, afterCalls;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            if (!this.isReady()) {\n              throw new Error('Not ready');\n            }\n\n            _c = this.availableExtensions((_a = ctx.event.integrations) !== null && _a !== void 0 ? _a : {}), before = _c.before, enrichment = _c.enrichment;\n            _i = 0, before_1 = before;\n            _f.label = 1;\n\n          case 1:\n            if (!(_i < before_1.length)) return [3\n            /*break*/\n            , 4];\n            beforeWare = before_1[_i];\n            return [4\n            /*yield*/\n            , ensure(ctx, beforeWare)];\n\n          case 2:\n            temp = _f.sent();\n\n            if (temp !== undefined) {\n              ctx = temp;\n            }\n\n            _f.label = 3;\n\n          case 3:\n            _i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            _d = 0, enrichment_1 = enrichment;\n            _f.label = 5;\n\n          case 5:\n            if (!(_d < enrichment_1.length)) return [3\n            /*break*/\n            , 8];\n            enrichmentWare = enrichment_1[_d];\n            return [4\n            /*yield*/\n            , attempt(ctx, enrichmentWare)];\n\n          case 6:\n            temp = _f.sent();\n\n            if (temp instanceof Context) {\n              ctx = temp;\n            }\n\n            _f.label = 7;\n\n          case 7:\n            _d++;\n            return [3\n            /*break*/\n            , 5];\n\n          case 8:\n            _e = this.availableExtensions((_b = ctx.event.integrations) !== null && _b !== void 0 ? _b : {}), destinations = _e.destinations, after = _e.after;\n            return [4\n            /*yield*/\n            , new Promise(function (resolve, reject) {\n              setTimeout(function () {\n                var attempts = destinations.map(function (destination) {\n                  return attempt(ctx, destination);\n                });\n                Promise.all(attempts).then(resolve).catch(reject);\n              }, 0);\n            })];\n\n          case 9:\n            _f.sent();\n\n            ctx.stats.increment('message_delivered');\n            afterCalls = after.map(function (after) {\n              return attempt(ctx, after);\n            });\n            return [4\n            /*yield*/\n            , Promise.all(afterCalls)];\n\n          case 10:\n            _f.sent();\n\n            return [2\n            /*return*/\n            , ctx];\n        }\n      });\n    });\n  };\n\n  return EventQueue;\n}(Emitter);\n\nexport { EventQueue };","map":null,"metadata":{},"sourceType":"module"}