{"version":3,"file":"utils.cjs.production.min.js","sources":["../src/debounce.ts","../src/helpers.ts"],"sourcesContent":["// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n\n/**\n * @func Callback function to be called after delay\n * @delay Delay for debounce in ms\n * @immediate should execute immediately\n * @returns debounced callaback function\n */\nexport const debounce = (\n  func: (args: any) => void,\n  wait: number,\n  immediate?: boolean\n) => {\n  let timeout: number | undefined | null;\n\n  return function() {\n    const context = null;\n    const args = arguments;\n    const later = function() {\n      timeout = null;\n      if (!immediate) func.apply(context, args as any);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout as number);\n    timeout = window.setTimeout(later, wait);\n    if (callNow) func.apply(context, args as any);\n  };\n};\n","import isToday from 'date-fns/isToday';\nimport isYesterday from 'date-fns/isYesterday';\n/**\n * @name Get contrasting text color\n * @description Get contrasting text color from a text color\n * @param bgColor  Background color of text.\n * @returns contrasting text color\n */\nexport const getContrastingTextColor = (bgColor: string): string => {\n  const color = bgColor.replace('#', '');\n  const r = parseInt(color.slice(0, 2), 16);\n  const g = parseInt(color.slice(2, 4), 16);\n  const b = parseInt(color.slice(4, 6), 16);\n  // http://stackoverflow.com/a/3943023/112731\n  return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? '#000000' : '#FFFFFF';\n};\n\n/**\n * @name Get formatted date\n * @description Get date in today, yesterday or any other date format\n * @param date  date\n * @param todayText  Today text\n * @param yesterdayText  Yesterday text\n * @returns formatted date\n */\nexport const formatDate = ({\n  date,\n  todayText,\n  yesterdayText,\n}: {\n  date: string;\n  todayText: string;\n  yesterdayText: string;\n}) => {\n  const dateValue = new Date(date);\n  if (isToday(dateValue)) return todayText;\n  if (isYesterday(dateValue)) return yesterdayText;\n  return date;\n};\n\n/**\n * @name formatTime\n * @description Format time to Hour, Minute and Second\n * @param timeInSeconds  number\n * @returns formatted time\n */\n\nexport const formatTime = (timeInSeconds: number) => {\n  let formattedTime = '';\n  if (timeInSeconds >= 60 && timeInSeconds < 3600) {\n    const minutes = Math.floor(timeInSeconds / 60);\n    formattedTime = `${minutes} Min`;\n    const seconds = minutes === 60 ? 0 : Math.floor(timeInSeconds % 60);\n    return formattedTime + `${seconds > 0 ? ' ' + seconds + ' Sec' : ''}`;\n  }\n  if (timeInSeconds >= 3600 && timeInSeconds < 86400) {\n    const hours = Math.floor(timeInSeconds / 3600);\n    formattedTime = `${hours} Hr`;\n    const minutes =\n      timeInSeconds % 3600 < 60 || hours === 24\n        ? 0\n        : Math.floor((timeInSeconds % 3600) / 60);\n    return formattedTime + `${minutes > 0 ? ' ' + minutes + ' Min' : ''}`;\n  }\n  if (timeInSeconds >= 86400) {\n    const days = Math.floor(timeInSeconds / 86400);\n    formattedTime = `${days} Day`;\n    const hours =\n      timeInSeconds % 86400 < 3600 || days >= 364\n        ? 0\n        : Math.floor((timeInSeconds % 86400) / 3600);\n    return formattedTime + `${hours > 0 ? ' ' + hours + ' Hr' : ''}`;\n  }\n  return `${Math.floor(timeInSeconds)} Sec`;\n};\n\n/**\n * @name trimContent\n * @description Trim a string to max length\n * @param content String to trim\n * @param maxLength Length of the string to trim, default 1024\n * @param ellipsis Boolean to add dots at the end of the string, default false\n * @returns trimmed string\n */\nexport const trimContent = (\n  content: string = '',\n  maxLength: number = 1024,\n  ellipsis: boolean = false\n) => {\n  let trimmedContent = content;\n  if (content.length > maxLength) {\n    trimmedContent = content.substring(0, maxLength);\n  }\n  if (ellipsis) {\n    trimmedContent = trimmedContent + '...';\n  }\n  return trimmedContent;\n};\n"],"names":["func","wait","immediate","timeout","context","args","arguments","later","apply","callNow","clearTimeout","window","setTimeout","date","todayText","yesterdayText","dateValue","Date","isToday","isYesterday","timeInSeconds","formattedTime","minutes","Math","floor","seconds","hours","days","bgColor","color","replace","parseInt","slice","content","maxLength","ellipsis","trimmedContent","length","substring"],"mappings":"qOAWwB,SACtBA,EACAC,EACAC,OAEIC,SAEG,eACCC,EAAU,KACVC,EAAOC,UACPC,EAAQ,WACZJ,EAAU,KACLD,GAAWF,EAAKQ,MAAMJ,EAASC,IAEhCI,EAAUP,IAAcC,EAC9BO,aAAaP,GACbA,EAAUQ,OAAOC,WAAWL,EAAON,GAC/BQ,GAAST,EAAKQ,MAAMJ,EAASC,wBCHX,gBACxBQ,IAAAA,KACAC,IAAAA,UACAC,IAAAA,cAMMC,EAAY,IAAIC,KAAKJ,UACvBK,EAAQF,GAAmBF,EAC3BK,EAAYH,GAAmBD,EAC5BF,sBAUiB,SAACO,OACrBC,EAAgB,MAChBD,GAAiB,IAAMA,EAAgB,KAAM,KACzCE,EAAUC,KAAKC,MAAMJ,EAAgB,IAC3CC,EAAmBC,aACbG,EAAsB,KAAZH,EAAiB,EAAIC,KAAKC,MAAMJ,EAAgB,WACzDC,GAAmBI,EAAU,EAAI,IAAMA,EAAU,OAAS,OAE/DL,GAAiB,MAAQA,EAAgB,MAAO,KAC5CM,EAAQH,KAAKC,MAAMJ,EAAgB,MACzCC,EAAmBK,YACbJ,EACJF,EAAgB,KAAO,IAAgB,KAAVM,EACzB,EACAH,KAAKC,MAAOJ,EAAgB,KAAQ,WACnCC,GAAmBC,EAAU,EAAI,IAAMA,EAAU,OAAS,OAE/DF,GAAiB,MAAO,KACpBO,EAAOJ,KAAKC,MAAMJ,EAAgB,OACxCC,EAAmBM,aACbD,EACJN,EAAgB,MAAQ,MAAQO,GAAQ,IACpC,EACAJ,KAAKC,MAAOJ,EAAgB,MAAS,aACpCC,GAAmBK,EAAQ,EAAI,IAAMA,EAAQ,MAAQ,WAEpDH,KAAKC,MAAMJ,2CAjEgB,SAACQ,OAChCC,EAAQD,EAAQE,QAAQ,IAAK,UAKxB,KAJDC,SAASF,EAAMG,MAAM,EAAG,GAAI,IAIf,KAHbD,SAASF,EAAMG,MAAM,EAAG,GAAI,IAGH,KAFzBD,SAASF,EAAMG,MAAM,EAAG,GAAI,IAEK,IAAM,UAAY,+BAsEpC,SACzBC,EACAC,EACAC,YAFAF,IAAAA,EAAkB,aAClBC,IAAAA,EAAoB,eACpBC,IAAAA,GAAoB,OAEhBC,EAAiBH,SACjBA,EAAQI,OAASH,IACnBE,EAAiBH,EAAQK,UAAU,EAAGJ,IAEpCC,IACFC,GAAkC,OAE7BA"}