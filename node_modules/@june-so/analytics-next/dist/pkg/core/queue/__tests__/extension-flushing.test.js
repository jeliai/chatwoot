import { __assign, __awaiter, __generator } from "tslib";
import { shuffle } from 'lodash';
import { PriorityQueue } from '../../../lib/priority-queue';
import { Context } from '../../context';
import { EventQueue } from '../event-queue';
var fruitBasket = new Context({
    type: 'track',
    event: 'Fruit Basket',
    properties: {
        banana: 'üçå',
        apple: 'üçé',
        grape: 'üçá',
    },
});
var testPlugin = {
    name: 'test',
    type: 'before',
    version: '0.1.0',
    load: function () { return Promise.resolve(); },
    isLoaded: function () { return true; },
};
var ajs = {};
describe('Registration', function () {
    test('can register plugins', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, load, plugin, ctx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    load = jest.fn();
                    plugin = {
                        name: 'test',
                        type: 'before',
                        version: '0.1.0',
                        load: load,
                        isLoaded: function () { return true; },
                    };
                    ctx = Context.system();
                    return [4 /*yield*/, eq.register(ctx, plugin, ajs)];
                case 1:
                    _a.sent();
                    expect(load).toHaveBeenCalledWith(ctx, ajs);
                    return [2 /*return*/];
            }
        });
    }); });
    test('fails if plugin cant be loaded', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, plugin, ctx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    plugin = {
                        name: 'test',
                        type: 'before',
                        version: '0.1.0',
                        load: function () { return Promise.reject(new Error('üëª')); },
                        isLoaded: function () { return false; },
                    };
                    ctx = Context.system();
                    return [4 /*yield*/, expect(eq.register(ctx, plugin, ajs)).rejects.toThrowErrorMatchingInlineSnapshot("\"\uD83D\uDC7B\"")];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    test('allows for destinations to fail registration', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, plugin, ctx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    plugin = {
                        name: 'test',
                        type: 'destination',
                        version: '0.1.0',
                        load: function () { return Promise.reject(new Error('üëª')); },
                        isLoaded: function () { return false; },
                    };
                    ctx = Context.system();
                    return [4 /*yield*/, eq.register(ctx, plugin, ajs)];
                case 1:
                    _a.sent();
                    expect(ctx.logs()[0].level).toEqual('warn');
                    expect(ctx.logs()[0].message).toEqual('Failed to load destination');
                    return [2 /*return*/];
            }
        });
    }); });
});
describe('Plugin flushing', function () {
    test('ensures `before` plugins are run', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, queue, flushed, failedFlush, messages;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    queue = new PriorityQueue(1, []);
                    eq.queue = queue;
                    return [4 /*yield*/, eq.register(Context.system(), __assign(__assign({}, testPlugin), { type: 'before' }), ajs)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, eq.dispatch(fruitBasket)];
                case 2:
                    flushed = _a.sent();
                    expect(flushed.logs().map(function (l) { return l.message; })).toContain('Delivered');
                    return [4 /*yield*/, eq.register(Context.system(), __assign(__assign({}, testPlugin), { name: 'Faulty before', type: 'before', track: function () {
                                throw new Error('aaay');
                            } }), ajs)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, eq
                            .dispatch(new Context({
                            type: 'track',
                        }))
                            .catch(function (ctx) { return ctx; })];
                case 4:
                    failedFlush = _a.sent();
                    messages = failedFlush.logs().map(function (l) { return l.message; });
                    expect(messages).not.toContain('Delivered');
                    return [2 /*return*/];
            }
        });
    }); });
    test('atempts `enrichment` plugins', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, flushed, messages;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    return [4 /*yield*/, eq.register(Context.system(), __assign(__assign({}, testPlugin), { name: 'Faulty enrichment', type: 'enrichment', track: function () {
                                throw new Error('aaay');
                            } }), ajs)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, eq.dispatch(new Context({
                            type: 'track',
                        }))];
                case 2:
                    flushed = _a.sent();
                    messages = flushed.logs().map(function (l) { return l.message; });
                    expect(messages).toContain('Delivered');
                    return [2 /*return*/];
            }
        });
    }); });
    test('attempts `destination` plugins', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, amplitude, fullstory, flushed, messages;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    amplitude = __assign(__assign({}, testPlugin), { name: 'Amplitude', type: 'destination', track: function () { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                throw new Error('Boom!');
                            });
                        }); } });
                    fullstory = __assign(__assign({}, testPlugin), { name: 'FullStory', type: 'destination' });
                    return [4 /*yield*/, eq.register(Context.system(), amplitude, ajs)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, eq.register(Context.system(), fullstory, ajs)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, eq.dispatch(new Context({
                            type: 'track',
                        }))];
                case 3:
                    flushed = _a.sent();
                    messages = flushed
                        .logs()
                        .map(function (l) { return ({ message: l.message, extras: l.extras }); });
                    expect(messages).toMatchInlineSnapshot("\n      Array [\n        Object {\n          \"extras\": undefined,\n          \"message\": \"Dispatching\",\n        },\n        Object {\n          \"extras\": Object {\n            \"plugin\": \"Amplitude\",\n          },\n          \"message\": \"plugin\",\n        },\n        Object {\n          \"extras\": Object {\n            \"plugin\": \"FullStory\",\n          },\n          \"message\": \"plugin\",\n        },\n        Object {\n          \"extras\": Object {\n            \"error\": [Error: Boom!],\n            \"plugin\": \"Amplitude\",\n          },\n          \"message\": \"plugin Error\",\n        },\n        Object {\n          \"extras\": Object {\n            \"type\": \"track\",\n          },\n          \"message\": \"Delivered\",\n        },\n      ]\n    ");
                    return [2 /*return*/];
            }
        });
    }); });
    test('attempts `after` plugins', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, afterFailed, after, flushed, messages;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    afterFailed = __assign(__assign({}, testPlugin), { name: 'after-failed', type: 'after', track: function () { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                throw new Error('Boom!');
                            });
                        }); } });
                    after = __assign(__assign({}, testPlugin), { name: 'after', type: 'after' });
                    return [4 /*yield*/, eq.register(Context.system(), afterFailed, ajs)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, eq.register(Context.system(), after, ajs)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, eq.dispatch(new Context({
                            type: 'track',
                        }))];
                case 3:
                    flushed = _a.sent();
                    messages = flushed
                        .logs()
                        .map(function (l) { return ({ message: l.message, extras: l.extras }); });
                    expect(messages).toMatchInlineSnapshot("\n      Array [\n        Object {\n          \"extras\": undefined,\n          \"message\": \"Dispatching\",\n        },\n        Object {\n          \"extras\": Object {\n            \"plugin\": \"after-failed\",\n          },\n          \"message\": \"plugin\",\n        },\n        Object {\n          \"extras\": Object {\n            \"plugin\": \"after\",\n          },\n          \"message\": \"plugin\",\n        },\n        Object {\n          \"extras\": Object {\n            \"error\": [Error: Boom!],\n            \"plugin\": \"after-failed\",\n          },\n          \"message\": \"plugin Error\",\n        },\n        Object {\n          \"extras\": Object {\n            \"type\": \"track\",\n          },\n          \"message\": \"Delivered\",\n        },\n      ]\n    ");
                    return [2 /*return*/];
            }
        });
    }); });
    test('runs `enrichment` and `before` inline', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, flushed;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    return [4 /*yield*/, eq.register(Context.system(), __assign(__assign({}, testPlugin), { name: 'Kiwi', type: 'enrichment', track: function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    ctx.updateEvent('properties.kiwi', 'ü•ù');
                                    return [2 /*return*/, ctx];
                                });
                            }); } }), ajs)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, eq.register(Context.system(), __assign(__assign({}, testPlugin), { name: 'Watermelon', type: 'enrichment', track: function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    ctx.updateEvent('properties.watermelon', 'üçâ');
                                    return [2 /*return*/, ctx];
                                });
                            }); } }), ajs)];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, eq.register(Context.system(), __assign(__assign({}, testPlugin), { name: 'Before', type: 'before', track: function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    ctx.stats.increment('before');
                                    return [2 /*return*/, ctx];
                                });
                            }); } }), ajs)];
                case 3:
                    _a.sent();
                    return [4 /*yield*/, eq.dispatch(new Context({
                            type: 'track',
                        }))];
                case 4:
                    flushed = _a.sent();
                    expect(flushed.event.properties).toEqual({
                        watermelon: 'üçâ',
                        kiwi: 'ü•ù',
                    });
                    expect(flushed.stats.metrics.map(function (m) { return m.metric; })).toContain('before');
                    return [2 /*return*/];
            }
        });
    }); });
    test('respects execution order', function () { return __awaiter(void 0, void 0, void 0, function () {
        var eq, trace, before, enrichment, enrichmentTwo, destination, plugins, _i, plugins_1, xt;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    eq = new EventQueue();
                    trace = 0;
                    before = __assign(__assign({}, testPlugin), { name: 'Before', type: 'before', track: function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                trace++;
                                expect(trace).toBe(1);
                                return [2 /*return*/, ctx];
                            });
                        }); } });
                    enrichment = __assign(__assign({}, testPlugin), { name: 'Enrichment', type: 'enrichment', track: function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                trace++;
                                expect(trace === 2 || trace === 3).toBe(true);
                                return [2 /*return*/, ctx];
                            });
                        }); } });
                    enrichmentTwo = __assign(__assign({}, testPlugin), { name: 'Enrichment 2', type: 'enrichment', track: function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                trace++;
                                expect(trace === 2 || trace === 3).toBe(true);
                                return [2 /*return*/, ctx];
                            });
                        }); } });
                    destination = __assign(__assign({}, testPlugin), { name: 'Destination', type: 'destination', track: function (ctx) { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                trace++;
                                expect(trace).toBe(4);
                                return [2 /*return*/, ctx];
                            });
                        }); } });
                    plugins = shuffle([before, enrichment, enrichmentTwo, destination]);
                    _i = 0, plugins_1 = plugins;
                    _a.label = 1;
                case 1:
                    if (!(_i < plugins_1.length)) return [3 /*break*/, 4];
                    xt = plugins_1[_i];
                    return [4 /*yield*/, eq.register(Context.system(), xt, ajs)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4: return [4 /*yield*/, eq.dispatch(new Context({
                        type: 'track',
                    }))];
                case 5:
                    _a.sent();
                    expect(trace).toBe(4);
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=extension-flushing.test.js.map