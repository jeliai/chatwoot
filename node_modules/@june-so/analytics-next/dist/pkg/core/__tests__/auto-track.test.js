import { __assign, __awaiter, __generator } from "tslib";
import { JSDOM } from 'jsdom';
import { Analytics } from '../../analytics';
var sleep = function (time) {
    return new Promise(function (resolve) {
        setTimeout(resolve, time);
    });
};
function resolveWhen(condition, timeout) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, _reject) {
                    if (condition()) {
                        resolve();
                        return;
                    }
                    var check = function () {
                        return setTimeout(function () {
                            if (condition()) {
                                resolve();
                            }
                            else {
                                check();
                            }
                        }, timeout);
                    };
                    check();
                })];
        });
    });
}
describe('track helpers', function () {
    describe('trackLink', function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var link;
        var wrap;
        var svg;
        var analytics = new Analytics({ writeKey: 'foo' });
        var mockTrack = jest.spyOn(analytics, 'track');
        beforeEach(function () {
            analytics = new Analytics({ writeKey: 'foo' });
            // @ts-ignore
            global.jQuery = require('jquery');
            var jsd = new JSDOM('', {
                runScripts: 'dangerously',
                resources: 'usable',
            });
            document = jsd.window.document;
            jest.spyOn(console, 'error').mockImplementationOnce(function () { });
            document.querySelector('html').innerHTML = "\n      <html>\n        <body>\n          <a href='foo.com' id='foo'></a>\n          <div id='bar'>\n            <div>\n              <a href='bar.com'></a>\n            </div>\n          </div>\n        </body>\n      </html>";
            link = document.getElementById('foo');
            wrap = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg = document.createElementNS('http://www.w3.org/2000/svg', 'a');
            wrap.appendChild(svg);
            document.body.appendChild(wrap);
            jest.spyOn(window, 'location', 'get').mockReturnValue(__assign({}, window.location));
            mockTrack = jest.spyOn(analytics, 'track');
            // We need to mock the track function for the .catch() call not to break when testing
            // eslint-disable-next-line @typescript-eslint/unbound-method
            mockTrack.mockImplementation(Analytics.prototype.track);
        });
        it('should stay on same page with blank href', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        link.href = '';
                        return [4 /*yield*/, analytics.trackLink(link, 'foo')];
                    case 1:
                        _a.sent();
                        link.click();
                        expect(mockTrack).toHaveBeenCalled();
                        expect(window.location.href).toBe('http://localhost/');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should work with nested link', function () { return __awaiter(void 0, void 0, void 0, function () {
            var nested;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        nested = document.getElementById('bar');
                        return [4 /*yield*/, analytics.trackLink(nested, 'foo')];
                    case 1:
                        _a.sent();
                        nested.click();
                        expect(mockTrack).toHaveBeenCalled();
                        return [4 /*yield*/, resolveWhen(function () { return window.location.href === 'bar.com'; })];
                    case 2:
                        _a.sent();
                        expect(window.location.href).toBe('bar.com');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should make a track call', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackLink(link, 'foo')];
                    case 1:
                        _a.sent();
                        link.click();
                        expect(mockTrack).toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it.only('should still navigate even if the track call fails', function () { return __awaiter(void 0, void 0, void 0, function () {
            var rejected, nested;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockTrack.mockClear();
                        rejected = false;
                        mockTrack.mockImplementationOnce(function () {
                            rejected = true;
                            return Promise.reject(new Error('boo!'));
                        });
                        nested = document.getElementById('bar');
                        return [4 /*yield*/, analytics.trackLink(nested, 'foo')];
                    case 1:
                        _a.sent();
                        nested.click();
                        return [4 /*yield*/, resolveWhen(function () { return rejected; })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, resolveWhen(function () { return window.location.href === 'bar.com'; })];
                    case 3:
                        _a.sent();
                        expect(window.location.href).toBe('bar.com');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should still navigate even if the track call times out', function () { return __awaiter(void 0, void 0, void 0, function () {
            var timedOut, nested;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mockTrack.mockClear();
                        timedOut = false;
                        mockTrack.mockImplementationOnce(function () { return __awaiter(void 0, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, sleep(600)];
                                    case 1:
                                        _a.sent();
                                        timedOut = true;
                                        return [2 /*return*/, Promise.resolve()];
                                }
                            });
                        }); });
                        nested = document.getElementById('bar');
                        return [4 /*yield*/, analytics.trackLink(nested, 'foo')];
                    case 1:
                        _a.sent();
                        nested.click();
                        return [4 /*yield*/, resolveWhen(function () { return window.location.href === 'bar.com'; })];
                    case 2:
                        _a.sent();
                        expect(window.location.href).toBe('bar.com');
                        expect(timedOut).toBe(false);
                        return [4 /*yield*/, resolveWhen(function () { return timedOut; })];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should accept a jquery object for an element', function () { return __awaiter(void 0, void 0, void 0, function () {
            var $link;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        $link = jQuery(link);
                        return [4 /*yield*/, analytics.trackLink($link, 'foo')];
                    case 1:
                        _a.sent();
                        link.click();
                        expect(mockTrack).toBeCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('accepts array of elements', function () { return __awaiter(void 0, void 0, void 0, function () {
            var links;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        links = [link, link];
                        return [4 /*yield*/, analytics.trackLink(links, 'foo')];
                    case 1:
                        _a.sent();
                        link.click();
                        expect(mockTrack).toHaveBeenCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should send an event and properties', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackLink(link, 'event', { property: true })];
                    case 1:
                        _a.sent();
                        link.click();
                        expect(mockTrack).toBeCalledWith('event', { property: true });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should accept an event function', function () { return __awaiter(void 0, void 0, void 0, function () {
            function event(el) {
                return el.nodeName;
            }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackLink(link, event, { foo: 'bar' })];
                    case 1:
                        _a.sent();
                        link.click();
                        expect(mockTrack).toBeCalledWith('A', { foo: 'bar' });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should accept a properties function', function () { return __awaiter(void 0, void 0, void 0, function () {
            function properties(el) {
                return { type: el.nodeName };
            }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackLink(link, 'event', properties)];
                    case 1:
                        _a.sent();
                        link.click();
                        expect(mockTrack).toBeCalledWith('event', { type: 'A' });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should load an href on click', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        link.href = '#test';
                        return [4 /*yield*/, analytics.trackLink(link, 'foo')];
                    case 1:
                        _a.sent();
                        link.click();
                        return [4 /*yield*/, resolveWhen(function () { return window.location.href === '#test'; })];
                    case 2:
                        _a.sent();
                        expect(global.window.location.href).toBe('#test');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should only navigate after the track call has been completed', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        link.href = '#test';
                        return [4 /*yield*/, analytics.trackLink(link, 'foo')];
                    case 1:
                        _a.sent();
                        link.click();
                        return [4 /*yield*/, resolveWhen(function () { return mockTrack.mock.calls.length === 1; })];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, resolveWhen(function () { return window.location.href === '#test'; })];
                    case 3:
                        _a.sent();
                        expect(global.window.location.href).toBe('#test');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should support svg .href attribute', function () { return __awaiter(void 0, void 0, void 0, function () {
            var clickEvent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        svg.setAttribute('href', '#svg');
                        return [4 /*yield*/, analytics.trackLink(svg, 'foo')];
                    case 1:
                        _a.sent();
                        clickEvent = new Event('click');
                        svg.dispatchEvent(clickEvent);
                        return [4 /*yield*/, resolveWhen(function () { return window.location.href === '#svg'; })];
                    case 2:
                        _a.sent();
                        expect(global.window.location.href).toBe('#svg');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should fallback to getAttributeNS', function () { return __awaiter(void 0, void 0, void 0, function () {
            var clickEvent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        svg.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#svg');
                        return [4 /*yield*/, analytics.trackLink(svg, 'foo')];
                    case 1:
                        _a.sent();
                        clickEvent = new Event('click');
                        svg.dispatchEvent(clickEvent);
                        return [4 /*yield*/, resolveWhen(function () { return window.location.href === '#svg'; })];
                    case 2:
                        _a.sent();
                        expect(global.window.location.href).toBe('#svg');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should support xlink:href', function () { return __awaiter(void 0, void 0, void 0, function () {
            var clickEvent;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        svg.setAttribute('xlink:href', '#svg');
                        return [4 /*yield*/, analytics.trackLink(svg, 'foo')];
                    case 1:
                        _a.sent();
                        clickEvent = new Event('click');
                        svg.dispatchEvent(clickEvent);
                        return [4 /*yield*/, resolveWhen(function () { return window.location.href === '#svg'; })];
                    case 2:
                        _a.sent();
                        expect(global.window.location.href).toBe('#svg');
                        return [2 /*return*/];
                }
            });
        }); });
        it('should not load an href for a link with a blank target', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        link.href = '/base/test/support/mock.html';
                        link.target = '_blank';
                        return [4 /*yield*/, analytics.trackLink(link, 'foo')];
                    case 1:
                        _a.sent();
                        link.click();
                        return [4 /*yield*/, sleep(300)];
                    case 2:
                        _a.sent();
                        expect(global.window.location.href).not.toBe('#test');
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe('trackForm', function () {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var form;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var submit;
        var analytics = new Analytics({ writeKey: 'foo' });
        var mockTrack = jest.spyOn(analytics, 'track');
        beforeEach(function () {
            document.querySelector('html').innerHTML = "\n      <html>\n        <body>\n          <form target='_blank' action='/base/test/support/mock.html' id='form'>\n            <input type='submit' id='submit'/>\n          </form>\n        </body>\n      </html>";
            form = document.getElementById('form');
            submit = document.getElementById('submit');
            // @ts-ignore
            global.jQuery = require('jquery');
            mockTrack = jest.spyOn(analytics, 'track');
            // eslint-disable-next-line @typescript-eslint/unbound-method
            mockTrack.mockImplementation(Analytics.prototype.track);
        });
        afterEach(function () {
            window.location.hash = '';
            document.body.removeChild(form);
        });
        it('should not error or send track event on null form', function () { return __awaiter(void 0, void 0, void 0, function () {
            var form;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        form = document.getElementById('fake-form');
                        return [4 /*yield*/, analytics.trackForm(form, 'Signed Up', {
                                plan: 'Premium',
                                revenue: 99.0,
                            })];
                    case 1:
                        _a.sent();
                        submit.click();
                        expect(mockTrack).not.toBeCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should trigger a track on a form submit', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackForm(form, 'foo')];
                    case 1:
                        _a.sent();
                        submit.click();
                        expect(mockTrack).toBeCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should accept a jquery object for an element', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackForm(form, 'foo')];
                    case 1:
                        _a.sent();
                        submit.click();
                        expect(mockTrack).toBeCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should not accept a string for an element', function () { return __awaiter(void 0, void 0, void 0, function () {
            var e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        // @ts-expect-error
                        return [4 /*yield*/, analytics.trackForm('foo')];
                    case 1:
                        // @ts-expect-error
                        _a.sent();
                        submit.click();
                        return [3 /*break*/, 3];
                    case 2:
                        e_1 = _a.sent();
                        expect(e_1 instanceof TypeError).toBe(true);
                        return [3 /*break*/, 3];
                    case 3:
                        expect(mockTrack).not.toBeCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should send an event and properties', function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackForm(form, 'event', { property: true })];
                    case 1:
                        _a.sent();
                        submit.click();
                        expect(mockTrack).toBeCalledWith('event', { property: true });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should accept an event function', function () { return __awaiter(void 0, void 0, void 0, function () {
            function event() {
                return 'event';
            }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackForm(form, event, { foo: 'bar' })];
                    case 1:
                        _a.sent();
                        submit.click();
                        expect(mockTrack).toBeCalledWith('event', { foo: 'bar' });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should accept a properties function', function () { return __awaiter(void 0, void 0, void 0, function () {
            function properties() {
                return { property: true };
            }
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, analytics.trackForm(form, 'event', properties)];
                    case 1:
                        _a.sent();
                        submit.click();
                        expect(mockTrack).toBeCalledWith('event', { property: true });
                        return [2 /*return*/];
                }
            });
        }); });
        it('should call submit after a timeout', function (done) { return __awaiter(void 0, void 0, void 0, function () {
            var submitSpy, mockedTrack;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        submitSpy = jest.spyOn(form, 'submit');
                        mockedTrack = jest.fn();
                        // eslint-disable-next-line @typescript-eslint/unbound-method
                        mockedTrack.mockImplementation(Analytics.prototype.track);
                        analytics.track = mockedTrack;
                        return [4 /*yield*/, analytics.trackForm(form, 'foo')];
                    case 1:
                        _a.sent();
                        submit.click();
                        setTimeout(function () {
                            expect(submitSpy).toHaveBeenCalled();
                            done();
                        }, 500);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should trigger an existing submit handler', function (done) { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        form.addEventListener('submit', function () {
                            done();
                        });
                        return [4 /*yield*/, analytics.trackForm(form, 'foo')];
                    case 1:
                        _a.sent();
                        submit.click();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should trigger an existing jquery submit handler', function (done) { return __awaiter(void 0, void 0, void 0, function () {
            var $form;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        $form = jQuery(form);
                        $form.submit(function () {
                            done();
                        });
                        return [4 /*yield*/, analytics.trackForm(form, 'foo')];
                    case 1:
                        _a.sent();
                        submit.click();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should track on a form submitted via jquery', function () { return __awaiter(void 0, void 0, void 0, function () {
            var $form;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        $form = jQuery(form);
                        return [4 /*yield*/, analytics.trackForm(form, 'foo')];
                    case 1:
                        _a.sent();
                        $form.submit();
                        expect(mockTrack).toBeCalled();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should trigger an existing jquery submit handler on a form submitted via jquery', function (done) { return __awaiter(void 0, void 0, void 0, function () {
            var $form;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        $form = jQuery(form);
                        $form.submit(function () {
                            done();
                        });
                        return [4 /*yield*/, analytics.trackForm(form, 'foo')];
                    case 1:
                        _a.sent();
                        $form.submit();
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
//# sourceMappingURL=auto-track.test.js.map