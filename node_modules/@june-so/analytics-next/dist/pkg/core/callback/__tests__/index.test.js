import { __awaiter, __generator } from "tslib";
import { invokeCallback } from '..';
import { Context } from '../../context';
describe(invokeCallback, function () {
    it('invokes a callback asynchronously', function () { return __awaiter(void 0, void 0, void 0, function () {
        var ctx, fn, returned;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ctx = new Context({
                        type: 'track',
                    });
                    fn = jest.fn();
                    return [4 /*yield*/, invokeCallback(ctx, fn)];
                case 1:
                    returned = _a.sent();
                    expect(fn).toHaveBeenCalledWith(ctx);
                    expect(returned).toBe(ctx);
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores unexisting callbacks', function () { return __awaiter(void 0, void 0, void 0, function () {
        var ctx, returned;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ctx = new Context({
                        type: 'track',
                    });
                    return [4 /*yield*/, invokeCallback(ctx)];
                case 1:
                    returned = _a.sent();
                    expect(returned).toBe(ctx);
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores the callback after a timeout', function () { return __awaiter(void 0, void 0, void 0, function () {
        var ctx, slow, returned, logs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ctx = new Context({
                        type: 'track',
                    });
                    slow = function (_ctx) {
                        return new Promise(function (resolve) {
                            setTimeout(resolve, 200);
                        });
                    };
                    return [4 /*yield*/, invokeCallback(ctx, slow, 50)];
                case 1:
                    returned = _a.sent();
                    expect(returned).toBe(ctx);
                    logs = returned.logs();
                    expect(logs[0].extras).toMatchInlineSnapshot("\n      Object {\n        \"error\": [Error: Promise timed out],\n      }\n    ");
                    expect(logs[0].level).toEqual('warn');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not crash if the callback crashes', function () { return __awaiter(void 0, void 0, void 0, function () {
        var ctx, boo, returned, logs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ctx = new Context({
                        type: 'track',
                    });
                    boo = function (_ctx) {
                        throw new Error('ðŸ‘» boo!');
                    };
                    return [4 /*yield*/, invokeCallback(ctx, boo)];
                case 1:
                    returned = _a.sent();
                    expect(returned).toBe(ctx);
                    logs = returned.logs();
                    expect(logs[0].extras).toMatchInlineSnapshot("\n      Object {\n        \"error\": [Error: \uD83D\uDC7B boo!],\n      }\n    ");
                    expect(logs[0].level).toEqual('warn');
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=index.test.js.map