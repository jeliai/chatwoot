import { __awaiter, __generator } from "tslib";
import jsdom, { JSDOM } from 'jsdom';
import { mocked } from 'ts-jest/utils';
import unfetch from 'unfetch';
import { pWhile } from '../lib/p-while';
import { snippet } from '../tester/__fixtures__/segment-snippet';
var cdnResponse = {
    integrations: {
        Zapier: {
            type: 'server',
        },
        'Amazon S3': {},
        Amplitude: {
            type: 'browser',
        },
        Segmentio: {
            type: 'browser',
        },
        Iterable: {
            type: 'browser',
            name: 'Iterable',
        },
    },
};
var fetchSettings = Promise.resolve({
    json: function () { return Promise.resolve(cdnResponse); },
});
jest.mock('unfetch', function () {
    return jest.fn();
});
describe('standalone bundle', function () {
    var segmentDotCom = "foo";
    var jsd;
    var windowSpy;
    var documentSpy;
    beforeEach(function () {
        jest.restoreAllMocks();
        jest.resetAllMocks();
        jest.spyOn(console, 'warn').mockImplementationOnce(function () { });
        // @ts-ignore ignore Response required fields
        mocked(unfetch).mockImplementation(function () { return fetchSettings; });
        var html = ("\n    <!DOCTYPE html>\n      <head>\n        <script>\n          " + snippet(segmentDotCom, true) + "\n        </script>\n      </head>\n      <body>\n      </body>\n    </html>\n    ").trim();
        var virtualConsole = new jsdom.VirtualConsole();
        jsd = new JSDOM(html, {
            runScripts: 'dangerously',
            resources: 'usable',
            url: 'https://segment.com',
            virtualConsole: virtualConsole,
        });
        windowSpy = jest.spyOn(global, 'window', 'get');
        documentSpy = jest.spyOn(global, 'document', 'get');
        jest.spyOn(console, 'warn').mockImplementationOnce(function () { });
        windowSpy.mockImplementation(function () {
            return jsd.window;
        });
        documentSpy.mockImplementation(function () { return jsd.window.document; });
    });
    it('loads AJS on execution', function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, import('../standalone')];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, pWhile(function () { var _a; return ((_a = window.analytics) === null || _a === void 0 ? void 0 : _a.initialized) !== true; }, function () { })];
                case 2:
                    _a.sent();
                    expect(window.analytics).not.toBeUndefined();
                    expect(window.analytics.initialized).toBe(true);
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=standalone.test.js.map