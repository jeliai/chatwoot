import { PriorityQueue } from '..';
describe('RetryQueue', function () {
    it('accepts new work', function () {
        var queue = new PriorityQueue(10, []);
        queue.push({ id: 'abc' }, { id: 'cde' });
        expect(queue.length).toBe(2);
    });
    it('pops items off the queue', function () {
        var queue = new PriorityQueue(10, []);
        queue.push({ id: 'abc' }, { id: 'cde' });
        expect(queue.pop()).toEqual({ id: 'abc' });
        expect(queue.length).toBe(1);
        expect(queue.pop()).toEqual({ id: 'cde' });
        expect(queue.length).toBe(0);
    });
    it('deprioritizes repeated items', function () {
        var queue = new PriorityQueue(10, []);
        queue.push({ id: 'abc' });
        queue.push({ id: 'abc' });
        queue.push({ id: 'cde' });
        // deprioritizes 'abc' because it was seen twice
        expect(queue.pop()).toEqual({ id: 'cde' });
    });
    it('deprioritizes repeated items even though they have been popped before', function () {
        var queue = new PriorityQueue(10, []);
        queue.push({ id: 'abc' });
        queue.pop();
        queue.push({ id: 'abc' });
        queue.push({ id: 'cde' });
        // a queue does not forget
        expect(queue.pop()).toEqual({ id: 'cde' });
    });
    it('stops accepting an item after attempts have been exausted', function () {
        var queue = new PriorityQueue(3, []);
        queue.push({ id: 'abc' });
        expect(queue.length).toBe(1);
        queue.pop();
        queue.push({ id: 'abc' });
        expect(queue.length).toBe(1);
        queue.pop();
        queue.push({ id: 'abc' });
        expect(queue.length).toBe(1);
        queue.pop();
        queue.push({ id: 'abc' });
        // does not accept it anymore
        expect(queue.length).toBe(0);
    });
});
describe('backoffs', function () {
    afterEach(function () {
        jest.clearAllTimers();
    });
    it('accepts new work', function () {
        var queue = new PriorityQueue(10, []);
        queue.pushWithBackoff({ id: 'abc' });
        queue.pushWithBackoff({ id: 'cde' });
        expect(queue.length).toBe(2);
        expect(queue.todo).toBe(2);
    });
    it('ignores when item has not been worked on', function () {
        var queue = new PriorityQueue(10, []);
        expect(queue.pushWithBackoff({ id: 'abc' })).toBe(true);
        expect(queue.pushWithBackoff({ id: 'abc' })).toBe(false);
        expect(queue.length).toBe(1);
        expect(queue.todo).toBe(1);
    });
    it('schedules as future work when item returns to the queue', function () {
        var queue = new PriorityQueue(10, []);
        queue.pushWithBackoff({ id: 'abc' });
        queue.pop();
        // accepted work
        expect(queue.pushWithBackoff({ id: 'abc' })).toBe(true);
        // not in the main queue yet
        expect(queue.length).toBe(0);
        // present in future work
        expect(queue.todo).toBe(1);
        expect(queue.includes({ id: 'abc' })).toBe(true);
    });
    it('schedules as future work for later', function () {
        jest.useFakeTimers();
        var spy = jest.spyOn(global, 'setTimeout');
        var queue = new PriorityQueue(10, []);
        queue.pushWithBackoff({ id: 'abc' });
        expect(spy).not.toHaveBeenCalled();
        queue.pop();
        queue.pushWithBackoff({ id: 'abc' });
        expect(spy).toHaveBeenCalled();
        var delay = spy.mock.calls[0][1];
        expect(delay).toBeGreaterThan(1000);
    });
    it('increases the delay as work gets requeued', function () {
        jest.useFakeTimers();
        var spy = jest.spyOn(global, 'setTimeout');
        var queue = new PriorityQueue(10, []);
        queue.pushWithBackoff({ id: 'abc' });
        jest.advanceTimersToNextTimer();
        queue.pop();
        queue.pushWithBackoff({ id: 'abc' });
        jest.advanceTimersToNextTimer();
        queue.pop();
        queue.pushWithBackoff({ id: 'abc' });
        jest.advanceTimersToNextTimer();
        queue.pop();
        queue.pushWithBackoff({ id: 'abc' });
        jest.advanceTimersToNextTimer();
        queue.pop();
        var firstDelay = spy.mock.calls[0][1];
        expect(firstDelay).toBeGreaterThan(1000);
        var secondDelay = spy.mock.calls[1][1];
        expect(secondDelay).toBeGreaterThan(2000);
        var thirdDelay = spy.mock.calls[2][1];
        expect(thirdDelay).toBeGreaterThan(3000);
    });
});
//# sourceMappingURL=index.test.js.map