import { Context } from '../../../core/context';
import { PersistedPriorityQueue } from '../persisted';
describe('Persisted Priority Queue', function () {
    beforeEach(function () {
        window.localStorage.clear();
    });
    var key = 'event-queue';
    it('a queue remembers', function () {
        var ctx = new Context({
            type: 'track',
            properties: {
                banana: 'üçå',
            },
        }, 'abc');
        window.localStorage.setItem("persisted-queue:v1:" + key + ":items", JSON.stringify([ctx]));
        window.localStorage.setItem("persisted-queue:v1:" + key + ":seen", JSON.stringify({ abc: 2 }));
        var queue = new PersistedPriorityQueue(3, key);
        var included = queue.includes(ctx);
        expect(included).toBe(true);
        expect(queue.todo).toBe(1);
        expect(queue.getAttempts(ctx)).toBe(2);
    });
    it('a queue always pays their debts', function () {
        var _a, _b;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var onUnload = jest.fn();
        jest
            .spyOn(window, 'addEventListener')
            .mockImplementation(function (evt, handler) {
            if (evt === 'beforeunload') {
                onUnload = handler;
            }
        });
        var ctx = new Context({
            type: 'track',
            properties: {
                banana: 'üçå',
            },
        }, 'abc');
        var queue = new PersistedPriorityQueue(3, key);
        queue.push(ctx);
        onUnload();
        var items = JSON.parse((_a = localStorage.getItem("persisted-queue:v1:" + key + ":items")) !== null && _a !== void 0 ? _a : '');
        var seen = JSON.parse((_b = localStorage.getItem("persisted-queue:v1:" + key + ":seen")) !== null && _b !== void 0 ? _b : '');
        expect(items[0]).toEqual(ctx.toJSON());
        expect(seen).toEqual({ abc: 1 });
    });
    it('a queue has a name', function () {
        var ctx = new Context({
            type: 'track',
            properties: {
                banana: 'üçå',
            },
        }, 'abc');
        window.localStorage.setItem("persisted-queue:v1:different-key:items", JSON.stringify([ctx]));
        var queue = new PersistedPriorityQueue(3, key);
        expect(queue.todo).toBe(0);
        var correctQueue = new PersistedPriorityQueue(3, 'different-key');
        expect(correctQueue.todo).toBe(1);
    });
    describe('merging', function () {
        it('merges queue items with existing data', function () {
            var _a;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var onUnload = jest.fn();
            jest
                .spyOn(window, 'addEventListener')
                .mockImplementation(function (evt, handler) {
                if (evt === 'beforeunload') {
                    onUnload = handler;
                }
            });
            var ctx = new Context({
                type: 'track',
                properties: {
                    banana: 'üçå',
                },
            }, 'abc');
            window.localStorage.setItem("persisted-queue:v1:" + key + ":items", JSON.stringify([ctx]));
            var ctxFromDifferentTab = new Context({
                type: 'page',
                properties: {
                    banana: 'üçå',
                },
            }, 'cde');
            var queue = new PersistedPriorityQueue(3, key);
            expect(queue.includes(ctx)).toBe(true);
            expect(queue.includes(ctxFromDifferentTab)).not.toBe(true);
            // another tab sets these two events again
            window.localStorage.setItem("persisted-queue:v1:" + key + ":items", JSON.stringify([ctx, ctxFromDifferentTab]));
            var newCtx = new Context({
                type: 'identify',
            }, 'id');
            expect(queue.push(newCtx)).toEqual([true]);
            // page is unloaded
            onUnload();
            var persisted = JSON.parse((_a = window.localStorage.getItem("persisted-queue:v1:" + key + ":items")) !== null && _a !== void 0 ? _a : '');
            expect(persisted.length).toBe(3);
            expect(persisted).toContainEqual(ctx.toJSON());
            expect(persisted).toContainEqual(ctxFromDifferentTab.toJSON());
            expect(persisted).toContainEqual(newCtx.toJSON());
        });
    });
    describe('concurrency', function () {
        it('only one tab unloads items from localstorage', function () {
            var ctx = new Context({
                type: 'track',
                properties: {
                    banana: 'üçå',
                },
            }, 'abc');
            window.localStorage.setItem("persisted-queue:v1:" + key + ":items", JSON.stringify([ctx]));
            var firstTabQueue = new PersistedPriorityQueue(3, key);
            var secondTabQueue = new PersistedPriorityQueue(3, key);
            // first tab gets a hold of it
            expect(firstTabQueue.includes(ctx)).toBe(true);
            // it's gone by the time the second tab comes in
            expect(secondTabQueue.includes(ctx)).not.toBe(true);
        });
        it('does not allow multiple tabs to override each other when closed', function () {
            var _a;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var onUnloadFunctions = [];
            jest
                .spyOn(window, 'addEventListener')
                .mockImplementation(function (evt, handler) {
                if (evt === 'beforeunload') {
                    onUnloadFunctions.push(handler);
                }
            });
            var firstTabQueue = new PersistedPriorityQueue(3, key);
            var secondTabQueue = new PersistedPriorityQueue(3, key);
            var firstTabItem = new Context({ type: 'track' }, 'firstTab');
            var secondTabItem = new Context({ type: 'page' }, 'secondTab');
            firstTabQueue.push(firstTabItem);
            secondTabQueue.push(secondTabItem);
            onUnloadFunctions[1]();
            onUnloadFunctions[0]();
            var stored = JSON.parse((_a = window.localStorage.getItem("persisted-queue:v1:" + key + ":items")) !== null && _a !== void 0 ? _a : '');
            expect(stored.length).toBe(2);
        });
    });
});
//# sourceMappingURL=persisted.test.js.map