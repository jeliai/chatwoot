import { __awaiter, __generator } from "tslib";
import { isOffline } from '../../core/connection';
import { PersistedPriorityQueue } from '../../lib/priority-queue/persisted';
import { toFacade } from '../../lib/to-facade';
import batch from './batched-dispatcher';
import standard from './fetch-dispatcher';
import { normalize } from './normalize';
import { scheduleFlush } from './schedule-flush';
function onAlias(analytics, json) {
    var _a, _b, _c, _d;
    var user = analytics.user();
    json.previousId = (_c = (_b = (_a = json.previousId) !== null && _a !== void 0 ? _a : json.from) !== null && _b !== void 0 ? _b : user.id()) !== null && _c !== void 0 ? _c : user.anonymousId();
    json.userId = (_d = json.userId) !== null && _d !== void 0 ? _d : json.to;
    delete json.from;
    delete json.to;
    return json;
}
export function segmentio(analytics, settings, integrations) {
    var _a, _b, _c;
    var buffer = new PersistedPriorityQueue(analytics.queue.queue.maxAttempts, "dest-Segment.io");
    var flushing = false;
    var apiHost = (_a = settings === null || settings === void 0 ? void 0 : settings.apiHost) !== null && _a !== void 0 ? _a : 'api.june.so/sdk';
    var remote = apiHost.includes('localhost')
        ? "http://" + apiHost
        : "https://" + apiHost;
    var client = ((_b = settings === null || settings === void 0 ? void 0 : settings.deliveryStrategy) === null || _b === void 0 ? void 0 : _b.strategy) === 'batching'
        ? batch(apiHost, (_c = settings === null || settings === void 0 ? void 0 : settings.deliveryStrategy) === null || _c === void 0 ? void 0 : _c.config)
        : standard();
    function send(ctx) {
        return __awaiter(this, void 0, void 0, function () {
            var path, json;
            return __generator(this, function (_a) {
                if (isOffline()) {
                    buffer.push(ctx);
                    // eslint-disable-next-line @typescript-eslint/no-use-before-define
                    scheduleFlush(flushing, buffer, segmentio, scheduleFlush);
                    return [2 /*return*/, ctx];
                }
                path = ctx.event.type //.charAt(0)
                ;
                json = toFacade(ctx.event).json();
                if (ctx.event.type === 'track') {
                    delete json.traits;
                }
                if (ctx.event.type === 'alias') {
                    json = onAlias(analytics, json);
                }
                return [2 /*return*/, client
                        .dispatch(remote + "/" + path, normalize(analytics, json, settings, integrations))
                        .then(function () { return ctx; })
                        .catch(function (err) {
                        if (err.type === 'error' || err.message === 'Failed to fetch') {
                            buffer.push(ctx);
                            // eslint-disable-next-line @typescript-eslint/no-use-before-define
                            scheduleFlush(flushing, buffer, segmentio, scheduleFlush);
                        }
                        return ctx;
                    })];
            });
        });
    }
    var segmentio = {
        name: 'Segment.io',
        type: 'after',
        version: '0.1.0',
        isLoaded: function () { return true; },
        load: function () { return Promise.resolve(); },
        track: send,
        identify: send,
        page: send,
        alias: send,
        group: send,
    };
    return segmentio;
}
//# sourceMappingURL=index.js.map