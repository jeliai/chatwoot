import { __awaiter, __generator } from "tslib";
import { segmentio } from '..';
import { Analytics } from '../../../analytics';
// @ts-ignore isOffline mocked dependency is accused as unused
import { isOffline } from '../../../core/connection';
import { pageEnrichment } from '../../page-enrichment';
import { scheduleFlush } from '../schedule-flush';
import { PersistedPriorityQueue } from '../../../lib/priority-queue/persisted';
jest.mock('../schedule-flush');
describe('Segment.io retries', function () {
    var options;
    var analytics;
    var segment;
    var queue;
    beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    jest.resetAllMocks();
                    jest.restoreAllMocks();
                    // @ts-expect-error reassign import
                    isOffline = jest.fn().mockImplementation(function () { return true; });
                    options = { apiKey: 'foo' };
                    analytics = new Analytics({ writeKey: options.apiKey }, { retryQueue: true });
                    queue = new PersistedPriorityQueue(3, "test-Segment.io");
                    // @ts-expect-error reassign import
                    PersistedPriorityQueue = jest.fn().mockImplementation(function () { return queue; });
                    segment = segmentio(analytics, options, {});
                    return [4 /*yield*/, analytics.register(segment, pageEnrichment)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    test('add events to the queue', function () { return __awaiter(void 0, void 0, void 0, function () {
        var ctx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    jest.spyOn(queue, 'push');
                    return [4 /*yield*/, analytics.track('event')];
                case 1:
                    ctx = _a.sent();
                    expect(scheduleFlush).toHaveBeenCalled();
                    /* eslint-disable  @typescript-eslint/unbound-method */
                    expect(queue.push).toHaveBeenCalled();
                    expect(queue.length).toBe(1);
                    expect(ctx.attempts).toBe(1);
                    expect(isOffline).toHaveBeenCalledTimes(2);
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=retries.test.js.map