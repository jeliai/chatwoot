import { __awaiter, __generator } from "tslib";
/* eslint-disable @typescript-eslint/no-floating-promises */
import jsdom from 'jsdom';
import { mocked } from 'ts-jest/utils';
import unfetch from 'unfetch';
import { ajsDestinations, LegacyDestination } from '..';
import { Analytics } from '../../../analytics';
import { Context } from '../../../core/context';
import { tsubMiddleware } from '../../routing-middleware';
import { AMPLITUDE_WRITEKEY } from '../../../__tests__/test-writekeys';
var cdnResponse = {
    integrations: {
        Zapier: {
            type: 'server',
        },
        WithNoVersion: {
            type: 'browser',
        },
        WithProperTypeComponent: {
            versionSettings: {
                componentTypes: ['browser'],
            },
        },
        WithVersionSettings: {
            versionSettings: {
                version: '1.2.3',
            },
            type: 'browser',
        },
        WithVersionOverrides: {
            versionSettings: {
                version: '1.2.3',
                override: '9.9.9',
            },
            type: 'browser',
        },
        'Amazon S3': {},
        Amplitude: {
            type: 'browser',
        },
        Segmentio: {
            type: 'browser',
        },
        Iterable: {
            type: 'browser',
            name: 'Iterable',
        },
    },
    middlewareSettings: {
        routingRules: [
            {
                matchers: [
                    {
                        ir: '["=","event",{"value":"Item Impression"}]',
                        type: 'fql',
                    },
                ],
                scope: 'destinations',
                // eslint-disable-next-line @typescript-eslint/camelcase
                target_type: 'workspace::project::destination',
                transformers: [[{ type: 'drop' }]],
                destinationName: 'Amplitude',
            },
        ],
    },
};
var fetchSettings = Promise.resolve({
    json: function () { return Promise.resolve(cdnResponse); },
});
jest.mock('unfetch', function () {
    return jest.fn();
});
describe('loading ajsDestinations', function () {
    beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            jest.resetAllMocks();
            // @ts-ignore: ignore Response required fields
            mocked(unfetch).mockImplementation(function () { return fetchSettings; });
            return [2 /*return*/];
        });
    }); });
    it('loads version overrides', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations, withVersionSettings, withVersionOverrides, withNoVersion;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations(cdnResponse, {}, {})];
                case 1:
                    destinations = _a.sent();
                    withVersionSettings = destinations.find(function (d) { return d.name === 'WithVersionSettings'; });
                    withVersionOverrides = destinations.find(function (d) { return d.name === 'WithVersionOverrides'; });
                    withNoVersion = destinations.find(function (d) { return d.name === 'WithNoVersion'; });
                    expect(withVersionSettings === null || withVersionSettings === void 0 ? void 0 : withVersionSettings.version).toBe('1.2.3');
                    expect(withVersionOverrides === null || withVersionOverrides === void 0 ? void 0 : withVersionOverrides.version).toBe('9.9.9');
                    expect(withNoVersion === null || withNoVersion === void 0 ? void 0 : withNoVersion.version).toBe('latest');
                    return [2 /*return*/];
            }
        });
    }); });
    // This test should temporary. It must be deleted once we fix the Iterable metadata
    it('ignores Iterable', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations, iterable;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations(cdnResponse, {}, {})];
                case 1:
                    destinations = _a.sent();
                    iterable = destinations.find(function (d) { return d.name === 'Iterable'; });
                    expect(iterable).toBeUndefined();
                    return [2 /*return*/];
            }
        });
    }); });
    describe('versionSettings.components', function () {
        it('ignores [componentType:browser] when bundlingStatus is unbundled', function () { return __awaiter(void 0, void 0, void 0, function () {
            var destinations;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, ajsDestinations({
                            integrations: {
                                'Some server destination': {
                                    versionSettings: {
                                        componentTypes: ['server'],
                                    },
                                    bundlingStatus: 'bundled',
                                },
                                'Device Mode Customer.io': {
                                    versionSettings: {
                                        componentTypes: ['browser'],
                                    },
                                    bundlingStatus: 'bundled',
                                },
                                'Cloud Mode Customer.io': {
                                    versionSettings: {
                                        componentTypes: ['browser'],
                                    },
                                    bundlingStatus: 'unbundled',
                                },
                            },
                        }, {}, {})];
                    case 1:
                        destinations = _a.sent();
                        expect(destinations.length).toBe(1);
                        return [2 /*return*/];
                }
            });
        }); });
        it('loads [componentType:browser] when bundlingStatus is not defined', function () { return __awaiter(void 0, void 0, void 0, function () {
            var destinations;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, ajsDestinations({
                            integrations: {
                                'Some server destination': {
                                    versionSettings: {
                                        componentTypes: ['server'],
                                    },
                                    bundlingStatus: 'bundled',
                                },
                                'Device Mode Customer.io': {
                                    versionSettings: {
                                        componentTypes: ['browser'],
                                    },
                                    bundlingStatus: 'bundled',
                                },
                                'Device Mode no bundling status Customer.io': {
                                    versionSettings: {
                                        componentTypes: ['browser'],
                                    },
                                },
                            },
                        }, {}, {})];
                    case 1:
                        destinations = _a.sent();
                        expect(destinations.length).toBe(2);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    it('loads type:browser legacy ajs destinations from cdn', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations(cdnResponse, {}, {})
                    // ignores segment.io
                ];
                case 1:
                    destinations = _a.sent();
                    // ignores segment.io
                    expect(destinations.length).toBe(5);
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores type:browser when bundlingStatus is unbundled', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations({
                        integrations: {
                            'Some server destination': {
                                type: 'server',
                                bundlingStatus: 'bundled',
                            },
                            'Device Mode Customer.io': {
                                type: 'browser',
                                bundlingStatus: 'bundled',
                            },
                            'Cloud Mode Customer.io': {
                                type: 'browser',
                                bundlingStatus: 'unbundled',
                            },
                        },
                    }, {}, {})];
                case 1:
                    destinations = _a.sent();
                    expect(destinations.length).toBe(1);
                    return [2 /*return*/];
            }
        });
    }); });
    it('loads type:browser when bundlingStatus is not defined', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations({
                        integrations: {
                            'Some server destination': {
                                type: 'server',
                                bundlingStatus: 'bundled',
                            },
                            'Device Mode Customer.io': {
                                type: 'browser',
                                bundlingStatus: 'bundled',
                            },
                            'Device Mode no bundling status Customer.io': {
                                type: 'browser',
                            },
                        },
                    }, {}, {})];
                case 1:
                    destinations = _a.sent();
                    expect(destinations.length).toBe(2);
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores destinations of type:server', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations(cdnResponse, {}, {})];
                case 1:
                    destinations = _a.sent();
                    expect(destinations.find(function (d) { return d.name === 'Zapier'; })).toBe(undefined);
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not load integrations when All:false', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations(cdnResponse, {
                        All: false,
                    }, {})];
                case 1:
                    destinations = _a.sent();
                    expect(destinations.length).toBe(0);
                    return [2 /*return*/];
            }
        });
    }); });
    it('loads integrations when All:false, <integration>: true', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations(cdnResponse, {
                        All: false,
                        Amplitude: true,
                        Segmentio: false,
                    }, {})];
                case 1:
                    destinations = _a.sent();
                    expect(destinations.length).toBe(1);
                    expect(destinations[0].name).toEqual('Amplitude');
                    return [2 /*return*/];
            }
        });
    }); });
    it('adds a tsub middleware for matching rules', function () { return __awaiter(void 0, void 0, void 0, function () {
        var destinations, amplitude;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ajsDestinations(cdnResponse)];
                case 1:
                    destinations = _a.sent();
                    amplitude = destinations.find(function (d) { return d.name === 'Amplitude'; });
                    expect(amplitude === null || amplitude === void 0 ? void 0 : amplitude.middleware.length).toBe(1);
                    return [2 /*return*/];
            }
        });
    }); });
});
describe('settings', function () {
    it('does not delete type=any', function () {
        var dest = new LegacyDestination('Yandex', 'latest', {
            type: 'custom',
        }, {});
        expect(dest.settings['type']).toEqual('custom');
    });
    it('deletes type=browser', function () {
        var dest = new LegacyDestination('Amplitude', 'latest', {
            type: 'browser',
        }, {});
        expect(dest.settings['type']).toBeUndefined();
    });
});
describe('remote loading', function () {
    var loadAmplitude = function () { return __awaiter(void 0, void 0, void 0, function () {
        var ajs, dest;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ajs = new Analytics({
                        writeKey: 'abc',
                    });
                    dest = new LegacyDestination('Amplitude', 'latest', {
                        apiKey: AMPLITUDE_WRITEKEY,
                    }, {});
                    return [4 /*yield*/, dest.load(Context.system(), ajs)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, dest.ready()];
                case 2:
                    _a.sent();
                    return [2 /*return*/, dest];
            }
        });
    }); };
    beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
        var html, jsd, windowSpy;
        return __generator(this, function (_a) {
            jest.restoreAllMocks();
            jest.resetAllMocks();
            html = "\n    <!DOCTYPE html>\n      <head>\n        <script>'hi'</script>\n      </head>\n      <body>\n      </body>\n    </html>\n    ".trim();
            jsd = new jsdom.JSDOM(html, {
                runScripts: 'dangerously',
                resources: 'usable',
                url: 'https://localhost',
            });
            windowSpy = jest.spyOn(global, 'window', 'get');
            windowSpy.mockImplementation(function () { return jsd.window; });
            return [2 /*return*/];
        });
    }); });
    it('loads integrations from the Segment CDN', function () { return __awaiter(void 0, void 0, void 0, function () {
        var sources;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadAmplitude()];
                case 1:
                    _a.sent();
                    sources = Array.from(window.document.querySelectorAll('script'))
                        .map(function (s) { return s.src; })
                        .filter(Boolean);
                    expect(sources).toMatchObject(expect.arrayContaining([
                        'https://cdn.segment.com/next-integrations/integrations/amplitude/latest/amplitude.dynamic.js.gz',
                        expect.stringContaining('https://cdn.segment.com/next-integrations/integrations/vendor/commons'),
                        'https://cdn.amplitude.com/libs/amplitude-5.2.2-min.gz.js',
                    ]));
                    return [2 /*return*/];
            }
        });
    }); });
    it('forwards identify calls to integration', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest, evt;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude()];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'identify');
                    evt = new Context({ type: 'identify' });
                    return [4 /*yield*/, dest.identify(evt)];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.identify).toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
    it('forwards track calls to integration', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude()];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'track');
                    return [4 /*yield*/, dest.track(new Context({ type: 'track' }))];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.track).toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
    it('forwards page calls to integration', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude()];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'page');
                    return [4 /*yield*/, dest.page(new Context({ type: 'page' }))];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.page).toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
    it('applies remote routing rules', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest;
        var _a, _b, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0: return [4 /*yield*/, loadAmplitude()];
                case 1:
                    dest = _d.sent();
                    jest.spyOn(dest.integration, 'track');
                    dest.addMiddleware(tsubMiddleware((_b = (_a = cdnResponse.middlewareSettings) === null || _a === void 0 ? void 0 : _a.routingRules) !== null && _b !== void 0 ? _b : []));
                    // this routing rule should drop the event
                    return [4 /*yield*/, dest.track(new Context({ type: 'track', event: 'Item Impression' }))];
                case 2:
                    // this routing rule should drop the event
                    _d.sent();
                    expect((_c = dest.integration) === null || _c === void 0 ? void 0 : _c.track).not.toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
});
describe('plan', function () {
    beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
        var html, jsd, windowSpy;
        return __generator(this, function (_a) {
            jest.resetAllMocks();
            html = "\n    <!DOCTYPE html>\n      <head>\n        <script>'hi'</script>\n      </head>\n      <body>\n      </body>\n    </html>\n    ".trim();
            jsd = new jsdom.JSDOM(html, {
                runScripts: 'dangerously',
                resources: 'usable',
                url: 'https://localhost',
            });
            windowSpy = jest.spyOn(global, 'window', 'get');
            windowSpy.mockImplementation(function () { return jsd.window; });
            return [2 /*return*/];
        });
    }); });
    var loadAmplitude = function (plan) { return __awaiter(void 0, void 0, void 0, function () {
        var ajs, dest;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ajs = new Analytics({
                        writeKey: 'abc',
                    });
                    dest = new LegacyDestination('amplitude', 'latest', {
                        apiKey: AMPLITUDE_WRITEKEY,
                    }, { plan: plan });
                    return [4 /*yield*/, dest.load(Context.system(), ajs)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, dest.ready()];
                case 2:
                    _a.sent();
                    return [2 /*return*/, dest];
            }
        });
    }); };
    it('does not drop events when no plan is defined', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude({})];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'track');
                    return [4 /*yield*/, dest.track(new Context({ type: 'page', event: 'Track Event' }))];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.track).toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
    it('drops event when event is disabled', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest, ctx;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude({
                        track: {
                            'Track Event': {
                                enabled: false,
                                integrations: { amplitude: false },
                            },
                        },
                    })];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'track');
                    ctx = new Context({ type: 'page', event: 'Track Event' });
                    return [4 /*yield*/, expect(function () { return dest.track(ctx); }).rejects.toMatchInlineSnapshot("\n      ContextCancelation {\n        \"reason\": \"Event Track Event disabled for integration amplitude in tracking plan\",\n        \"retry\": false,\n        \"type\": \"Dropped by plan\",\n      }\n    ")];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.track).not.toHaveBeenCalled();
                    expect(ctx.event.integrations).toMatchInlineSnapshot("\n      Object {\n        \"All\": false,\n        \"Segment.io\": true,\n      }\n    ");
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not drop events with different names', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude({
                        track: {
                            'Fake Track Event': {
                                enabled: true,
                                integrations: { amplitude: false },
                            },
                        },
                    })];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'track');
                    return [4 /*yield*/, dest.track(new Context({ type: 'page', event: 'Track Event' }))];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.track).toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
    it('drops enabled event for matching destination', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest, ctx;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude({
                        track: {
                            'Track Event': {
                                enabled: true,
                                integrations: { amplitude: false },
                            },
                        },
                    })];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'track');
                    ctx = new Context({ type: 'page', event: 'Track Event' });
                    return [4 /*yield*/, expect(function () { return dest.track(ctx); }).rejects.toMatchInlineSnapshot("\n      ContextCancelation {\n        \"reason\": \"Event Track Event disabled for integration amplitude in tracking plan\",\n        \"retry\": false,\n        \"type\": \"Dropped by plan\",\n      }\n    ")];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.track).not.toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not drop enabled event for non-matching destination', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude({
                        track: {
                            'Track Event': {
                                enabled: true,
                                integrations: { 'not amplitude': false },
                            },
                        },
                    })];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'track');
                    return [4 /*yield*/, dest.track(new Context({ type: 'page', event: 'Track Event' }))];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.track).toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not drop enabled event with enabled destination', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude({
                        track: {
                            'Track Event': {
                                enabled: true,
                                integrations: { amplitude: true },
                            },
                        },
                    })];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'track');
                    return [4 /*yield*/, dest.track(new Context({ type: 'page', event: 'Track Event' }))];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.track).toHaveBeenCalled();
                    return [2 /*return*/];
            }
        });
    }); });
    it('properly sets event integrations object with enabled plan', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest, ctx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadAmplitude({
                        track: {
                            'Track Event': {
                                enabled: true,
                                integrations: { amplitude: true },
                            },
                        },
                    })];
                case 1:
                    dest = _a.sent();
                    return [4 /*yield*/, dest.track(new Context({ type: 'page', event: 'Track Event' }))];
                case 2:
                    ctx = _a.sent();
                    expect(ctx.event.integrations).toEqual({ amplitude: true });
                    return [2 /*return*/];
            }
        });
    }); });
    it('sets event integrations object when integration is disabled', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest, ctx;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, loadAmplitude({
                        track: {
                            'Track Event': {
                                enabled: true,
                                integrations: { amplitude: false },
                            },
                        },
                    })];
                case 1:
                    dest = _b.sent();
                    jest.spyOn(dest.integration, 'track');
                    ctx = new Context({ type: 'page', event: 'Track Event' });
                    return [4 /*yield*/, expect(function () { return dest.track(ctx); }).rejects.toMatchInlineSnapshot("\n      ContextCancelation {\n        \"reason\": \"Event Track Event disabled for integration amplitude in tracking plan\",\n        \"retry\": false,\n        \"type\": \"Dropped by plan\",\n      }\n    ")];
                case 2:
                    _b.sent();
                    expect((_a = dest.integration) === null || _a === void 0 ? void 0 : _a.track).not.toHaveBeenCalled();
                    expect(ctx.event.integrations).toEqual({ amplitude: false });
                    return [2 /*return*/];
            }
        });
    }); });
    it('doesnt set event integrations object with different event', function () { return __awaiter(void 0, void 0, void 0, function () {
        var dest, ctx;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadAmplitude({
                        track: {
                            'Track Event': {
                                enabled: true,
                                integrations: { amplitude: true },
                            },
                        },
                    })];
                case 1:
                    dest = _a.sent();
                    return [4 /*yield*/, dest.track(new Context({ type: 'page', event: 'Not Track Event' }))];
                case 2:
                    ctx = _a.sent();
                    expect(ctx.event.integrations).toEqual({});
                    return [2 /*return*/];
            }
        });
    }); });
});
describe('option overrides', function () {
    beforeEach(function () { return __awaiter(void 0, void 0, void 0, function () {
        var html, jsd, windowSpy;
        return __generator(this, function (_a) {
            jest.resetAllMocks();
            html = "\n    <!DOCTYPE html>\n      <head>\n        <script>'hi'</script>\n      </head>\n      <body>\n      </body>\n    </html>\n    ".trim();
            jsd = new jsdom.JSDOM(html, {
                runScripts: 'dangerously',
                resources: 'usable',
                url: 'https://localhost',
            });
            windowSpy = jest.spyOn(global, 'window', 'get');
            windowSpy.mockImplementation(function () { return jsd.window; });
            return [2 /*return*/];
        });
    }); });
    it('accepts settings overrides from options', function () { return __awaiter(void 0, void 0, void 0, function () {
        var cdnSettings, initOptions, destinations, amplitude;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    cdnSettings = {
                        integrations: {
                            Amplitude: {
                                type: 'browser',
                                apiKey: '123',
                                secondOption: '👻',
                            },
                        },
                    };
                    initOptions = {
                        integrations: {
                            Amplitude: {
                                apiKey: 'abc',
                                thirdOption: '🤠',
                            },
                        },
                    };
                    return [4 /*yield*/, ajsDestinations(cdnSettings, {}, initOptions)];
                case 1:
                    destinations = _b.sent();
                    amplitude = destinations[0];
                    return [4 /*yield*/, amplitude.load(Context.system(), {})];
                case 2:
                    _b.sent();
                    return [4 /*yield*/, amplitude.ready()];
                case 3:
                    _b.sent();
                    expect(amplitude.settings).toMatchObject({
                        apiKey: 'abc',
                        secondOption: '👻',
                        thirdOption: '🤠',
                    });
                    expect((_a = amplitude.integration) === null || _a === void 0 ? void 0 : _a.options).toEqual(expect.objectContaining({
                        apiKey: 'abc',
                        secondOption: '👻',
                        thirdOption: '🤠',
                    }));
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=index.test.js.map