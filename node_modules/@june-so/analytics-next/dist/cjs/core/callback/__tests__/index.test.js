"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var __1 = require("..");
var context_1 = require("../../context");
describe(__1.invokeCallback, function () {
    it('invokes a callback asynchronously', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var ctx, fn, returned;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ctx = new context_1.Context({
                        type: 'track',
                    });
                    fn = jest.fn();
                    return [4 /*yield*/, __1.invokeCallback(ctx, fn)];
                case 1:
                    returned = _a.sent();
                    expect(fn).toHaveBeenCalledWith(ctx);
                    expect(returned).toBe(ctx);
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores unexisting callbacks', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var ctx, returned;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ctx = new context_1.Context({
                        type: 'track',
                    });
                    return [4 /*yield*/, __1.invokeCallback(ctx)];
                case 1:
                    returned = _a.sent();
                    expect(returned).toBe(ctx);
                    return [2 /*return*/];
            }
        });
    }); });
    it('ignores the callback after a timeout', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var ctx, slow, returned, logs;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ctx = new context_1.Context({
                        type: 'track',
                    });
                    slow = function (_ctx) {
                        return new Promise(function (resolve) {
                            setTimeout(resolve, 200);
                        });
                    };
                    return [4 /*yield*/, __1.invokeCallback(ctx, slow, 50)];
                case 1:
                    returned = _a.sent();
                    expect(returned).toBe(ctx);
                    logs = returned.logs();
                    expect(logs[0].extras).toMatchInlineSnapshot("\n      Object {\n        \"error\": [Error: Promise timed out],\n      }\n    ");
                    expect(logs[0].level).toEqual('warn');
                    return [2 /*return*/];
            }
        });
    }); });
    it('does not crash if the callback crashes', function () { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
        var ctx, boo, returned, logs;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    ctx = new context_1.Context({
                        type: 'track',
                    });
                    boo = function (_ctx) {
                        throw new Error('ðŸ‘» boo!');
                    };
                    return [4 /*yield*/, __1.invokeCallback(ctx, boo)];
                case 1:
                    returned = _a.sent();
                    expect(returned).toBe(ctx);
                    logs = returned.logs();
                    expect(logs[0].extras).toMatchInlineSnapshot("\n      Object {\n        \"error\": [Error: \uD83D\uDC7B boo!],\n      }\n    ");
                    expect(logs[0].level).toEqual('warn');
                    return [2 /*return*/];
            }
        });
    }); });
});
//# sourceMappingURL=index.test.js.map