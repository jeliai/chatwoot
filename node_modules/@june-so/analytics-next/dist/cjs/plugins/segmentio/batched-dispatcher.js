"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var unfetch_1 = tslib_1.__importDefault(require("unfetch"));
var fetch = unfetch_1.default;
if (typeof window !== 'undefined') {
    // @ts-ignore
    fetch = window.fetch || unfetch_1.default;
}
var MAX_PAYLOAD_SIZE = 500;
function kilobytes(buffer) {
    var size = encodeURI(JSON.stringify(buffer)).split(/%..|./).length - 1;
    return size / 1024;
}
/**
 * Checks if the payload is over or close to
 * the maximum payload size allowed by tracking
 * API.
 */
function approachingTrackingAPILimit(buffer) {
    return kilobytes(buffer) >= MAX_PAYLOAD_SIZE - 50;
}
function chunks(batch) {
    var result = [];
    var index = 0;
    batch.forEach(function (item) {
        var size = kilobytes(result[index]);
        if (size >= 64) {
            index++;
        }
        if (result[index]) {
            result[index].push(item);
        }
        else {
            result[index] = [item];
        }
    });
    return result;
}
function batch(apiHost, config) {
    var _this = this;
    var _a, _b;
    var buffer = [];
    var flushing = false;
    var limit = (_a = config === null || config === void 0 ? void 0 : config.size) !== null && _a !== void 0 ? _a : 10;
    var timeout = (_b = config === null || config === void 0 ? void 0 : config.timeout) !== null && _b !== void 0 ? _b : 5000;
    function flush() {
        var _a;
        if (flushing) {
            return;
        }
        flushing = true;
        var batch = buffer.map(function (_a) {
            var _url = _a[0], blob = _a[1];
            return blob;
        });
        buffer = [];
        flushing = false;
        var writeKey = (_a = batch[0]) === null || _a === void 0 ? void 0 : _a.writeKey;
        return fetch("https://" + apiHost + "/b", {
            // @ts-ignore
            headers: {
                'Content-Type': 'application/json',
            },
            method: 'post',
            body: JSON.stringify({ batch: batch, writeKey: writeKey }),
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    var schedule = scheduleFlush();
    function scheduleFlush() {
        return setTimeout(function () {
            schedule = undefined;
            if (buffer.length && !flushing) {
                flush();
            }
        }, timeout);
    }
    window.addEventListener('beforeunload', function () {
        if (buffer.length === 0) {
            return;
        }
        var batch = buffer.map(function (_a) {
            var _url = _a[0], blob = _a[1];
            return blob;
        });
        var chunked = chunks(batch);
        var reqs = chunked.map(function (chunk) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var remote, writeKey;
            var _a;
            return tslib_1.__generator(this, function (_b) {
                if (chunk.length === 0) {
                    return [2 /*return*/];
                }
                remote = "https://" + apiHost + "/b";
                writeKey = (_a = chunk[0]) === null || _a === void 0 ? void 0 : _a.writeKey;
                return [2 /*return*/, fetch(remote, {
                        // @ts-expect-error
                        keepalive: true,
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        method: 'post',
                        body: JSON.stringify({ batch: chunk, writeKey: writeKey }),
                    })];
            });
        }); });
        Promise.all(reqs).catch(console.error);
    });
    function dispatch(url, body) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var bufferOverflow;
            return tslib_1.__generator(this, function (_a) {
                buffer.push([url, body]);
                bufferOverflow = buffer.length >= limit || approachingTrackingAPILimit(buffer);
                if (bufferOverflow && !flushing) {
                    flush();
                }
                else {
                    if (!schedule) {
                        schedule = scheduleFlush();
                    }
                }
                return [2 /*return*/, true];
            });
        });
    }
    return {
        dispatch: dispatch,
    };
}
exports.default = batch;
//# sourceMappingURL=batched-dispatcher.js.map