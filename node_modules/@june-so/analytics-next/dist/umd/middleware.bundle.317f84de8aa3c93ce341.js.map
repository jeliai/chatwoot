{"version":3,"file":"middleware.bundle.317f84de8aa3c93ce341.js","mappings":";;;;;;;;;;;;;;;;;;;AAAgE;AAGhB;AACa;AAoBtD,SAAe,0BAA0B,CAC9C,WAAmB,EACnB,GAAiB,EACjB,UAA2C;0EAC1C,OAAO;QACR,SAAe,eAAe,CAC5B,KAAmB,EACnB,EAAiC;kFAChC,OAAO;;;;;;4BACJ,UAAU,GAAG,KAAK;4BAClB,aAAa,GAAwB,IAAI;4BAE7C,qBAAM,0DAAS,CACb,EAAE,CAAC;oCACD,OAAO,EAAE,wDAAQ,CAAC,KAAK,EAAE;wCACvB,KAAK,EAAE,IAAI;wCACX,QAAQ,EAAE,KAAK;qCAChB,CAAC;oCACF,WAAW,EAAE,WAAW;oCACxB,IAAI,YAAC,GAAG;wCACN,UAAU,GAAG,IAAI;wCAEjB,IAAI,GAAG,KAAK,IAAI,EAAE;4CAChB,aAAa,GAAG,IAAI;yCACrB;wCAED,IAAI,GAAG,EAAE;4CACP,aAAa,GAAG,GAAG,CAAC,GAAG;yCACxB;oCACH,CAAC;iCACF,CAAC,CACH;;4BAnBD,SAmBC;4BAED,IAAI,CAAC,UAAU,IAAI,aAAa,KAAK,IAAI,EAAE;gCACzC,aAAa,GAAG,aAA6B;gCAC7C,aAAa,CAAC,YAAY,GAAG,oGACxB,KAAK,CAAC,YAAY,gBACpB,WAAW,IAAG,KAAK,MACrB;6BACF;4BAED,sBAAO,aAAa;;;;SACrB;;;;;0BAE0B,EAAV,yBAAU;;;yBAAV,yBAAU;oBAAhB,EAAE;oBACI,qBAAM,eAAe,CAAC,GAAG,EAAE,EAAE,CAAC;;oBAAvC,MAAM,GAAG,SAA8B;oBAC7C,IAAI,MAAM,KAAK,IAAI,EAAE;wBACnB,sBAAO,IAAI;qBACZ;oBACD,GAAG,GAAG,MAAM;;;oBALG,IAAU;;wBAQ3B,sBAAO,GAAG;;;;CACX;AAEM,SAAS,sBAAsB,CACpC,EAAsB,EACtB,YAA0C;IAE1C,SAAe,KAAK,CAAC,GAAY;8EAAG,OAAO;;;;;wBACrC,UAAU,GAAG,KAAK;wBAEtB,qBAAM,0DAAS,CACb,EAAE,CAAC;gCACD,OAAO,EAAE,wDAAQ,CAAC,GAAG,CAAC,KAAK,EAAE;oCAC3B,KAAK,EAAE,IAAI;oCACX,QAAQ,EAAE,KAAK;iCAChB,CAAC;gCACF,YAAY,EAAE,YAAY,aAAZ,YAAY,cAAZ,YAAY,GAAI,EAAE;gCAChC,IAAI,YAAC,GAAG;oCACN,UAAU,GAAG,IAAI;oCACjB,IAAI,GAAG,EAAE;wCACP,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,GAAG;qCACpB;gCACH,CAAC;6BACF,CAAC,CACH;;wBAdD,SAcC;wBAED,IAAI,CAAC,UAAU,EAAE;4BACf,MAAM,IAAI,6DAAkB,CAAC;gCAC3B,KAAK,EAAE,KAAK;gCACZ,IAAI,EAAE,yBAAyB;gCAC/B,MAAM,EAAE,oCAAoC;6BAC7C,CAAC;yBACH;wBAED,sBAAO,GAAG;;;;KACX;IAED,OAAO;QACL,IAAI,EAAE,uBAAqB,EAAE,CAAC,IAAM;QACpC,IAAI,EAAE,QAAQ;QACd,OAAO,EAAE,OAAO;QAEhB,QAAQ,EAAE,cAAe,WAAI,EAAJ,CAAI;QAC7B,IAAI,EAAE,UAAC,GAAG,IAAuB,cAAO,CAAC,OAAO,CAAC,GAAG,CAAC,EAApB,CAAoB;QAErD,KAAK,EAAE,KAAK;QACZ,IAAI,EAAE,KAAK;QACX,QAAQ,EAAE,KAAK;QACf,KAAK,EAAE,KAAK;QACZ,KAAK,EAAE,KAAK;KACb;AACH,CAAC","sources":["webpack://@june-so/analytics-next/./src/plugins/middleware/index.ts"],"sourcesContent":["import { Context, ContextCancelation } from '../../core/context'\nimport { SegmentEvent } from '../../core/events'\nimport { Plugin } from '../../core/plugin'\nimport { asPromise } from '../../lib/as-promise'\nimport { SegmentFacade, toFacade } from '../../lib/to-facade'\n\nexport interface MiddlewareParams {\n  payload: SegmentFacade\n\n  integrations?: SegmentEvent['integrations']\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport interface DestinationMiddlewareParams {\n  payload: SegmentFacade\n  integration: string\n  next: (payload: MiddlewareParams['payload'] | null) => void\n}\n\nexport type MiddlewareFunction = (middleware: MiddlewareParams) => void\nexport type DestinationMiddlewareFunction = (\n  middleware: DestinationMiddlewareParams\n) => void\n\nexport async function applyDestinationMiddleware(\n  destination: string,\n  evt: SegmentEvent,\n  middleware: DestinationMiddlewareFunction[]\n): Promise<SegmentEvent | null> {\n  async function applyMiddleware(\n    event: SegmentEvent,\n    fn: DestinationMiddlewareFunction\n  ): Promise<SegmentEvent | null> {\n    let nextCalled = false\n    let returnedEvent: SegmentEvent | null = null\n\n    await asPromise(\n      fn({\n        payload: toFacade(event, {\n          clone: true,\n          traverse: false,\n        }),\n        integration: destination,\n        next(evt) {\n          nextCalled = true\n\n          if (evt === null) {\n            returnedEvent = null\n          }\n\n          if (evt) {\n            returnedEvent = evt.obj\n          }\n        },\n      })\n    )\n\n    if (!nextCalled && returnedEvent !== null) {\n      returnedEvent = returnedEvent as SegmentEvent\n      returnedEvent.integrations = {\n        ...event.integrations,\n        [destination]: false,\n      }\n    }\n\n    return returnedEvent\n  }\n\n  for (const md of middleware) {\n    const result = await applyMiddleware(evt, md)\n    if (result === null) {\n      return null\n    }\n    evt = result\n  }\n\n  return evt\n}\n\nexport function sourceMiddlewarePlugin(\n  fn: MiddlewareFunction,\n  integrations: SegmentEvent['integrations']\n): Plugin {\n  async function apply(ctx: Context): Promise<Context> {\n    let nextCalled = false\n\n    await asPromise(\n      fn({\n        payload: toFacade(ctx.event, {\n          clone: true,\n          traverse: false,\n        }),\n        integrations: integrations ?? {},\n        next(evt) {\n          nextCalled = true\n          if (evt) {\n            ctx.event = evt.obj\n          }\n        },\n      })\n    )\n\n    if (!nextCalled) {\n      throw new ContextCancelation({\n        retry: false,\n        type: 'middleware_cancellation',\n        reason: 'Middleware `next` function skipped',\n      })\n    }\n\n    return ctx\n  }\n\n  return {\n    name: `Source Middleware ${fn.name}`,\n    type: 'before',\n    version: '0.1.0',\n\n    isLoaded: (): boolean => true,\n    load: (ctx): Promise<Context> => Promise.resolve(ctx),\n\n    track: apply,\n    page: apply,\n    identify: apply,\n    alias: apply,\n    group: apply,\n  }\n}\n"],"names":[],"sourceRoot":""}